{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hyperlinked Twin","text":"<p>This website is a hyperlinked twin of a Spoofax language project code repository. The website navigation hierarchy corresponds to the repository file hierarchy, and the code displayed on each page is a verbatim copy of the raw code in the corresponding file.</p> <p>Hyperlinked twins support precise name-based code navigation online in ordinary web browsers:</p> <ul> <li>Simply click on a name reference to jump to the first declaration of the name.</li> <li>Click on a declaration to display a modal with links to all the references to the declaration.<sup>1</sup></li> </ul> <p>The sources of the webpages were generated using Spoofax from the analysed language project. The hyperlinks added to names were generated from the name binding analysis used by Spoofax, and the syntax highlighting corresponds closely to that displayed when browsing files in Spoofax.</p> <p>The aim is for a future release of Spoofax to support generation of hyperlinked twin websites with code in all Spoofax meta-languages.</p> <ol> <li> <p>When there is only one reference to a declaration, \u200b    clicking on the declaration jumps directly to the reference. \u200b    When there are no references to a declaration, \u200b    clicking on it has no effect.\u00a0\u21a9</p> </li> </ol>"},{"location":"webdslstatix/","title":"WebDSL","text":"<p> webdsl/webdsl-statix</p>"},{"location":"webdslstatix/#reference","title":"Reference","text":"<p>Max de Krieger: Modernizing the WebDSL Front-End: A Case Study in SDF3 and Statix, Master thesis, TU Delft, 2022</p>"},{"location":"webdslstatix/#syntax","title":"Syntax","text":"<p><code>syntax/webdsl-statix.sdf3</code></p> <p>The syntax of WedDSL is specified in SDF3.</p>"},{"location":"webdslstatix/#name-binding","title":"Name binding","text":"<p><code>trans/statics.stx</code></p> <p>The name binding of WebDSL is specified in Statix.</p> <p>To do</p> <ul> <li> Check for broken links</li> <li> Make Statix highlighting consistent with that specified in the Statix language project.</li> </ul>"},{"location":"webdslstatix/src-gen/statix/signatures/HQL-sig.stx/","title":"<code>HQL-sig.stx</code>","text":"<pre><code>module signatures/HQL-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-UI-sig\n\nsignature\n\n  sorts\n    HQLIdentifier = string\n    HQLIdParameter = string\n    HQLNumParameter = string\n    HQLNumInt = string\n    HQLQuotedString = string\n    HQLQuotedStringChar = string\n    HQLStatement\n    HQLDeleteStatement\n    HQLSelectClauseOpt\n    HQLFromClause\n    HQLQueryRule\n    HQLSelectFrom\n    HQLDistinctOpt\n    HQLSelection\n    HQLFromRangeJoin\n    HQLFromJoin\n    HQLJoinTypeOpt\n    HQLFetchOpt\n    HQLWithClauseOpt\n    HQLFromRange\n    HQLPropertyFetchOpt\n    HQLAlias\n    HQLAsAliasOpt\n    HQLGroupByClauseOpt\n    HQLOrderByClauseOpt\n    HQLOrderElement\n    HQLAscOrDescOpt\n    HQLHavingClauseOpt\n    HQLWhereClauseOpt\n    HQLAliasedExpression\n    HQLPath\n    HQLExpression\n    HQLConstant\n\n  constructors\n    HQLStatement-Plhdr : HQLStatement\n    HQLDeleteStatement-Plhdr : HQLDeleteStatement\n    HQLSelectClauseOpt-Plhdr : HQLSelectClauseOpt\n    HQLFromClause-Plhdr : HQLFromClause\n    HQLQueryRule-Plhdr : HQLQueryRule\n    HQLSelectFrom-Plhdr : HQLSelectFrom\n    HQLDistinctOpt-Plhdr : HQLDistinctOpt\n    HQLSelection-Plhdr : HQLSelection\n    HQLFromRangeJoin-Plhdr : HQLFromRangeJoin\n    HQLFromJoin-Plhdr : HQLFromJoin\n    HQLJoinTypeOpt-Plhdr : HQLJoinTypeOpt\n    HQLFetchOpt-Plhdr : HQLFetchOpt\n    HQLWithClauseOpt-Plhdr : HQLWithClauseOpt\n    HQLFromRange-Plhdr : HQLFromRange\n    HQLPropertyFetchOpt-Plhdr : HQLPropertyFetchOpt\n    HQLAlias-Plhdr : HQLAlias\n    HQLAsAliasOpt-Plhdr : HQLAsAliasOpt\n    HQLGroupByClauseOpt-Plhdr : HQLGroupByClauseOpt\n    HQLOrderByClauseOpt-Plhdr : HQLOrderByClauseOpt\n    HQLOrderElement-Plhdr : HQLOrderElement\n    HQLAscOrDescOpt-Plhdr : HQLAscOrDescOpt\n    HQLHavingClauseOpt-Plhdr : HQLHavingClauseOpt\n    HQLWhereClauseOpt-Plhdr : HQLWhereClauseOpt\n    HQLAliasedExpression-Plhdr : HQLAliasedExpression\n    HQLPath-Plhdr : HQLPath\n    HQLExpression-Plhdr : HQLExpression\n    HQLConstant-Plhdr : HQLConstant\n\nsignature\n\n  constructors\n    DeleteStatement : HQLDeleteStatement -&gt; HQLStatement\n    SelectStatement : HQLQueryRule -&gt; HQLStatement\n    HQLDeleteStatement : HQLFromClause * HQLWhereClauseOpt -&gt; HQLDeleteStatement\n    QueryRule : HQLSelectFrom * HQLWhereClauseOpt * HQLGroupByClauseOpt * HQLOrderByClauseOpt -&gt; HQLQueryRule\n    SelectFrom : HQLSelectClauseOpt * HQLFromClause -&gt; HQLSelectFrom\n    Select : HQLDistinctOpt * HQLSelection -&gt; HQLSelectClauseOpt\n    SelectNone : HQLSelectClauseOpt\n    Distinct : HQLDistinctOpt\n    NoneDistinct : HQLDistinctOpt\n    NewExpression : HQLPath * list(HQLAliasedExpression) -&gt; HQLSelection\n    SelectObject : HQLIdentifier -&gt; HQLSelection\n    SelectedProperties : list(HQLAliasedExpression) -&gt; HQLSelection\n    FromClause : list(HQLFromRangeJoin) -&gt; HQLFromClause\n    FromRangeJoin : HQLFromRange * list(HQLFromJoin) -&gt; HQLFromRangeJoin\n    FromJoin : HQLJoinTypeOpt * HQLFetchOpt * HQLPath * HQLAsAliasOpt * HQLPropertyFetchOpt * HQLWithClauseOpt -&gt; HQLFromJoin\n    LeftJoin : HQLJoinTypeOpt\n    RightJoin : HQLJoinTypeOpt\n    LeftOuterJoin : HQLJoinTypeOpt\n    RightOuterJoin : HQLJoinTypeOpt\n    FullJoin : HQLJoinTypeOpt\n    InnerJoin : HQLJoinTypeOpt\n    JoinTypeNone : HQLJoinTypeOpt\n    Fetch : HQLFetchOpt\n    FetchNone : HQLFetchOpt\n    WithClause : HQLExpression -&gt; HQLWithClauseOpt\n    WithClauseNone : HQLWithClauseOpt\n    FromClassOrOuterQueryPath : HQLPath * HQLAsAliasOpt * HQLPropertyFetchOpt -&gt; HQLFromRange\n    InClassDeclaration : HQLAlias * HQLPath -&gt; HQLFromRange\n    InCollectionDeclaration : HQLPath * HQLAlias -&gt; HQLFromRange\n    InCollectionElementsDeclaration : HQLAlias * HQLPath -&gt; HQLFromRange\n    AsAlias : HQLAlias -&gt; HQLAsAliasOpt\n    AsAliasNone : HQLAsAliasOpt\n    Alias : HQLIdentifier -&gt; HQLAlias\n    PropertyFetch : HQLPropertyFetchOpt\n    PropertyFetchNone : HQLPropertyFetchOpt\n    HQLGroupBy : list(HQLExpression) * HQLHavingClauseOpt -&gt; HQLGroupByClauseOpt\n    HQLGroupByNone : HQLGroupByClauseOpt\n    OrderByClause : list(HQLOrderElement) -&gt; HQLOrderByClauseOpt\n    OrderByClauseNone : HQLOrderByClauseOpt\n    OrderElement : HQLExpression * HQLAscOrDescOpt -&gt; HQLOrderElement\n    HQLAscending : HQLAscOrDescOpt\n    HQLAscendingAbbr : HQLAscOrDescOpt\n    HQLDescending : HQLAscOrDescOpt\n    HQLDescendingAbbr : HQLAscOrDescOpt\n    AscOrDescNone : HQLAscOrDescOpt\n    HavingClause : HQLExpression -&gt; HQLHavingClauseOpt\n    HavingClauseNone : HQLHavingClauseOpt\n    WhereClause : HQLExpression -&gt; HQLWhereClauseOpt\n    WhereClauseNone : HQLWhereClauseOpt\n    AliasedExpression : HQLExpression * HQLAsAliasOpt -&gt; HQLAliasedExpression\n    Path : list(HQLIdentifier) -&gt; HQLPath\n    HQLDslExp : DslExp -&gt; HQLExpression\n    HQLPath : HQLPath -&gt; HQLExpression\n    HQLExpressions : list(HQLExpression) -&gt; HQLExpression\n    HQLQueryRule : HQLQueryRule -&gt; HQLExpression\n    HQLQueryRuleAlt : HQLQueryRule -&gt; HQLExpression\n    QueryOr : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryAnd : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryNot : HQLExpression -&gt; HQLExpression\n    QueryEq : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryIs : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryNe : HQLExpression * HQLExpression -&gt; HQLExpression\n    QuerySqlNe : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryLike : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryNotLike : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryLt : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryLe : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryGt : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryGe : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryIn : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryNotIn : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryMemberOf : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryNotMemberOf : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryConcat : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryPlus : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryMinus : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryMultiply : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryDivide : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryModulo : HQLExpression * HQLExpression -&gt; HQLExpression\n    QueryUMinus : HQLExpression -&gt; HQLExpression\n    HQLFunCurDate : HQLExpression\n    HQLFunCurTime : HQLExpression\n    HQLFunCurTimestamp : HQLExpression\n    HQLFunSecond : HQLExpression -&gt; HQLExpression\n    HQLFunMinute : HQLExpression -&gt; HQLExpression\n    HQLFunHour : HQLExpression -&gt; HQLExpression\n    HQLFunDay : HQLExpression -&gt; HQLExpression\n    HQLFunMonth : HQLExpression -&gt; HQLExpression\n    HQLFunYear : HQLExpression -&gt; HQLExpression\n    HQLAvg : HQLExpression -&gt; HQLExpression\n    HQLSum : HQLExpression -&gt; HQLExpression\n    HQLMin : HQLExpression -&gt; HQLExpression\n    HQLMax : HQLExpression -&gt; HQLExpression\n    HQLCountStar : HQLExpression\n    HQLCount : HQLExpression -&gt; HQLExpression\n    HQLSize : HQLExpression -&gt; HQLExpression\n    HQLSubString : HQLExpression * HQLExpression * HQLExpression -&gt; HQLExpression\n    HQLElements : HQLPath -&gt; HQLExpression\n    HQLIndices : HQLPath -&gt; HQLExpression\n    HQLConstant : HQLConstant -&gt; HQLExpression\n    HQLTrue : HQLConstant\n    HQLFalse : HQLConstant\n    HQLEmpty : HQLConstant\n    HQLNull : HQLConstant\n    HQLString : HQLQuotedString -&gt; HQLConstant\n    HQLNumInt : HQLNumInt -&gt; HQLConstant\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/HQL-sig.stx/#modal-h2","title":"HQL-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-AccessControl-sig.stx/","title":"<code>WebDSL-AccessControl-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-AccessControl-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Core-sig\n  signatures/WebDSL-DataModel-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-UI-sig\n\nsignature\n\n  sorts\n    OptMatchArgs\n    OptId\n    OptWildCardArg\n    AccessControlDefinition\n    AccessControlRule\n    AccessControlPointcutElement\n    AccessControlImportRulesArg\n    PolicyExp\n    MatchName\n    AccessControlType\n\n  constructors\n    OptMatchArgs-Plhdr : OptMatchArgs\n    OptId-Plhdr : OptId\n    OptWildCardArg-Plhdr : OptWildCardArg\n    AccessControlDefinition-Plhdr : AccessControlDefinition\n    AccessControlRule-Plhdr : AccessControlRule\n    AccessControlPointcutElement-Plhdr : AccessControlPointcutElement\n    AccessControlImportRulesArg-Plhdr : AccessControlImportRulesArg\n    PolicyExp-Plhdr : PolicyExp\n    MatchName-Plhdr : MatchName\n    AccessControlType-Plhdr : AccessControlType\n\nsignature\n\n  constructors\n    MatchNameWildCard : MatchName\n    MatchName : PageId * OptWildCardArg -&gt; MatchName\n    AccessControlDefinition : OptId * list(AccessControlDefinition) -&gt; Section\n    AccessControlDefinitionAlt : OptId * list(AccessControlDefinition) -&gt; Section\n    Predicate : Id * OptFormalArgs * Exp -&gt; Definition\n    AccessControlPrincipalDef : Id * list(Id) -&gt; Definition\n    PredicateAc : Id * OptFormalArgs * Exp -&gt; AccessControlDefinition\n    AccessControlPrincipalAcDef : Id * list(Id) -&gt; AccessControlDefinition\n    AccessControlPointcut : Id * list(FormalArg) * list(AccessControlPointcutElement) -&gt; AccessControlDefinition\n    Rule : AccessControlRule -&gt; AccessControlDefinition\n    AccessControlRule : AccessControlType * MatchName * OptMatchArgs * Exp * list(AccessControlRule) -&gt; AccessControlRule\n    SpecialAccessControlRule : Exp -&gt; AccessControlRule\n    AccessControlPointcutElement : AccessControlType * MatchName * list(Id) * OptWildCardArg -&gt; AccessControlPointcutElement\n    ACPolicy : PolicyExp -&gt; Section\n    Name : Id -&gt; PolicyExp\n    PolicyAnd : PolicyExp * PolicyExp -&gt; PolicyExp\n    PolicyOr : PolicyExp * PolicyExp -&gt; PolicyExp\n    PredicateInEntity : Id * OptFormalArgs * Exp -&gt; EntityBodyDeclaration\n    IgnoreAccessControl : Modifier\n    AccessControlImportRules : Id * list(AccessControlImportRulesArg) -&gt; TemplateElement\n    ACVar : Id -&gt; AccessControlImportRulesArg\n    MatchArgs : list(FormalArg) * OptWildCardArg -&gt; OptMatchArgs\n    OptMatchArgsNone : OptMatchArgs\n    Id : Id -&gt; OptId\n    OptIdNone : OptId\n    WildCardArg : OptWildCardArg\n    OptWildCardArgNone : OptWildCardArg\n    ACTypePage : AccessControlType\n    ACTypeAction : AccessControlType\n    ACTypeTemplate : AccessControlType\n    ACTypeAjaxTemplate : AccessControlType\n    ACTypePointcut : AccessControlType\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-AccessControl-sig.stx/#modal-h2","title":"WebDSL-AccessControl-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Action-sig.stx/","title":"<code>WebDSL-Action-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Action-sig\n\nimports\n  signatures/WebDSL-Core-sig\n  signatures/WebDSL-DataModel-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-Search-sig\n  signatures/WebDSL-UI-sig\n  signatures/HQL-sig\n\nsignature\n\n  sorts\n    OptSort\n    Block\n    Function\n    ElseIfStatement\n    OptElse\n    Case\n    TypeCaseAlt\n    OptTypeAlias\n    CaseAltExps\n    ThisLex = string\n    ConstValue\n    Exp\n    PropAssignment\n    ObjectPropertyAssignment\n    Mapping\n    ThisCall\n    FAExp\n    OptGroupBy\n    GroupBy\n    ForExp\n    HqlExp\n    LimitValueExp\n    DslExp\n    EmailCall\n\n  constructors\n    OptSort-Plhdr : OptSort\n    Block-Plhdr : Block\n    Function-Plhdr : Function\n    ElseIfStatement-Plhdr : ElseIfStatement\n    OptElse-Plhdr : OptElse\n    Case-Plhdr : Case\n    TypeCaseAlt-Plhdr : TypeCaseAlt\n    OptTypeAlias-Plhdr : OptTypeAlias\n    CaseAltExps-Plhdr : CaseAltExps\n    ConstValue-Plhdr : ConstValue\n    Exp-Plhdr : Exp\n    PropAssignment-Plhdr : PropAssignment\n    ObjectPropertyAssignment-Plhdr : ObjectPropertyAssignment\n    Mapping-Plhdr : Mapping\n    ThisCall-Plhdr : ThisCall\n    FAExp-Plhdr : FAExp\n    OptGroupBy-Plhdr : OptGroupBy\n    GroupBy-Plhdr : GroupBy\n    ForExp-Plhdr : ForExp\n    HqlExp-Plhdr : HqlExp\n    LimitValueExp-Plhdr : LimitValueExp\n    DslExp-Plhdr : DslExp\n    EmailCall-Plhdr : EmailCall\n\nsignature\n\n  constructors\n    Function : FunId * OptFormalArgs * OptSort * Block -&gt; Function\n    OptSortNone : OptSort\n    OptSortSome : Sort -&gt; OptSort\n    GlobalFunction : Function -&gt; Definition\n    CachedGlobalFunction : Function -&gt; Definition\n    ExtendGlobalFunction : Function -&gt; Definition\n    EntityFunction : Function -&gt; EntityBodyDeclaration\n    CachedFunction : Function -&gt; EntityBodyDeclaration\n    ExtendFunction : Function -&gt; EntityBodyDeclaration\n    StaticEntityFunction : Function -&gt; EntityBodyDeclaration\n    FunctionExp : OptFormalArgs * OptSort * Block -&gt; Exp\n    FunctionRef : FunId * list(Sort) * OptSort -&gt; Exp\n    FunctionRefCall : FunId * list(Sort) * OptSort * list(Exp) -&gt; Exp\n    FunctionRefCallPartial : FunId * list(Sort) * OptSort * list(Exp) -&gt; Exp\n    Block : list(Statement) -&gt; Block\n    Block2Statement : Block -&gt; Statement\n    Stat : Exp -&gt; Statement\n    Return : Exp -&gt; Statement\n    ReturnEmpty : Statement\n    GoTo : PageCall -&gt; Statement\n    GoToAlt : PageCall -&gt; Statement\n    VarDecl : VarId * Sort -&gt; Statement\n    VarDeclInit : VarId * Sort * Exp -&gt; Statement\n    VarDeclInitInferred : VarId * Exp -&gt; Statement\n    If : Exp * Block * Block -&gt; Statement\n    IfNoElse : Exp * Block -&gt; Statement\n    IfWithElseIf : Exp * Block * list(ElseIfStatement) * OptElse -&gt; Statement\n    ElseIf : Exp * Block -&gt; ElseIfStatement\n    OptElseSome : Block -&gt; OptElse\n    OptElseNone : OptElse\n    CaseStmt : list(Exp) * list(Case) -&gt; Statement\n    CaseAlt : CaseAltExps * Block -&gt; Case\n    CaseAltDefault : Block -&gt; Case\n    TypeCaseStmt : Exp * OptTypeAlias * list(TypeCaseAlt) -&gt; Statement\n    TypeAlias : Id -&gt; OptTypeAlias\n    OptTypeAliasNone : OptTypeAlias\n    TypeCaseAlt : Sort * Block -&gt; TypeCaseAlt\n    TypeCaseAltDefault : Block -&gt; TypeCaseAlt\n    CaseExps : list(Exp) -&gt; CaseAltExps\n    ForStmt : VarId * Sort * Exp * OptFilter * Block -&gt; Statement\n    ForStmtInferred : VarId * Exp * OptFilter * Block -&gt; Statement\n    ForAllStmt : VarId * Sort * OptFilter * Block -&gt; Statement\n    ForCountStmt : VarId * Exp * Exp * Block -&gt; Statement\n    WhileStmt : Exp * Block -&gt; Statement\n    Const : ConstValue -&gt; Exp\n    Int : Int -&gt; ConstValue\n    Long : Long -&gt; ConstValue\n    Float : Float -&gt; ConstValue\n    StringConst : String -&gt; ConstValue\n    Var : VarId -&gt; Exp\n    FieldAccess : FAExp * PropertyId -&gt; Exp\n    CollectionIndex : Exp * Exp -&gt; Exp\n    This : ThisLex -&gt; Exp\n    FAExp : Exp -&gt; FAExp\n    FAVar : FAVarId -&gt; FAExp\n    FAGlobal : FAExp\n    FASession : FAExp\n    ObjectCreation : SimpleSortLex * list(PropAssignment) -&gt; Exp\n    PropAssignment : ObjectPropertyAssignment -&gt; PropAssignment\n    PropAssignmentComma : ObjectPropertyAssignment -&gt; PropAssignment\n    ObjectPropertyAssignment : Id * Exp -&gt; ObjectPropertyAssignment\n    Assignment : Exp * Exp -&gt; Statement\n    MapCreation : list(Mapping) -&gt; Exp\n    Mapping : Exp * Exp -&gt; Mapping\n    ListCreation : list(Exp) -&gt; Exp\n    SetCreation : list(Exp) -&gt; Exp\n    TypedListCreation : Sort * list(Exp) -&gt; Exp\n    TypedSetCreation : Sort * list(Exp) -&gt; Exp\n    ThisCall2Exp : ThisCall -&gt; Exp\n    ThisCall : FunId * list(Exp) -&gt; ThisCall\n    Call : Exp * Id * list(Exp) -&gt; Exp\n    IsA : Exp * Sort -&gt; Exp\n    Cast : Exp * Sort -&gt; Exp\n    InColl : Exp * Exp -&gt; Exp\n    IfExp : Exp * Exp * Exp -&gt; Exp\n    OutputShorthand : Exp -&gt; OutputShorthand\n    SimpleThisCall : ThisCall -&gt; SimpleExp\n    SimpleCall : SimpleExp * Id * list(Exp) -&gt; SimpleExp\n    InterpExp : Exp -&gt; StringPart\n    Eq : Exp * Exp -&gt; Exp\n    NotEq : Exp * Exp -&gt; Exp\n    LargerThan : Exp * Exp -&gt; Exp\n    LargerThanOrEqual : Exp * Exp -&gt; Exp\n    SmallerThan : Exp * Exp -&gt; Exp\n    SmallerThanOrEqual : Exp * Exp -&gt; Exp\n    True : Exp\n    False : Exp\n    Null : Exp\n    And : Exp * Exp -&gt; Exp\n    Or : Exp * Exp -&gt; Exp\n    Not : Exp -&gt; Exp\n    ForExp : Exp * VarId * Sort * Exp * OptFilter * OptGroupBy -&gt; ForExp\n    ForExpInferred : Exp * VarId * Exp * OptFilter * OptGroupBy -&gt; ForExp\n    ForExpShort : VarId * Sort * Exp -&gt; ForExp\n    ForExpShortFilter : VarId * Sort * Exp * Filter -&gt; ForExp\n    ForExpShortFilterInferred : VarId * Exp * Filter -&gt; ForExp\n    ForExpShortGroupBy : VarId * Sort * Exp * GroupBy -&gt; ForExp\n    ForExpShortGroupByInferred : VarId * Exp * GroupBy -&gt; ForExp\n    ForExpShortFilterGroupBy : VarId * Sort * Exp * Filter * GroupBy -&gt; ForExp\n    ForExpShortFilterGroupByInferred : VarId * Exp * Filter * GroupBy -&gt; ForExp\n    ForExp2Exp : ForExp -&gt; Exp\n    OptGroupBySome : GroupBy -&gt; OptGroupBy\n    OptGroupByNone : OptGroupBy\n    GroupBy : Exp -&gt; GroupBy\n    AndForExp : ForExp -&gt; Exp\n    OrForExp : ForExp -&gt; Exp\n    Mul : Exp * Exp -&gt; Exp\n    Div : Exp * Exp -&gt; Exp\n    Mod : Exp * Exp -&gt; Exp\n    Add : Exp * Exp -&gt; Exp\n    Sub : Exp * Exp -&gt; Exp\n    HqlExp : HqlExp -&gt; Exp\n    HqlQuery : HQLQueryRule -&gt; HqlExp\n    HqlQueryLimit : HQLQueryRule * LimitValueExp -&gt; HqlExp\n    HqlQueryLimitOffset : HQLQueryRule * LimitValueExp * LimitValueExp -&gt; HqlExp\n    LimitValueExp : Exp -&gt; LimitValueExp\n    LimitValueDslExp : DslExp -&gt; LimitValueExp\n    DslExp : Exp -&gt; DslExp\n    HqlStatement : HQLDeleteStatement -&gt; Statement\n    RenderEmailFunctionCall : EmailCall -&gt; Exp\n    EmailFunctionCall : EmailCall -&gt; Exp\n    EmailFunctionCallAlt : EmailCall -&gt; Exp\n    SendEmailFunctionCall : EmailCall -&gt; Exp\n    EmailCall : Id * list(Exp) -&gt; EmailCall\n    RenderTemplateFunctionCall : TemplateCall -&gt; Exp\n    ValidateTemplateFunctionCall : TemplateCall -&gt; Exp\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Action-sig.stx/#modal-h2","title":"WebDSL-Action-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Ajax-sig.stx/","title":"<code>WebDSL-Ajax-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Ajax-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-UI-sig\n  signatures/WebDSL-Core-sig\n\nsignature\n\n  sorts\n    AjaxStatement\n    Placeholder\n    PlaceholderWithAjaxCall\n    PlaceholderVar\n    AjaxVisibility\n    AjaxReplaceTemplateCall\n    EmptyLex = string\n    PHExp\n\n  constructors\n    AjaxStatement-Plhdr : AjaxStatement\n    Placeholder-Plhdr : Placeholder\n    PlaceholderWithAjaxCall-Plhdr : PlaceholderWithAjaxCall\n    PlaceholderVar-Plhdr : PlaceholderVar\n    AjaxVisibility-Plhdr : AjaxVisibility\n    AjaxReplaceTemplateCall-Plhdr : AjaxReplaceTemplateCall\n    PHExp-Plhdr : PHExp\n\nsignature\n\n  constructors\n    AjaxStatement : AjaxStatement -&gt; Statement\n    AjaxReplace : Exp * AjaxReplaceTemplateCall -&gt; AjaxStatement\n    AjaxAppend : Exp * TemplateCall -&gt; AjaxStatement\n    AjaxVisibility : Exp * AjaxVisibility -&gt; AjaxStatement\n    Show : AjaxVisibility\n    Toggle : AjaxVisibility\n    Hide : AjaxVisibility\n    AjaxRelocate : PageCall -&gt; AjaxStatement\n    AjaxRestyle : Exp * Exp -&gt; AjaxStatement\n    AjaxClear : Exp -&gt; AjaxStatement\n    AjaxRefresh : AjaxStatement\n    AjaxRunScript : Exp -&gt; AjaxStatement\n    AjaxReplaceTemplateCall : TemplateCall -&gt; AjaxReplaceTemplateCall\n    AjaxReplaceEmpty : EmptyLex -&gt; AjaxReplaceTemplateCall\n    TEPlaceholder : Placeholder -&gt; TemplateElement\n    TEPlaceholderWithAjaxCall : PlaceholderWithAjaxCall -&gt; TemplateElement\n    PlaceholderHtml : Id * Id * list(TemplateElement) -&gt; Placeholder\n    PlaceholderHtmlExp : Id * Exp * list(TemplateElement) -&gt; Placeholder\n    Placeholder : Id * list(TemplateElement) -&gt; Placeholder\n    PlaceholderExp : Exp * list(TemplateElement) -&gt; Placeholder\n    PlaceholderAjaxHtml : Id * Id * TemplateCall -&gt; PlaceholderWithAjaxCall\n    PlaceholderAjaxHtmlExp : Id * PHExp * TemplateCall -&gt; PlaceholderWithAjaxCall\n    PlaceholderAjax : Id * TemplateCall -&gt; PlaceholderWithAjaxCall\n    PlaceholderAjaxExp : PHExp * TemplateCall -&gt; PlaceholderWithAjaxCall\n    PlaceholderVar2TemplateElement : PlaceholderVar -&gt; TemplateElement\n    PlaceholderVar : Id -&gt; PlaceholderVar\n    PHThisCall : ThisCall -&gt; PHExp\n    PHCall : Exp * Id * list(Exp) -&gt; PHExp\n    PHFieldAccess : Exp * PropertyId -&gt; PHExp\n    PHCollectionIndex : Exp * Exp -&gt; PHExp\n    PHAdd : Exp * Exp -&gt; PHExp\n    PHConst : ConstValue -&gt; PHExp\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Ajax-sig.stx/#modal-h2","title":"WebDSL-Ajax-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Attributes-sig.stx/","title":"<code>WebDSL-Attributes-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Attributes-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-Core-sig\n  signatures/WebDSL-UI-sig\n\nsignature\n\n  sorts\n    AttributeSelection\n    AttributeCollectionOverride\n    AttributeElem\n    AttributeIncludeIgnore\n    Attribute\n    AttributeId = string\n\n  constructors\n    AttributeSelection-Plhdr : AttributeSelection\n    AttributeCollectionOverride-Plhdr : AttributeCollectionOverride\n    AttributeElem-Plhdr : AttributeElem\n    AttributeIncludeIgnore-Plhdr : AttributeIncludeIgnore\n    Attribute-Plhdr : Attribute\n\nsignature\n\n  constructors\n    AttributeCollection : AttributeCollectionOverride * Id * list(AttributeElem) -&gt; Definition\n    AttributeAssign : AttributeId * Exp -&gt; AttributeElem\n    AttributeInclude : AttributeId * AttributeIncludeIgnore -&gt; AttributeElem\n    AttributeIgnore : AttributeId -&gt; AttributeElem\n    AttributeIncludeIgnoreNone : AttributeIncludeIgnore\n    AttributeIncludeIgnore : list(AttributeId) -&gt; AttributeIncludeIgnore\n    AttributeCollectionOverrideNone : AttributeCollectionOverride\n    AttributeCollectionOverride : AttributeCollectionOverride\n    AttributeSelection : AttributeId -&gt; AttributeSelection\n    AttributeIgnoreDefault : AttributeId -&gt; AttributeSelection\n    AttributeSelection2PropertyAssignment : AttributeSelection -&gt; PropertyAssignment\n    AttributeSelection2Attribute : AttributeSelection -&gt; Attribute\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Attributes-sig.stx/#modal-h2","title":"WebDSL-Attributes-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Core-sig.stx/","title":"<code>WebDSL-Core-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Core-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-DataModel-sig\n  signatures/WebDSL-Lexical-sig\n\nsignature\n\n  sorts\n    FormalArg\n    OptFormalArgs\n    FunctionSortParams\n    FunctionSortParam\n    FunctionSortReturn\n    OptCallArgs\n    Sort\n    Unit\n    Section\n    Definition\n    EnumValue\n    Action\n    Statement\n\n  constructors\n    FormalArg-Plhdr : FormalArg\n    OptFormalArgs-Plhdr : OptFormalArgs\n    FunctionSortParams-Plhdr : FunctionSortParams\n    FunctionSortParam-Plhdr : FunctionSortParam\n    FunctionSortReturn-Plhdr : FunctionSortReturn\n    OptCallArgs-Plhdr : OptCallArgs\n    Sort-Plhdr : Sort\n    Unit-Plhdr : Unit\n    Section-Plhdr : Section\n    Definition-Plhdr : Definition\n    EnumValue-Plhdr : EnumValue\n    Action-Plhdr : Action\n    Statement-Plhdr : Statement\n\nsignature\n\n  constructors\n    SimpleSort : SimpleSortLex -&gt; Sort\n    GenericSort : GenericSortLex * list(Sort) -&gt; Sort\n    ListSort : Sort -&gt; Sort\n    SetSort : Sort -&gt; Sort\n    RefSort : Sort -&gt; Sort\n    RefSortAlt : Sort -&gt; Sort\n    FunctionSort : FunctionSortParams * FunctionSortReturn -&gt; Sort\n    FunctionSortParams : list(FunctionSortParam) -&gt; FunctionSortParams\n    FunctionSortParamsNone : FunctionSortParams\n    UnnamedArg : Sort -&gt; FunctionSortParam\n    NamedArg : VarId * Sort -&gt; FunctionSortParam\n    FunctionSortReturn : Sort -&gt; FunctionSortReturn\n    FunctionSortReturnNone : FunctionSortReturn\n    Arg : VarId * Sort -&gt; FormalArg\n    FormalArgs : list(FormalArg) -&gt; OptFormalArgs\n    OptFormalArgsNone : OptFormalArgs\n    CallArgs : list(Exp) -&gt; OptCallArgs\n    OptCallArgsNone : OptCallArgs\n    Section : SectionName * list(Definition) -&gt; Section\n    ApplicationDefs : QId * list(Definition) * list(Section) -&gt; Unit\n    Application : QId * list(Section) -&gt; Unit\n    ModuleDefs : ModuleName * list(Definition) * list(Section) -&gt; Unit\n    Module : ModuleName * list(Section) -&gt; Unit\n    BuiltInDefs : list(Definition) * list(Section) -&gt; Unit\n    BuiltIn : list(Section) -&gt; Unit\n    BuiltInLibraryDefs : list(Definition) * list(Section) -&gt; Unit\n    BuiltInLibrary : list(Section) -&gt; Unit\n    EmptyUnit : Unit\n    Imports : ImportName -&gt; Definition\n    ImportsBuiltIn : Definition\n    Description : list(Word) -&gt; Definition\n    Note : list(Word) -&gt; Definition\n    Enum : Id * list(EnumValue) -&gt; Definition\n    EnumValue : Id * String -&gt; EnumValue\n    Action2Definition : Action -&gt; Definition\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Core-sig.stx/#modal-h2","title":"WebDSL-Core-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-DataModel-sig.stx/","title":"<code>WebDSL-DataModel-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-DataModel-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Core-sig\n  signatures/WebDSL-Lexical-sig\n\nsignature\n\n  sorts\n    EntityBodyDeclaration\n    OptPropAnnos\n    PropKind\n    Annotation\n    AnnotationId = string\n\n  constructors\n    EntityBodyDeclaration-Plhdr : EntityBodyDeclaration\n    OptPropAnnos-Plhdr : OptPropAnnos\n    PropKind-Plhdr : PropKind\n    Annotation-Plhdr : Annotation\n\nsignature\n\n  constructors\n    Entity : Id * Id * list(EntityBodyDeclaration) -&gt; Definition\n    EntityNoSuper : Id * list(EntityBodyDeclaration) -&gt; Definition\n    SessionEntity : Id * list(EntityBodyDeclaration) -&gt; Definition\n    ExtendEntity : Id * list(EntityBodyDeclaration) -&gt; Definition\n    ExtendSessionEntity : Id * list(EntityBodyDeclaration) -&gt; Definition\n    GlobalVarDecl : VarId * Sort -&gt; Definition\n    GlobalVarDeclDepr : VarId * Sort -&gt; Definition\n    GlobalVarDeclInit : VarId * Sort * Exp -&gt; Definition\n    GlobalVarDeclInitDepr : VarId * Sort * Exp -&gt; Definition\n    GlobalVarDeclInitInferred : VarId * Exp -&gt; Definition\n    GlobalVarDeclInitInferredDepr : VarId * Exp -&gt; Definition\n    RequestVarDecl : VarId * Sort -&gt; Definition\n    RequestVarDeclDepr : VarId * Sort -&gt; Definition\n    RequestVarDeclInit : VarId * Sort * Exp -&gt; Definition\n    RequestVarDeclInitDepr : VarId * Sort * Exp -&gt; Definition\n    RequestVarDeclInitInferred : VarId * Exp -&gt; Definition\n    RequestVarDeclInitInferredDepr : VarId * Exp -&gt; Definition\n    Property : PropertyId * PropKind * Sort * OptPropAnnos -&gt; EntityBodyDeclaration\n    DerivedProperty : PropertyId * PropKind * Sort * OptPropAnnos * Exp -&gt; EntityBodyDeclaration\n    CachedEntity : EntityBodyDeclaration\n    PropAnnos : list(Annotation) -&gt; OptPropAnnos\n    OptPropAnnosNone : OptPropAnnos\n    Simple : PropKind\n    Ref : PropKind\n    Comp : PropKind\n    AnyProp : PropKind\n    SimpleAnno : AnnotationId -&gt; Annotation\n    TransientAnno : Annotation\n    IdAnno : Annotation\n    NameAnno : Annotation\n    CacheAnno : Annotation\n    InverseAnno : Id * Id -&gt; Annotation\n    IncompleteInverseAnno : Id -&gt; Annotation\n    InverseSlaveAnno : Id * Id -&gt; Annotation\n    InverseReferenceOnlyAnno : Annotation\n    InlineAnno : list(Id) -&gt; Annotation\n    SelectAnno : Id -&gt; Annotation\n    NotNullAnno : Annotation\n    NotEmptyAnno : Annotation\n    AllowedAnno : Exp -&gt; Annotation\n    DefaultAnno : Exp -&gt; Annotation\n    LengthAnno : Int -&gt; Annotation\n    FormatAnno : String -&gt; Annotation\n    IndexEmptyAnno : Annotation\n    IndexAnno : Int -&gt; Annotation\n    CollationAnno : Id -&gt; Annotation\n    IdErrorAnno : String -&gt; Annotation\n    IdEmptyErrorAnno : String -&gt; Annotation\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-DataModel-sig.stx/#modal-h2","title":"WebDSL-DataModel-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-DataValidation-sig.stx/","title":"<code>WebDSL-DataValidation-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-DataValidation-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-UI-sig\n  signatures/WebDSL-DataModel-sig\n  signatures/WebDSL-Core-sig\n\nsignature\n\n  sorts\n\n  constructors\n\nsignature\n\n  constructors\n    ValidateCreateAnno : Exp * Exp -&gt; Annotation\n    ValidateUpdateAnno : Exp * Exp -&gt; Annotation\n    ValidateDeleteAnno : Exp * Exp -&gt; Annotation\n    ValidateAnno : Exp * Exp -&gt; Annotation\n    NamedValidateAnno : Id * Exp * Exp -&gt; Annotation\n    ValidateEntity : Exp * Exp -&gt; EntityBodyDeclaration\n    ValidateStatement : Exp * Exp -&gt; Statement\n    NamedValidateStatement : Id * Exp * Exp -&gt; Statement\n    ValidationErrors : Id -&gt; TemplateCall\n    ValidationErrorsEmpty : TemplateCall\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-DataValidation-sig.stx/#modal-h2","title":"WebDSL-DataValidation-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Dispatch-sig.stx/","title":"<code>WebDSL-Dispatch-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Dispatch-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Core-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-UI-sig\n\nsignature\n\n  sorts\n    DispatchEntry\n    DispatchDefault\n    DispatchNavigateCall\n    DispatchNavigate\n    DispatchNavigateButton\n\n  constructors\n    DispatchEntry-Plhdr : DispatchEntry\n    DispatchDefault-Plhdr : DispatchDefault\n    DispatchNavigateCall-Plhdr : DispatchNavigateCall\n    DispatchNavigate-Plhdr : DispatchNavigate\n    DispatchNavigateButton-Plhdr : DispatchNavigateButton\n\nsignature\n\n  constructors\n    Dispatch : list(DispatchEntry) * DispatchDefault -&gt; TemplateElement\n    DispatchEntry : Id * OptFormalArgs * list(TemplateElement) -&gt; DispatchEntry\n    DispatchEntity : Id * Sort * list(TemplateElement) -&gt; DispatchEntry\n    DispatchDefault : list(TemplateElement) -&gt; DispatchDefault\n    DispatchDefaultNone : DispatchDefault\n    DispatchNavigate2TemplateElement : DispatchNavigate -&gt; TemplateElement\n    DispatchNavigateButton2TemplateElement : DispatchNavigateButton -&gt; TemplateElement\n    DispatchNavigate : list(DispatchNavigateCall) * list(TemplateElement) -&gt; DispatchNavigate\n    DispatchNavigateButton : Exp * list(DispatchNavigateCall) -&gt; DispatchNavigateButton\n    DispatchNavigateCall : Id * list(Exp) -&gt; DispatchNavigateCall\n    DispatchNavigateCallNoArg : Id -&gt; DispatchNavigateCall\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Dispatch-sig.stx/#modal-h2","title":"WebDSL-Dispatch-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-EntityDerive-sig.stx/","title":"<code>WebDSL-EntityDerive-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-EntityDerive-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Core-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-UI-sig\n\nsignature\n\n  sorts\n    ExpEntityDeriveProp\n    DeriveArgPropId = string\n\n  constructors\n    ExpEntityDeriveProp-Plhdr : ExpEntityDeriveProp\n\nsignature\n\n  constructors\n    ExpEntityDerive : Exp * list(ExpEntityDeriveProp) -&gt; TemplateArgExp\n    ExpEntityDeriveProp : DeriveArgPropId * OptCallArgs -&gt; ExpEntityDeriveProp\n    ArgEntityDerive : Id * DeriveArgPropId * OptFormalArgs -&gt; Sort\n    ForeachElementEntityDerive : Id * list(TemplateElement) -&gt; TemplateElement\n    ForeachStatementEntityDerive : Id * list(Statement) -&gt; Statement\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-EntityDerive-sig.stx/#modal-h2","title":"WebDSL-EntityDerive-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Exception-sig.stx/","title":"<code>WebDSL-Exception-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Exception-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Core-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-UI-sig\n\nsignature\n\n  sorts\n    Catch\n\n  constructors\n    Catch-Plhdr : Catch\n\nsignature\n\n  constructors\n    ThrowStatement : list(Exp) -&gt; Statement\n    ThrowTemplate : list(Exp) -&gt; TemplateCall\n    TryStatement : Block * list(Catch) -&gt; Statement\n    TryTemplate : Block * list(Catch) -&gt; TemplateCall\n    Catch : VarId * Sort * Block -&gt; Catch\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Exception-sig.stx/#modal-h2","title":"WebDSL-Exception-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Expand-sig.stx/","title":"<code>WebDSL-Expand-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Expand-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-Core-sig\n  signatures/WebDSL-UI-sig\n  signatures/WebDSL-DataModel-sig\n  signatures/WebDSL-Attributes-sig\n\nsignature\n\n  sorts\n    DeriveProperty\n    DeriveBody\n    DeriveBodyElement\n    ExpandId = string\n    ExpandArgId = string\n\n  constructors\n    DeriveProperty-Plhdr : DeriveProperty\n    DeriveBody-Plhdr : DeriveBody\n    DeriveBodyElement-Plhdr : DeriveBodyElement\n\nsignature\n\n  constructors\n    DeriveNoBody : Id * Exp * list(DeriveProperty) -&gt; TemplateElement\n    DeriveNoForNoBody : Id * Exp -&gt; TemplateElement\n    Derive : Id * Exp * list(DeriveProperty) * DeriveBody -&gt; TemplateElement\n    DeriveNoFor : Id * Exp * DeriveBody -&gt; TemplateElement\n    DeriveNoFromNoFor : Id * DeriveBody -&gt; TemplateElement\n    DeriveDefault : Id -&gt; DeriveProperty\n    DeriveMode : Id * Id -&gt; DeriveProperty\n    DeriveBody : list(DeriveBodyElement) -&gt; DeriveBody\n    DeriveBodyElement : Id * list(TemplateElement) -&gt; DeriveBodyElement\n    DeriveCrud : Id -&gt; Definition\n    ExpandTemplateCall : list(ExpandId) * Id -&gt; Definition\n    ExpandTemplateDefinition : Id * list(ExpandArgId) * list(Definition) -&gt; Definition\n    TemplateElementExpandLocal : list(ExpandId) * list(ExpandArgId) * list(TemplateElement) -&gt; TemplateElement\n    EntityBodyDeclarationExpandLocal : list(ExpandId) * list(ExpandArgId) * list(EntityBodyDeclaration) -&gt; EntityBodyDeclaration\n    StatementExpandLocal : list(ExpandId) * list(ExpandArgId) * list(Statement) -&gt; Statement\n    ObjectPropertyAssignmentExpandLocal : list(ExpandId) * list(ExpandArgId) * list(ObjectPropertyAssignment) -&gt; ObjectPropertyAssignment\n    DefinitionExpandLocal : list(ExpandId) * list(ExpandArgId) * list(Definition) -&gt; Definition\n    ExpExpandLocal : list(ExpandId) * list(ExpandArgId) * Exp -&gt; Exp\n    AttributeExpandLocal : list(ExpandId) * list(ExpandArgId) * Attribute -&gt; Attribute\n    PropertyAssignmentExpandLocal : list(ExpandId) * list(ExpandArgId) * PropertyAssignment -&gt; PropertyAssignment\n    FormalArgExpandLocal : list(ExpandId) * list(ExpandArgId) * FormalArg -&gt; FormalArg\n    CaseAltExpandLocal : list(ExpandId) * list(ExpandArgId) * Case -&gt; Case\n    TemplateCaseAltExpandLocal : list(ExpandId) * list(ExpandArgId) * TemplateCaseAlt -&gt; TemplateCaseAlt\n    TypeCaseAltExpandLocal : list(ExpandId) * list(ExpandArgId) * ExpandArgId * Block -&gt; TypeCaseAlt\n    TemplateTypeCaseAltExpandLocal : list(ExpandId) * list(ExpandArgId) * ExpandArgId * list(TemplateElement) -&gt; TemplateTypeCaseAlt\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Expand-sig.stx/#modal-h2","title":"WebDSL-Expand-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Generated-sig.stx/","title":"<code>WebDSL-Generated-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Generated-sig\n\nimports\n  signatures/WebDSL-Core-sig\n  signatures/WebDSL-Lexical-sig\n\nsignature\n\n  sorts\n    GeneratedElement\n\n  constructors\n    GeneratedElement-Plhdr : GeneratedElement\n\nsignature\n\n  constructors\n    Generated : list(Id) -&gt; GeneratedElement\n    GeneratedDefinition : GeneratedElement -&gt; Definition\n    GeneratedEntityBodyDeclaration : GeneratedElement -&gt; EntityBodyDeclaration\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Generated-sig.stx/#modal-h2","title":"WebDSL-Generated-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-JavaScript-sig.stx/","title":"<code>WebDSL-JavaScript-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-JavaScript-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Attributes-sig\n  signatures/WebDSL-UI-sig\n  signatures/WebDSL-XML-sig\n\nsignature\n\n  sorts\n    JSPart\n    JSChar = string\n    JSString = string\n    JSSmallerThan = string\n    JSTilde = string\n\n  constructors\n    JSPart-Plhdr : JSPart\n\nsignature\n\n  constructors\n    JSElement : list(Attribute) * list(JSPart) -&gt; TemplateElement\n    StyleElement : list(Attribute) * list(JSPart) -&gt; TemplateElement\n    JSExp : Exp -&gt; JSPart\n    JSString : JSString -&gt; JSPart\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-JavaScript-sig.stx/#modal-h2","title":"WebDSL-JavaScript-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Lexical-sig.stx/","title":"<code>WebDSL-Lexical-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Lexical-sig\n\nimports\n\nsignature\n\n  sorts\n    QId = string\n    TemplateId = string\n    VarId = string\n    FAVarId = string\n    FunId = string\n    PropertyId = string\n    Id = string\n    PageId = string\n    ExtendedId = string\n    SectionName = string\n    ModuleName\n    ModulePart\n    ImportName\n    OptWildcardImport\n    Int = string\n    Long = string\n    Float = string\n    FloatDigits = string\n    ExponentPart = string\n    SignedInteger = string\n    String\n    StringPart\n    StringInterpExp\n    OutputShorthand\n    SimpleExp\n    QMLex = string\n    StringLex = string\n    StringChar = string\n    HexPart = string\n    InsideComment = string\n    CommentChar = string\n    NewLineEOF = string\n    EOF = string\n    Word = string\n    SimpleSortLex = string\n    GenericSortLex = string\n\n  constructors\n    ModuleName-Plhdr : ModuleName\n    ModulePart-Plhdr : ModulePart\n    ImportName-Plhdr : ImportName\n    OptWildcardImport-Plhdr : OptWildcardImport\n    String-Plhdr : String\n    StringPart-Plhdr : StringPart\n    StringInterpExp-Plhdr : StringInterpExp\n    OutputShorthand-Plhdr : OutputShorthand\n    SimpleExp-Plhdr : SimpleExp\n\nsignature\n\n  constructors\n    ModulePart : ExtendedId -&gt; ModulePart\n    WildcardImport : OptWildcardImport\n    NoWildcardImport : OptWildcardImport\n    ModuleName : list(ModulePart) -&gt; ModuleName\n    ImportName : ModuleName * OptWildcardImport -&gt; ImportName\n    String : list(StringPart) -&gt; String\n    StringValue : StringLex -&gt; StringPart\n    InterpValue : StringInterpExp -&gt; StringPart\n    InterpSimpleExp : SimpleExp -&gt; StringInterpExp\n    OutputShorthandSimpleExp : SimpleExp -&gt; OutputShorthand\n    SimpleVar : Id -&gt; SimpleExp\n    SimpleFieldAccess : SimpleExp * PropertyId -&gt; SimpleExp\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Lexical-sig.stx/#modal-h2","title":"WebDSL-Lexical-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Native-sig.stx/","title":"<code>WebDSL-Native-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Native-sig\n\nimports\n  signatures/WebDSL-Core-sig\n  signatures/WebDSL-Lexical-sig\n\nsignature\n\n  sorts\n    NCAlias\n    NCSuper\n    NCElement\n    NativeType\n    NCFunction\n    NCFunctionReturn\n    NCFunctionStatic\n    NCFunctionFromStatic\n    NativeFunId = string\n\n  constructors\n    NCAlias-Plhdr : NCAlias\n    NCSuper-Plhdr : NCSuper\n    NCElement-Plhdr : NCElement\n    NativeType-Plhdr : NativeType\n    NCFunction-Plhdr : NCFunction\n    NCFunctionReturn-Plhdr : NCFunctionReturn\n    NCFunctionStatic-Plhdr : NCFunctionStatic\n    NCFunctionFromStatic-Plhdr : NCFunctionFromStatic\n\nsignature\n\n  constructors\n    NativeClass : QId * NCAlias * NCSuper * list(NCElement) -&gt; Definition\n    ExtendNativeClass : QId * NCAlias * list(NCElement) -&gt; Definition\n    NCAlias : Id -&gt; NCAlias\n    NCAliasNone : NCAlias\n    NCSuper : Id -&gt; NCSuper\n    NCSuperNone : NCSuper\n    NCProperty : Id * NativeType -&gt; NCElement\n    NCFunctionElement : NCFunction -&gt; NCElement\n    NCFunction : NCFunctionStatic * NativeFunId * list(NativeType) * NCFunctionReturn -&gt; NCFunction\n    NCFunctionReturn : NativeType -&gt; NCFunctionReturn\n    NCFunctionReturnNone : NCFunctionReturn\n    NCFunctionStatic : NCFunctionStatic\n    NCFunctionStaticNone : NCFunctionStatic\n    NCFunctionFromStatic : QId * NCFunction -&gt; NCFunctionFromStatic\n    NCFunctionFromStaticElement : NCFunctionFromStatic -&gt; NCElement\n    NCConstructor : list(NativeType) -&gt; NCElement\n    NCConstructorFromStatic : QId * list(NativeType) -&gt; NCElement\n    NativeGenericType : Id * list(NativeType) -&gt; NativeType\n    NativeGenericTypeList : list(NativeType) -&gt; NativeType\n    NativeGenericTypeSet : list(NativeType) -&gt; NativeType\n    NativeSimpleType : Id -&gt; NativeType\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Native-sig.stx/#modal-h2","title":"WebDSL-Native-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Prefetch-sig.stx/","title":"<code>WebDSL-Prefetch-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Prefetch-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Core-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-UI-sig\n\nsignature\n\n  sorts\n    PrefetchChildren\n    PrefetchNode\n    PrefetchTemplateArgsOpt\n    PrefetchNodeMod\n    PrefetchCondition\n    PrefetchCondVal\n    PrefetchCond\n    PrefetchWhereOpt\n    PrefetchWhereMod\n    OptSimpleSort\n    PrefetchChildrenOpt\n    OptPrefetchOwnerCast\n    SortOrThis\n    TemplateArgOrThis\n\n  constructors\n    PrefetchChildren-Plhdr : PrefetchChildren\n    PrefetchNode-Plhdr : PrefetchNode\n    PrefetchTemplateArgsOpt-Plhdr : PrefetchTemplateArgsOpt\n    PrefetchNodeMod-Plhdr : PrefetchNodeMod\n    PrefetchCondition-Plhdr : PrefetchCondition\n    PrefetchCondVal-Plhdr : PrefetchCondVal\n    PrefetchCond-Plhdr : PrefetchCond\n    PrefetchWhereOpt-Plhdr : PrefetchWhereOpt\n    PrefetchWhereMod-Plhdr : PrefetchWhereMod\n    OptSimpleSort-Plhdr : OptSimpleSort\n    PrefetchChildrenOpt-Plhdr : PrefetchChildrenOpt\n    OptPrefetchOwnerCast-Plhdr : OptPrefetchOwnerCast\n    SortOrThis-Plhdr : SortOrThis\n    TemplateArgOrThis-Plhdr : TemplateArgOrThis\n\nsignature\n\n  constructors\n    PrefetchFor : Id * PrefetchTemplateArgsOpt * PrefetchWhereOpt * PrefetchChildren -&gt; TemplateElement\n    PrefetchForStmt : Id * PrefetchTemplateArgsOpt * PrefetchWhereOpt * PrefetchChildren -&gt; Statement\n    PrefetchChildren : list(PrefetchNode) -&gt; PrefetchChildren\n    PrefetchChildrenOptNone : PrefetchChildrenOpt\n    PrefetchChildren2PrefetchChildrenOpt : PrefetchChildren -&gt; PrefetchChildrenOpt\n    PrefetchNode : OptPrefetchOwnerCast * Id * list(PrefetchNodeMod) * PrefetchTemplateArgsOpt * PrefetchCondition * PrefetchWhereOpt * PrefetchChildrenOpt -&gt; PrefetchNode\n    OptPrefetchOwnerCastNone : OptPrefetchOwnerCast\n    PrefetchOwnerCast : SimpleSortLex -&gt; OptPrefetchOwnerCast\n    NoEmptyBatch : PrefetchNodeMod\n    FetchEarly : PrefetchNodeMod\n    PrefetchTemplateArgsOptNone : PrefetchTemplateArgsOpt\n    PrefetchTemplateArgs : list(TemplateArgOrThis) -&gt; PrefetchTemplateArgsOpt\n    TemplateArgOrThis : Id * list(SortOrThis) -&gt; TemplateArgOrThis\n    Sort : Sort -&gt; SortOrThis\n    TArgThis : SortOrThis\n    PrefetchThisCast : Sort -&gt; SortOrThis\n    PrefetchConditionNone : PrefetchCondition\n    PrefetchCondition : PrefetchCond -&gt; PrefetchCondition\n    PrefetchWhereOptNone : PrefetchWhereOpt\n    PrefetchWhere : list(PrefetchWhereMod) * PrefetchCond -&gt; PrefetchWhereOpt\n    Hint : PrefetchWhereMod\n    PrefetchEq : PrefetchCondVal * PrefetchCondVal -&gt; PrefetchCond\n    PrefetchNotEq : PrefetchCondVal * PrefetchCondVal -&gt; PrefetchCond\n    PrefetchLargerThan : PrefetchCondVal * PrefetchCondVal -&gt; PrefetchCond\n    PrefetchLargerThanOrEqual : PrefetchCondVal * PrefetchCondVal -&gt; PrefetchCond\n    PrefetchSmallerThan : PrefetchCondVal * PrefetchCondVal -&gt; PrefetchCond\n    PrefetchSmallerThanOrEqual : PrefetchCondVal * PrefetchCondVal -&gt; PrefetchCond\n    PrefetchAnd : PrefetchCond * PrefetchCond -&gt; PrefetchCond\n    PrefetchOr : PrefetchCond * PrefetchCond -&gt; PrefetchCond\n    PrefetchNot : PrefetchCond -&gt; PrefetchCond\n    PrefetchCondVal2PrefetchCond : PrefetchCondVal -&gt; PrefetchCond\n    PrefetchTrue : PrefetchCondVal\n    PrefetchFalse : PrefetchCondVal\n    PrefetchNull : PrefetchCondVal\n    PrefetchConst : ConstValue -&gt; PrefetchCondVal\n    PrefetchCondVar : VarId -&gt; PrefetchCondVal\n    RelativeFieldAccess : OptSimpleSort * PropertyId -&gt; PrefetchCondVal\n    PrefetchMul : PrefetchCondVal * PrefetchCondVal -&gt; PrefetchCondVal\n    PrefetchDiv : PrefetchCondVal * PrefetchCondVal -&gt; PrefetchCondVal\n    PrefetchMod : PrefetchCondVal * PrefetchCondVal -&gt; PrefetchCondVal\n    PrefetchAdd : PrefetchCondVal * PrefetchCondVal -&gt; PrefetchCondVal\n    PrefetchSub : PrefetchCondVal * PrefetchCondVal -&gt; PrefetchCondVal\n    OptSimpleSortNone : OptSimpleSort\n    OptSimpleSortSome : SimpleSortLex -&gt; OptSimpleSort\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Prefetch-sig.stx/#modal-h2","title":"WebDSL-Prefetch-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Regex-sig.stx/","title":"<code>WebDSL-Regex-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Regex-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-DataModel-sig\n\nsignature\n\n  sorts\n    Pattern\n    RegexExp\n    Branche\n    Piece\n    Quantifier\n    Atom\n    CharacterClass\n    BracketItem\n    BracketLiteralOrBracketCharacter\n    ClassKeyword\n    BracketLiteral = string\n    AtomLiteral = string\n    AllChars = string\n    BracketCharacter\n    AtomCharacter\n    DoubleQuote\n    OctalChar\n    HexHexChar\n    DecHexChar\n    Tab\n    Newline\n    ReturnAtom\n    Formfeed\n    Alarm\n    Escape\n    WordChar\n    NonWordChar\n    WhiteSpaceChar\n    DigitChar\n    NonDigitChar\n    ControlCharacter\n    WordBoundry\n    NonWordBoundry\n    InputBeginBoundry\n    PrevMatchEndBoundry\n    EndInputBoundry\n    EndInputFinalBoundry\n    Space\n    NonWhiteSpaceChar\n    BackReference\n    QuotablePatternSymbol\n    Quoted\n    QuotablePatternSymbolLex = string\n    Integer = string\n    OctalValue = string\n    TwoHexValue = string\n    FourHexValue = string\n    BackReferenceLex = string\n    ControlValue = string\n    RegexId\n    RegexID = string\n\n  constructors\n    Pattern-Plhdr : Pattern\n    RegexExp-Plhdr : RegexExp\n    Branche-Plhdr : Branche\n    Piece-Plhdr : Piece\n    Quantifier-Plhdr : Quantifier\n    Atom-Plhdr : Atom\n    CharacterClass-Plhdr : CharacterClass\n    BracketItem-Plhdr : BracketItem\n    BracketLiteralOrBracketCharacter-Plhdr : BracketLiteralOrBracketCharacter\n    ClassKeyword-Plhdr : ClassKeyword\n    BracketCharacter-Plhdr : BracketCharacter\n    AtomCharacter-Plhdr : AtomCharacter\n    DoubleQuote-Plhdr : DoubleQuote\n    OctalChar-Plhdr : OctalChar\n    HexHexChar-Plhdr : HexHexChar\n    DecHexChar-Plhdr : DecHexChar\n    Tab-Plhdr : Tab\n    Newline-Plhdr : Newline\n    ReturnAtom-Plhdr : ReturnAtom\n    Formfeed-Plhdr : Formfeed\n    Alarm-Plhdr : Alarm\n    Escape-Plhdr : Escape\n    WordChar-Plhdr : WordChar\n    NonWordChar-Plhdr : NonWordChar\n    WhiteSpaceChar-Plhdr : WhiteSpaceChar\n    DigitChar-Plhdr : DigitChar\n    NonDigitChar-Plhdr : NonDigitChar\n    ControlCharacter-Plhdr : ControlCharacter\n    WordBoundry-Plhdr : WordBoundry\n    NonWordBoundry-Plhdr : NonWordBoundry\n    InputBeginBoundry-Plhdr : InputBeginBoundry\n    PrevMatchEndBoundry-Plhdr : PrevMatchEndBoundry\n    EndInputBoundry-Plhdr : EndInputBoundry\n    EndInputFinalBoundry-Plhdr : EndInputFinalBoundry\n    Space-Plhdr : Space\n    NonWhiteSpaceChar-Plhdr : NonWhiteSpaceChar\n    BackReference-Plhdr : BackReference\n    QuotablePatternSymbol-Plhdr : QuotablePatternSymbol\n    Quoted-Plhdr : Quoted\n    RegexId-Plhdr : RegexId\n\nsignature\n\n  constructors\n    RegexCall : RegexExp * Id * list(Exp) -&gt; Exp\n    RegexPattern : Pattern -&gt; RegexExp\n    SingleBranch : Branche -&gt; Pattern\n    TupleBranch : Pattern * Pattern -&gt; Pattern\n    Pieces : list(Piece) -&gt; Branche\n    SingleAtom : Atom -&gt; Piece\n    QuantifiedAtom : Atom * Quantifier -&gt; Piece\n    GreedyExactBound : Integer -&gt; Quantifier\n    GreedyLowerBound : Integer -&gt; Quantifier\n    GreedyLowerUpperBound : Integer * Integer -&gt; Quantifier\n    GreedyOnceOrNot : Quantifier\n    GreedyZeroOrMore : Quantifier\n    GreedyOneOrMore : Quantifier\n    ReluctantExactBound : Integer -&gt; Quantifier\n    ReluctantLowerBound : Integer -&gt; Quantifier\n    ReluctantLowerUpperBound : Integer * Integer -&gt; Quantifier\n    ReluctantOnceOrNot : Quantifier\n    ReluctantZeroOrMore : Quantifier\n    ReluctantOneOrMore : Quantifier\n    PossessiveExactBound : Integer -&gt; Quantifier\n    PossessiveLowerBound : Integer -&gt; Quantifier\n    PossessiveLowerUpperBound : Integer * Integer -&gt; Quantifier\n    PossessiveOnceOrNot : Quantifier\n    PossessiveZeroOrMore : Quantifier\n    PossessiveOneOrMore : Quantifier\n    Capture : Pattern -&gt; Atom\n    NonCapture : Pattern -&gt; Atom\n    PositiveLookahead : Pattern -&gt; Atom\n    NegativeLookahead : Pattern -&gt; Atom\n    PositiveLookbehind : Pattern -&gt; Atom\n    NegativeLookbehind : Pattern -&gt; Atom\n    PythonCapture : RegexId * Pattern -&gt; Atom\n    RegexCapture : Pattern * RegexId -&gt; Atom\n    Empty : Atom\n    SingleCharacter : Atom\n    LineStart : Atom\n    LineEnd : Atom\n    CharacterClass : CharacterClass -&gt; Atom\n    AtomLiteral : AtomLiteral -&gt; Atom\n    AtomCharacter : AtomCharacter -&gt; Atom\n    QuotedAtom : AllChars -&gt; Atom\n    BracketList : list(BracketItem) -&gt; CharacterClass\n    NegatedBracketList : list(BracketItem) -&gt; CharacterClass\n    Range : BracketLiteralOrBracketCharacter * BracketLiteralOrBracketCharacter -&gt; BracketItem\n    BracketLiteral2BracketLiteralOrBracketCharacter : BracketLiteral -&gt; BracketLiteralOrBracketCharacter\n    BracketCharacter2BracketLiteralOrBracketCharacter : BracketCharacter -&gt; BracketLiteralOrBracketCharacter\n    Union : CharacterClass -&gt; BracketItem\n    BracketLiteral : BracketLiteral -&gt; BracketItem\n    BracketCharacter : BracketCharacter -&gt; BracketItem\n    LowerClass : ClassKeyword\n    UpperClass : ClassKeyword\n    ASCIIClass : ClassKeyword\n    AlphaClass : ClassKeyword\n    DigitClass : ClassKeyword\n    AlnumClass : ClassKeyword\n    PunctClass : ClassKeyword\n    GraphClass : ClassKeyword\n    PrintClass : ClassKeyword\n    BlankClass : ClassKeyword\n    CntrlClass : ClassKeyword\n    XDigitClass : ClassKeyword\n    WhiteSpace : ClassKeyword\n    JavaIsLowerCase : ClassKeyword\n    JavaIsUpperCase : ClassKeyword\n    JavaIsWhitespace : ClassKeyword\n    JavaIsMirrored : ClassKeyword\n    GreekBlock : ClassKeyword\n    UppercaseLetter : ClassKeyword\n    CurrencySymbol : ClassKeyword\n    DoubleQuote : DoubleQuote\n    OctalChar : OctalValue -&gt; OctalChar\n    HexHexChar : TwoHexValue -&gt; HexHexChar\n    DecHexChar : FourHexValue -&gt; DecHexChar\n    Tab : Tab\n    Newline : Newline\n    ReturnAtom : ReturnAtom\n    Formfeed : Formfeed\n    Alarm : Alarm\n    Escape : Escape\n    WordChar : WordChar\n    NonWordChar : NonWordChar\n    WhiteSpaceChar : WhiteSpaceChar\n    NonWhiteSpaceChar : NonWhiteSpaceChar\n    DigitChar : DigitChar\n    NonDigitChar : NonDigitChar\n    ControlCharacter : ControlValue -&gt; ControlCharacter\n    WordBoundry : WordBoundry\n    NonWordBoundry : NonWordBoundry\n    InputBeginBoundry : InputBeginBoundry\n    PrevMatchEndBoundry : PrevMatchEndBoundry\n    EndInputBoundry : EndInputBoundry\n    EndInputFinalBoundry : EndInputFinalBoundry\n    BackReference : BackReferenceLex -&gt; BackReference\n    Space : Space\n    DoubleQuote2BracketCharacter : DoubleQuote -&gt; BracketCharacter\n    OctalChar2BracketCharacter : OctalChar -&gt; BracketCharacter\n    HexHexChar2BracketCharacter : HexHexChar -&gt; BracketCharacter\n    DecHexChar2BracketCharacter : DecHexChar -&gt; BracketCharacter\n    Tab2BracketCharacter : Tab -&gt; BracketCharacter\n    Newline2BracketCharacter : Newline -&gt; BracketCharacter\n    ReturnAtom2BracketCharacter : ReturnAtom -&gt; BracketCharacter\n    Formfeed2BracketCharacter : Formfeed -&gt; BracketCharacter\n    Alarm2BracketCharacter : Alarm -&gt; BracketCharacter\n    Escape2BracketCharacter : Escape -&gt; BracketCharacter\n    WordChar2BracketCharacter : WordChar -&gt; BracketCharacter\n    NonWordChar2BracketCharacter : NonWordChar -&gt; BracketCharacter\n    WhiteSpaceChar2BracketCharacter : WhiteSpaceChar -&gt; BracketCharacter\n    NonWhiteSpaceChar2BracketCharacter : NonWhiteSpaceChar -&gt; BracketCharacter\n    DigitChar2BracketCharacter : DigitChar -&gt; BracketCharacter\n    NonDigitChar2BracketCharacter : NonDigitChar -&gt; BracketCharacter\n    ControlCharacter2BracketCharacter : ControlCharacter -&gt; BracketCharacter\n    WordBoundry2BracketCharacter : WordBoundry -&gt; BracketCharacter\n    NonWordBoundry2BracketCharacter : NonWordBoundry -&gt; BracketCharacter\n    InputBeginBoundry2BracketCharacter : InputBeginBoundry -&gt; BracketCharacter\n    PrevMatchEndBoundry2BracketCharacter : PrevMatchEndBoundry -&gt; BracketCharacter\n    EndInputBoundry2BracketCharacter : EndInputBoundry -&gt; BracketCharacter\n    EndInputFinalBoundry2BracketCharacter : EndInputFinalBoundry -&gt; BracketCharacter\n    BackReference2BracketCharacter : BackReference -&gt; BracketCharacter\n    Space2BracketCharacter : Space -&gt; BracketCharacter\n    DoubleQuote2AtomCharacter : DoubleQuote -&gt; AtomCharacter\n    OctalChar2AtomCharacter : OctalChar -&gt; AtomCharacter\n    HexHexChar2AtomCharacter : HexHexChar -&gt; AtomCharacter\n    DecHexChar2AtomCharacter : DecHexChar -&gt; AtomCharacter\n    Tab2AtomCharacter : Tab -&gt; AtomCharacter\n    Newline2AtomCharacter : Newline -&gt; AtomCharacter\n    ReturnAtom2AtomCharacter : ReturnAtom -&gt; AtomCharacter\n    Formfeed2AtomCharacter : Formfeed -&gt; AtomCharacter\n    Alarm2AtomCharacter : Alarm -&gt; AtomCharacter\n    Escape2AtomCharacter : Escape -&gt; AtomCharacter\n    WordChar2AtomCharacter : WordChar -&gt; AtomCharacter\n    NonWordChar2AtomCharacter : NonWordChar -&gt; AtomCharacter\n    WhiteSpaceChar2AtomCharacter : WhiteSpaceChar -&gt; AtomCharacter\n    NonWhiteSpaceChar2AtomCharacter : NonWhiteSpaceChar -&gt; AtomCharacter\n    DigitChar2AtomCharacter : DigitChar -&gt; AtomCharacter\n    NonDigitChar2AtomCharacter : NonDigitChar -&gt; AtomCharacter\n    ControlCharacter2AtomCharacter : ControlCharacter -&gt; AtomCharacter\n    WordBoundry2AtomCharacter : WordBoundry -&gt; AtomCharacter\n    NonWordBoundry2AtomCharacter : NonWordBoundry -&gt; AtomCharacter\n    InputBeginBoundry2AtomCharacter : InputBeginBoundry -&gt; AtomCharacter\n    PrevMatchEndBoundry2AtomCharacter : PrevMatchEndBoundry -&gt; AtomCharacter\n    EndInputBoundry2AtomCharacter : EndInputBoundry -&gt; AtomCharacter\n    EndInputFinalBoundry2AtomCharacter : EndInputFinalBoundry -&gt; AtomCharacter\n    BackReference2AtomCharacter : BackReference -&gt; AtomCharacter\n    Space2AtomCharacter : Space -&gt; AtomCharacter\n    Quoted : QuotablePatternSymbol -&gt; Quoted\n    Quoted2AtomCharacter : Quoted -&gt; AtomCharacter\n    Quoted2BracketCharacter : Quoted -&gt; BracketCharacter\n    QuotablePatternSymbol : QuotablePatternSymbolLex -&gt; QuotablePatternSymbol\n    DoubleQuote2QuotablePatternSymbol : DoubleQuote -&gt; QuotablePatternSymbol\n    RegexId : RegexID -&gt; RegexId\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Regex-sig.stx/#modal-h2","title":"WebDSL-Regex-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Routing-sig.stx/","title":"<code>WebDSL-Routing-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Routing-sig\n\nimports\n  signatures/WebDSL-Core-sig\n  signatures/WebDSL-Action-sig\n\nsignature\n\n  sorts\n    RoutingElement\n\n  constructors\n    RoutingElement-Plhdr : RoutingElement\n\nsignature\n\n  constructors\n    Routing : list(RoutingElement) -&gt; Definition\n    RoutingReceive : OptFormalArgs * Block -&gt; RoutingElement\n    RoutingConstruct : OptFormalArgs * Block -&gt; RoutingElement\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Routing-sig.stx/#modal-h2","title":"WebDSL-Routing-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Search-sig.stx/","title":"<code>WebDSL-Search-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Search-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Core-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-DataModel-sig\n\nsignature\n\n  sorts\n    SA-Value = string\n    SearcherKW = string\n    SearchFieldId = string\n    SEARCHERREF = string\n    FullTextAnalyzerBody\n    FullTextAnalyzerBodyDef\n    CharFilter\n    Tokenizer\n    TokenFilter\n    AnalyzerArgument\n    OptDefaultAnalyzer\n    OptAnalyzerArguments\n    SearchableAnno\n    SearchNamespaceAnno\n    SA-Argument\n    OptSAArguments\n    SA-Key\n    SearchMappingContent\n    MappingPart\n    OptDefaultSearchField\n    SearchMappingAnnoPart\n    SearchMappingId = string\n    SearcherDef\n    SearcherPart\n    QueryDef\n    Offset\n    MaxResults\n    SortBy\n    ConstraintFilter\n    FacetDef\n    SearchAttributes\n    NamespaceConstraint\n    SearchAttribute\n    FacetExp\n    FilterConstraint\n    FieldsConstraint\n    QuerySearchField\n    QueryConstraint\n    QueryBoost\n    MatchGroup\n    QueryExp\n    Slop\n    Range\n    ExpOrWildCard\n    RangeOpen\n    RangeClose\n    BoolOp\n    QueryTerm\n    SortExp\n    Direction\n    Highlight\n    RetrievalExp\n    SuggestType\n    SearchField\n    PlainField\n    SuggestionPart\n    OptQueryBoost\n    OptBoolOp\n    OptFieldsConstraint\n    OptSlop\n    OptDirection\n    GroupDef\n\n  constructors\n    FullTextAnalyzerBody-Plhdr : FullTextAnalyzerBody\n    FullTextAnalyzerBodyDef-Plhdr : FullTextAnalyzerBodyDef\n    CharFilter-Plhdr : CharFilter\n    Tokenizer-Plhdr : Tokenizer\n    TokenFilter-Plhdr : TokenFilter\n    AnalyzerArgument-Plhdr : AnalyzerArgument\n    OptDefaultAnalyzer-Plhdr : OptDefaultAnalyzer\n    OptAnalyzerArguments-Plhdr : OptAnalyzerArguments\n    SearchableAnno-Plhdr : SearchableAnno\n    SearchNamespaceAnno-Plhdr : SearchNamespaceAnno\n    SA-Argument-Plhdr : SA-Argument\n    OptSAArguments-Plhdr : OptSAArguments\n    SA-Key-Plhdr : SA-Key\n    SearchMappingContent-Plhdr : SearchMappingContent\n    MappingPart-Plhdr : MappingPart\n    OptDefaultSearchField-Plhdr : OptDefaultSearchField\n    SearchMappingAnnoPart-Plhdr : SearchMappingAnnoPart\n    SearcherDef-Plhdr : SearcherDef\n    SearcherPart-Plhdr : SearcherPart\n    QueryDef-Plhdr : QueryDef\n    Offset-Plhdr : Offset\n    MaxResults-Plhdr : MaxResults\n    SortBy-Plhdr : SortBy\n    ConstraintFilter-Plhdr : ConstraintFilter\n    FacetDef-Plhdr : FacetDef\n    SearchAttributes-Plhdr : SearchAttributes\n    NamespaceConstraint-Plhdr : NamespaceConstraint\n    SearchAttribute-Plhdr : SearchAttribute\n    FacetExp-Plhdr : FacetExp\n    FilterConstraint-Plhdr : FilterConstraint\n    FieldsConstraint-Plhdr : FieldsConstraint\n    QuerySearchField-Plhdr : QuerySearchField\n    QueryConstraint-Plhdr : QueryConstraint\n    QueryBoost-Plhdr : QueryBoost\n    MatchGroup-Plhdr : MatchGroup\n    QueryExp-Plhdr : QueryExp\n    Slop-Plhdr : Slop\n    Range-Plhdr : Range\n    ExpOrWildCard-Plhdr : ExpOrWildCard\n    RangeOpen-Plhdr : RangeOpen\n    RangeClose-Plhdr : RangeClose\n    BoolOp-Plhdr : BoolOp\n    QueryTerm-Plhdr : QueryTerm\n    SortExp-Plhdr : SortExp\n    Direction-Plhdr : Direction\n    Highlight-Plhdr : Highlight\n    RetrievalExp-Plhdr : RetrievalExp\n    SuggestType-Plhdr : SuggestType\n    SearchField-Plhdr : SearchField\n    PlainField-Plhdr : PlainField\n    SuggestionPart-Plhdr : SuggestionPart\n    OptQueryBoost-Plhdr : OptQueryBoost\n    OptBoolOp-Plhdr : OptBoolOp\n    OptFieldsConstraint-Plhdr : OptFieldsConstraint\n    OptSlop-Plhdr : OptSlop\n    OptDirection-Plhdr : OptDirection\n    GroupDef-Plhdr : GroupDef\n\nsignature\n\n  constructors\n    FullTextAnalyzer : OptDefaultAnalyzer * Id * FullTextAnalyzerBody -&gt; Definition\n    NonDefaultAnalyzer : OptDefaultAnalyzer\n    DefaultAnalyzer : OptDefaultAnalyzer\n    DefaultBuiltInAnalyzer : OptDefaultAnalyzer\n    FullTextAnalyzerBody : FullTextAnalyzerBodyDef -&gt; FullTextAnalyzerBody\n    DualFullTextAnalyzerBody : FullTextAnalyzerBodyDef * FullTextAnalyzerBodyDef -&gt; FullTextAnalyzerBody\n    FullTextAnalyzerBodyDef : list(CharFilter) * Tokenizer * list(TokenFilter) -&gt; FullTextAnalyzerBodyDef\n    CharFilter : Id * OptAnalyzerArguments -&gt; CharFilter\n    Tokenizer : Id * OptAnalyzerArguments -&gt; Tokenizer\n    TokenFilter : Id * OptAnalyzerArguments -&gt; TokenFilter\n    OptAnalyzerArgumentsNone : OptAnalyzerArguments\n    AnalyzerArguments : list(AnalyzerArgument) -&gt; OptAnalyzerArguments\n    AnalyzerArgument : Id * String -&gt; AnalyzerArgument\n    SearchableAnno : OptSAArguments -&gt; SearchableAnno\n    SearchNamespaceAnno : SearchNamespaceAnno\n    SearchableAnnoBoost : SearchableAnno * Float -&gt; Annotation\n    SearchableAnno2Annotation : SearchableAnno -&gt; Annotation\n    SearchNamespaceAnno2Annotation : SearchNamespaceAnno -&gt; Annotation\n    OptSAArgumentsNone : OptSAArguments\n    OptSAArguments : list(SA-Argument) -&gt; OptSAArguments\n    SA-Argument : SA-Key * SA-Value -&gt; SA-Argument\n    Autocomplete-Argument : SA-Argument\n    Spellcheck-Argument : SA-Argument\n    Numeric-Argument : SA-Argument\n    DefaultSF-Argument : SA-Argument\n    SAKeyAnalyzer : SA-Key\n    SAKeyName : SA-Key\n    SAKeyBoost : SA-Key\n    SAKeySubclass : SA-Key\n    SAKeyDepth : SA-Key\n    SearchMapping : Id * list(SearchMappingContent) -&gt; Definition\n    SearchMappingEmbedded : list(SearchMappingContent) -&gt; EntityBodyDeclaration\n    SearchNamespaceMapping : Id -&gt; SearchMappingContent\n    SearchNamespaceMappingAlt : Id -&gt; SearchMappingContent\n    SearchFieldMapping : OptDefaultSearchField * SearchMappingId * list(MappingPart) -&gt; SearchMappingContent\n    SearchFieldMappingAlt : OptDefaultSearchField * SearchMappingId * list(MappingPart) -&gt; SearchMappingContent\n    SearchFieldMappingIndex : OptDefaultSearchField * Id * list(MappingPart) -&gt; SearchMappingContent\n    SearchFieldMappingIndexAlt : OptDefaultSearchField * Id * list(MappingPart) -&gt; SearchMappingContent\n    FieldName : Id -&gt; MappingPart\n    AnalyzerName : Id -&gt; MappingPart\n    BoostAlt : Float -&gt; MappingPart\n    TargetEntity : Id -&gt; MappingPart\n    SearchMappingAnno : list(SearchMappingAnnoPart) -&gt; MappingPart\n    EmbeddedDepth : Int -&gt; MappingPart\n    EmbeddedDepthAlt : Int -&gt; MappingPart\n    Boost : Float -&gt; MappingPart\n    SearchMappingAnnoSpellCheck : SearchMappingAnnoPart\n    SearchMappingAnnoAutoComplete : SearchMappingAnnoPart\n    OptDefaultSearchFieldNone : OptDefaultSearchField\n    DefaultSearchField : OptDefaultSearchField\n    SearcherDef : SearcherDef -&gt; Exp\n    SearcherInit : SimpleSortLex * list(SearcherPart) -&gt; SearcherDef\n    SearcherRefMod : Exp * list(SearcherPart) -&gt; SearcherDef\n    ConstraintFilter2SearcherPart : ConstraintFilter -&gt; SearcherPart\n    QueryDef2SearcherPart : QueryDef -&gt; SearcherPart\n    Offset2SearcherPart : Offset -&gt; SearcherPart\n    MaxResults2SearcherPart : MaxResults -&gt; SearcherPart\n    SortBy2SearcherPart : SortBy -&gt; SearcherPart\n    FacetDef2SearcherPart : FacetDef -&gt; SearcherPart\n    SearchAttributes2SearcherPart : SearchAttributes -&gt; SearcherPart\n    NamespaceConstraint2SearcherPart : NamespaceConstraint -&gt; SearcherPart\n    QueryDef : list(MatchGroup) -&gt; QueryDef\n    Start : Exp -&gt; Offset\n    MaxResults : Exp -&gt; MaxResults\n    SortBy : list(SortExp) -&gt; SortBy\n    ConstraintFilter : list(FilterConstraint) -&gt; ConstraintFilter\n    ConstraintFilterAlt : list(FilterConstraint) -&gt; ConstraintFilter\n    FacetDef : list(FacetExp) -&gt; FacetDef\n    FacetDefAlt : list(FacetExp) -&gt; FacetDef\n    SearchAttributes : list(SearchAttribute) -&gt; SearchAttributes\n    NamespaceConstraint : Exp -&gt; NamespaceConstraint\n    NoLucene : SearchAttribute\n    Lucene : SearchAttribute\n    DefaultAnd : SearchAttribute\n    DefaultOr : SearchAttribute\n    DiscreteFacetDef : SearchField * Exp -&gt; FacetExp\n    RangeFacetDef : SearchField * list(Range) -&gt; FacetExp\n    FieldFilterConstraint : SearchField * Exp -&gt; FilterConstraint\n    FieldsConstraint : list(QuerySearchField) -&gt; FieldsConstraint\n    QuerySearchField : SearchField * OptQueryBoost -&gt; QuerySearchField\n    QueryConstraint : list(QueryExp) -&gt; QueryConstraint\n    QueryBoost : Exp -&gt; QueryBoost\n    Clause : OptBoolOp * list(MatchGroup) -&gt; MatchGroup\n    Query : OptFieldsConstraint * QueryConstraint -&gt; MatchGroup\n    MatchAllQuery : MatchGroup\n    TermDef : OptBoolOp * QueryTerm * OptSlop -&gt; QueryExp\n    RangeDef : OptBoolOp * Range -&gt; QueryExp\n    QueryExpGroupDef : GroupDef -&gt; QueryExp\n    GroupDef : OptBoolOp * list(QueryExp) * OptSlop -&gt; GroupDef\n    Slop : Exp -&gt; Slop\n    Range : RangeOpen * ExpOrWildCard * ExpOrWildCard * RangeClose -&gt; Range\n    RangeAlt : RangeOpen * ExpOrWildCard * ExpOrWildCard * RangeClose -&gt; Range\n    Exp2ExpOrWildCard : Exp -&gt; ExpOrWildCard\n    WildCard : ExpOrWildCard\n    ExcludingOpen : RangeOpen\n    ExcludingClose : RangeClose\n    IncludingOpen : RangeOpen\n    IncludingClose : RangeClose\n    Must : BoolOp\n    MustNot : BoolOp\n    QueryTermExp : Exp -&gt; QueryTerm\n    SortDef : SearchField * OptDirection -&gt; SortExp\n    AscendingAbbr : Direction\n    Ascending : Direction\n    DescendingAbbr : Direction\n    Descending : Direction\n    NormalHighlight : Highlight\n    HTMLHighlight : Highlight\n    Highlight : Highlight * SearchField * Exp * Exp -&gt; RetrievalExp\n    HighlightTags : Highlight * SearchField * Exp * Exp * Exp * Exp -&gt; RetrievalExp\n    SearchResults : Exp -&gt; RetrievalExp\n    FacetResults : SearchField * Exp -&gt; RetrievalExp\n    SearchResultsSize : Exp -&gt; RetrievalExp\n    SearchTimeString : Exp -&gt; RetrievalExp\n    Suggest : SimpleSortLex * SuggestType * list(SuggestionPart) -&gt; RetrievalExp\n    AutoComplete : SuggestType\n    SpellCheck : SuggestType\n    RetrievalExp : RetrievalExp -&gt; Exp\n    SearchFieldExp : Exp -&gt; SearchField\n    PlainField2SearchField : PlainField -&gt; SearchField\n    SearchFieldPlainBase : SearchFieldId -&gt; PlainField\n    SearchFieldPlain : SearchFieldId * PlainField -&gt; PlainField\n    Similarity : Exp -&gt; SuggestionPart\n    SuggestTerm : FieldsConstraint * Exp -&gt; SuggestionPart\n    NamespaceConstraint2SuggestionPart : NamespaceConstraint -&gt; SuggestionPart\n    MaxResults2SuggestionPart : MaxResults -&gt; SuggestionPart\n    OptQueryBoostNone : OptQueryBoost\n    QueryBoost2OptQueryBoost : QueryBoost -&gt; OptQueryBoost\n    OptBoolOpNone : OptBoolOp\n    BoolOp2OptBoolOp : BoolOp -&gt; OptBoolOp\n    OptFieldsConstraintNone : OptFieldsConstraint\n    FieldsConstraint2OptFieldsConstraint : FieldsConstraint -&gt; OptFieldsConstraint\n    OptSlopNone : OptSlop\n    Slop2OptSlop : Slop -&gt; OptSlop\n    OptDirectionNone : OptDirection\n    Direction2OptDirection : Direction -&gt; OptDirection\n    SearchMappingEmbeddedDepr : list(SearchMappingContent) -&gt; EntityBodyDeclaration\n    SearchMappingDepr : Id * list(SearchMappingContent) -&gt; Definition\n    CharFilterDepr : Id * OptAnalyzerArguments -&gt; CharFilter\n    TokenFilterDepr : Id * OptAnalyzerArguments -&gt; TokenFilter\n    AllFacetResults : SearchField * Exp -&gt; RetrievalExp\n    DiscreteFacetDefDepr : SearchField * Exp -&gt; FacetExp\n    RangeFacetDefDepr : SearchField * list(Range) -&gt; FacetExp\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Search-sig.stx/#modal-h2","title":"WebDSL-Search-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Service-sig.stx/","title":"<code>WebDSL-Service-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Service-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Core-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-UI-sig\n  signatures/WebDSL-DataModel-sig\n\nsignature\n\n  sorts\n    SyncConfigEmbedded\n    SyncOption\n\n  constructors\n    SyncConfigEmbedded-Plhdr : SyncConfigEmbedded\n    SyncOption-Plhdr : SyncOption\n\nsignature\n\n  constructors\n    ServiceFunction : list(Modifier) * Id * list(FormalArg) * Block -&gt; Definition\n    DeriveWebServices : Id * Id -&gt; Definition\n    SyncConfigEmbedded2EntityBodyDeclaration : SyncConfigEmbedded -&gt; EntityBodyDeclaration\n    SyncConfigEmbedded : list(SyncOption) -&gt; SyncConfigEmbedded\n    SyncTopLevelNameProperty : Id -&gt; SyncOption\n    SyncRestrictedProperties : list(Id) -&gt; SyncOption\n    SyncACRead : Exp -&gt; SyncOption\n    SyncACWrite : Exp -&gt; SyncOption\n    SyncACCreate : Exp -&gt; SyncOption\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Service-sig.stx/#modal-h2","title":"WebDSL-Service-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Test-sig.stx/","title":"<code>WebDSL-Test-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Test-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-Core-sig\n\nsignature\n\n  sorts\n\n  constructors\n\nsignature\n\n  constructors\n    Test : Id * Block -&gt; Definition\n    UnnamedTest : Block -&gt; Definition\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Test-sig.stx/#modal-h2","title":"WebDSL-Test-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-TimeInterval-sig.stx/","title":"<code>WebDSL-TimeInterval-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-TimeInterval-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Core-sig\n\nsignature\n\n  sorts\n    TimeIntervalPart\n    TimeInterval\n\n  constructors\n    TimeIntervalPart-Plhdr : TimeIntervalPart\n    TimeInterval-Plhdr : TimeInterval\n\nsignature\n\n  constructors\n    Weeks : Exp -&gt; TimeIntervalPart\n    Days : Exp -&gt; TimeIntervalPart\n    Hours : Exp -&gt; TimeIntervalPart\n    Minutes : Exp -&gt; TimeIntervalPart\n    Seconds : Exp -&gt; TimeIntervalPart\n    Milliseconds : Exp -&gt; TimeIntervalPart\n    TimeInterval : list(TimeIntervalPart) -&gt; TimeInterval\n    InvokeEvery : Exp * TimeInterval -&gt; Definition\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-TimeInterval-sig.stx/#modal-h2","title":"WebDSL-TimeInterval-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Type-sig.stx/","title":"<code>WebDSL-Type-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-Type-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-DataModel-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-Native-sig\n  signatures/WebDSL-Core-sig\n\nsignature\n\n  sorts\n    TypeElement\n\n  constructors\n    TypeElement-Plhdr : TypeElement\n\nsignature\n\n  constructors\n    TypeDef : Id * list(TypeElement) -&gt; Definition\n    TypeAnno : Annotation -&gt; TypeElement\n    TypeFunction : NCFunction -&gt; TypeElement\n    TypeFunctionFromStatic : NCFunctionFromStatic -&gt; TypeElement\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-Type-sig.stx/#modal-h2","title":"WebDSL-Type-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-UI-sig.stx/","title":"<code>WebDSL-UI-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-UI-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Attributes-sig\n  signatures/WebDSL-Core-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-XML-sig\n\nsignature\n\n  sorts\n    TemplateDefinition\n    Modifier\n    TemplateElement\n    OptFilter\n    PageCall\n    TemplateCall\n    PropertyAssignment\n    TemplateArgExp\n    TemplateCaseAlt\n    TemplateTypeCaseAlt\n    OptTemplateArgs\n    TemplateArg\n    OptLocalRedefineArgs\n    LocalRedefineArg\n    SubmitProp = string\n    VarDecl\n    Filter\n    OrderExp\n    Limit\n    ForSeparator\n    ElseIfTempl\n    OptElseTempl\n    TemplateCaseAltExps\n    OptTCallArgs\n    OptTCallPropAssigns\n    TemplateBody\n    ArgDefine\n    ActionCallOrInline\n    ActionCallOrInlineOrExp\n    PropertySubmitMultiple\n    PropertySubmitExp\n    PropertyAssignmentId = string\n    ActionModifier\n    TemplateCallId\n    FormalVarArg\n    ExpVarArg\n    ExpOrTemplateArg\n    HTMLWrapper\n    HTMLWrapperAssigns\n    HTMLWrapperBody\n    HTMLWrapperAssign\n    TemplateName\n\n  constructors\n    TemplateDefinition-Plhdr : TemplateDefinition\n    Modifier-Plhdr : Modifier\n    TemplateElement-Plhdr : TemplateElement\n    OptFilter-Plhdr : OptFilter\n    PageCall-Plhdr : PageCall\n    TemplateCall-Plhdr : TemplateCall\n    PropertyAssignment-Plhdr : PropertyAssignment\n    TemplateArgExp-Plhdr : TemplateArgExp\n    TemplateCaseAlt-Plhdr : TemplateCaseAlt\n    TemplateTypeCaseAlt-Plhdr : TemplateTypeCaseAlt\n    OptTemplateArgs-Plhdr : OptTemplateArgs\n    TemplateArg-Plhdr : TemplateArg\n    OptLocalRedefineArgs-Plhdr : OptLocalRedefineArgs\n    LocalRedefineArg-Plhdr : LocalRedefineArg\n    VarDecl-Plhdr : VarDecl\n    Filter-Plhdr : Filter\n    OrderExp-Plhdr : OrderExp\n    Limit-Plhdr : Limit\n    ForSeparator-Plhdr : ForSeparator\n    ElseIfTempl-Plhdr : ElseIfTempl\n    OptElseTempl-Plhdr : OptElseTempl\n    TemplateCaseAltExps-Plhdr : TemplateCaseAltExps\n    OptTCallArgs-Plhdr : OptTCallArgs\n    OptTCallPropAssigns-Plhdr : OptTCallPropAssigns\n    TemplateBody-Plhdr : TemplateBody\n    ArgDefine-Plhdr : ArgDefine\n    ActionCallOrInline-Plhdr : ActionCallOrInline\n    ActionCallOrInlineOrExp-Plhdr : ActionCallOrInlineOrExp\n    PropertySubmitMultiple-Plhdr : PropertySubmitMultiple\n    PropertySubmitExp-Plhdr : PropertySubmitExp\n    ActionModifier-Plhdr : ActionModifier\n    TemplateCallId-Plhdr : TemplateCallId\n    FormalVarArg-Plhdr : FormalVarArg\n    ExpVarArg-Plhdr : ExpVarArg\n    ExpOrTemplateArg-Plhdr : ExpOrTemplateArg\n    HTMLWrapper-Plhdr : HTMLWrapper\n    HTMLWrapperAssigns-Plhdr : HTMLWrapperAssigns\n    HTMLWrapperBody-Plhdr : HTMLWrapperBody\n    HTMLWrapperAssign-Plhdr : HTMLWrapperAssign\n    TemplateName-Plhdr : TemplateName\n\nsignature\n\n  constructors\n    TemplateDefinition : TemplateDefinition -&gt; Definition\n    Define : list(Modifier) * Id * OptFormalArgs * OptTemplateArgs * list(TemplateElement) -&gt; TemplateDefinition\n    TemplateArgs : list(TemplateArg) -&gt; OptTemplateArgs\n    OptTemplateArgsNone : OptTemplateArgs\n    TemplateArg : TemplateId * list(Sort) -&gt; TemplateArg\n    LocalRedefine : list(Modifier) * TemplateId * list(FormalArg) * TemplateId * OptLocalRedefineArgs -&gt; TemplateDefinition\n    OptLocalRedefineArgsNone : OptLocalRedefineArgs\n    LocalRedefineArgs : list(LocalRedefineArg) -&gt; OptLocalRedefineArgs\n    LocalRedefineArg : Id -&gt; LocalRedefineArg\n    DefinePage : list(Modifier) * PageId * OptFormalArgs * OptTemplateArgs * list(TemplateElement) -&gt; TemplateDefinition\n    DefineTemplate : list(Modifier) * TemplateId * OptFormalArgs * OptTemplateArgs * list(TemplateElement) -&gt; TemplateDefinition\n    DefineEmail : list(Modifier) * Id * OptFormalArgs * OptTemplateArgs * list(TemplateElement) -&gt; TemplateDefinition\n    Page : Modifier\n    Email : Modifier\n    AjaxTemplate : Modifier\n    Template : Modifier\n    Feed : Modifier\n    Local : Modifier\n    NoSpan : Modifier\n    TemplateModSpan : Modifier\n    TemplateModInline : Modifier\n    TempateModSecure : Modifier\n    TemplateModNotSecure : Modifier\n    TemplateModOverride : Modifier\n    TemplateDeprecated : Modifier\n    ExpireCache : Modifier\n    ReadOnlyPage : Modifier\n    WebService : Modifier\n    Init : Block -&gt; TemplateElement\n    Action2TemplateElement : Action -&gt; TemplateElement\n    TemplateVarDecl : VarId * Sort -&gt; VarDecl\n    TemplateVarDeclDepr : VarId * Sort -&gt; VarDecl\n    TemplateVarDeclInit : VarId * Sort * Exp -&gt; VarDecl\n    TemplateVarDeclInitDepr : VarId * Sort * Exp -&gt; VarDecl\n    TemplateVarDeclInitInferred : VarId * Exp -&gt; VarDecl\n    TemplateVarDeclInitInferredDepr : VarId * Exp -&gt; VarDecl\n    TEVarDecl : VarDecl -&gt; TemplateElement\n    RequestScopeTemplate : VarDecl -&gt; TemplateElement\n    LocalScopeTemplate : VarDecl -&gt; TemplateElement\n    TemplateDefinition2TemplateElement : TemplateDefinition -&gt; TemplateElement\n    TemplateCall2TemplateElement : TemplateCall -&gt; TemplateElement\n    FilterNoOrderByNoLimit : Exp -&gt; Filter\n    FilterNoWhereNoLimit : list(OrderExp) -&gt; Filter\n    FilterNoLimit : Exp * list(OrderExp) -&gt; Filter\n    FilterNoOrderBy : Exp * Limit -&gt; Filter\n    FilterNoWhere : list(OrderExp) * Limit -&gt; Filter\n    FilterNoWhereNoOrderBy : Limit -&gt; Filter\n    Filter : Exp * list(OrderExp) * Limit -&gt; Filter\n    OrderNonSpecific : Exp -&gt; OrderExp\n    OrderAscending : Exp -&gt; OrderExp\n    OrderDescending : Exp -&gt; OrderExp\n    Limit : Exp * Exp -&gt; Limit\n    LimitNoOffset : Exp -&gt; Limit\n    LimitNoLimit : Exp -&gt; Limit\n    OptFilterSome : Filter -&gt; OptFilter\n    OptFilterNone : OptFilter\n    For : VarId * Sort * Exp * OptFilter * list(TemplateElement) * ForSeparator -&gt; TemplateElement\n    ForInferred : VarId * Exp * OptFilter * list(TemplateElement) * ForSeparator -&gt; TemplateElement\n    ForAll : VarId * Sort * OptFilter * list(TemplateElement) * ForSeparator -&gt; TemplateElement\n    ForCount : VarId * Exp * Exp * list(TemplateElement) * ForSeparator -&gt; TemplateElement\n    ForSeparator : list(TemplateElement) -&gt; ForSeparator\n    ForSeparatorNone : ForSeparator\n    IfTempl : Exp * list(TemplateElement) * list(TemplateElement) -&gt; TemplateElement\n    IfNoElseTempl : Exp * list(TemplateElement) -&gt; TemplateElement\n    IfElseIfTempl : Exp * list(TemplateElement) * list(ElseIfTempl) * OptElseTempl -&gt; TemplateElement\n    OptElseTemplNone : OptElseTempl\n    ElseTempl : list(TemplateElement) -&gt; OptElseTempl\n    ElseIfTempl : Exp * list(TemplateElement) -&gt; ElseIfTempl\n    TemplateCase : list(Exp) * list(TemplateCaseAlt) -&gt; TemplateElement\n    TemplateCaseAlt : TemplateCaseAltExps * list(TemplateElement) -&gt; TemplateCaseAlt\n    TemplateCaseAltDefault : list(TemplateElement) -&gt; TemplateCaseAlt\n    TemplateTypeCase : Exp * OptTypeAlias * list(TemplateTypeCaseAlt) -&gt; TemplateElement\n    TemplateTypeCaseAlt : Sort * list(TemplateElement) -&gt; TemplateTypeCaseAlt\n    TemplateTypeCaseDefault : list(TemplateElement) -&gt; TemplateTypeCaseAlt\n    TemplateCaseExps : list(Exp) -&gt; TemplateCaseAltExps\n    TemplateCall : TemplateCallId * OptTCallArgs * OptTCallPropAssigns * TemplateBody -&gt; TemplateCall\n    TCallArgs : list(TemplateArgExp) -&gt; OptTCallArgs\n    OptTCallArgsNone : OptTCallArgs\n    Exp : Exp -&gt; TemplateArgExp\n    TemplateElementsArgument : list(TemplateElement) -&gt; TemplateArgExp\n    TCallPropAssigns : list(PropertyAssignment) -&gt; OptTCallPropAssigns\n    OptTCallPropAssignsNone : OptTCallPropAssigns\n    TemplateBody : list(TemplateElement) -&gt; TemplateBody\n    TemplateBodyNone : TemplateBody\n    TemplateWith : list(ArgDefine) -&gt; TemplateBody\n    ArgDefine : TemplateCallId * list(FormalArg) * list(TemplateElement) -&gt; ArgDefine\n    NavigateCallParenthesesNoProps : PageCall * list(TemplateElement) -&gt; TemplateElement\n    NavigateCallParentheses : PageCall * list(PropertyAssignment) * list(TemplateElement) -&gt; TemplateElement\n    NavigateCallNoProps : PageCall * list(TemplateElement) -&gt; TemplateElement\n    NavigateCall : PageCall * list(PropertyAssignment) * list(TemplateElement) -&gt; TemplateElement\n    PageCall : PageId * list(Exp) -&gt; PageCall\n    SubmitActionNoProps : Exp * ActionCallOrInline -&gt; TemplateElement\n    SubmitAction : Exp * ActionCallOrInline * list(PropertyAssignment) -&gt; TemplateElement\n    SubmitLinkActionNoProps : Exp * ActionCallOrInline -&gt; TemplateElement\n    SubmitLinkAction : Exp * ActionCallOrInline * list(PropertyAssignment) -&gt; TemplateElement\n    SubmitNoProps : Exp * ActionCallOrInline -&gt; TemplateElement\n    Submit : Exp * ActionCallOrInline * list(PropertyAssignment) -&gt; TemplateElement\n    SubmitLinkNoProps : Exp * ActionCallOrInline -&gt; TemplateElement\n    SubmitLink : Exp * ActionCallOrInline * list(PropertyAssignment) -&gt; TemplateElement\n    SubmitElemNoProps : ActionCallOrInline * list(TemplateElement) -&gt; TemplateElement\n    SubmitElem : ActionCallOrInline * list(PropertyAssignment) * list(TemplateElement) -&gt; TemplateElement\n    SubmitLinkElemNoProps : ActionCallOrInline * list(TemplateElement) -&gt; TemplateElement\n    SubmitLinkElem : ActionCallOrInline * list(PropertyAssignment) * list(TemplateElement) -&gt; TemplateElement\n    DownloadLinkNoProps : ActionCallOrInline * list(TemplateElement) -&gt; TemplateElement\n    DownloadLink : ActionCallOrInline * list(PropertyAssignment) * list(TemplateElement) -&gt; TemplateElement\n    OutputImageNoProps : ActionCallOrInline * list(TemplateElement) -&gt; TemplateElement\n    OutputImage : ActionCallOrInline * list(PropertyAssignment) * list(TemplateElement) -&gt; TemplateElement\n    ActionCall : ThisCall -&gt; ActionCallOrInline\n    InlineAction : Block -&gt; ActionCallOrInline\n    PropertySubmitColon : SubmitProp * ActionCallOrInlineOrExp -&gt; PropertyAssignment\n    PropertySubmitAssign : SubmitProp * ActionCallOrInlineOrExp -&gt; PropertyAssignment\n    PropertySubmit : SubmitProp * ActionCallOrInlineOrExp -&gt; PropertyAssignment\n    PropertyAssignmentColon : PropertyAssignmentId * Exp -&gt; PropertyAssignment\n    PropertyAssignmentAssign : PropertyAssignmentId * Exp -&gt; PropertyAssignment\n    PropertyAssignment : PropertyAssignmentId * Exp -&gt; PropertyAssignment\n    TemplateCallPropertyAjax : PropertyAssignment\n    TemplateCallPropertyNoLoadingFeedback : PropertyAssignment\n    TemplateCallPropertySecure : PropertyAssignment\n    TemplateCallPropertyIgnoreValidation : PropertyAssignment\n    TemplateCallPropertyNotSecure : PropertyAssignment\n    TemplateCallPropertyNotNull : PropertyAssignment\n    CommonAttribute2PropertyAssignment : CommonAttribute -&gt; PropertyAssignment\n    PropertySubmitMultiple2PropertyAssignment : PropertySubmitMultiple -&gt; PropertyAssignment\n    PropertySubmitMultiple : SubmitProp * list(ActionCallOrInlineOrExp) -&gt; PropertySubmitMultiple\n    ActionCallOrInline : ActionCallOrInline -&gt; ActionCallOrInlineOrExp\n    ActionCallOrInlineExp : PropertySubmitExp -&gt; ActionCallOrInlineOrExp\n    PropertySubmitExp : Exp -&gt; PropertySubmitExp\n    OutputShorthand2TemplateElement : OutputShorthand -&gt; TemplateElement\n    Text : list(StringPart) -&gt; TemplateElement\n    GlobalInit : Block -&gt; Definition\n    DataBindAction : Block -&gt; TemplateElement\n    RenderAction : Block -&gt; TemplateElement\n    AllPhasesAction : Block -&gt; TemplateElement\n    ValidateAction : Block -&gt; TemplateElement\n    Action : list(ActionModifier) * Id * OptFormalArgs * Block -&gt; Action\n    ActionModifierIgnoreValidation : ActionModifier\n    QualifiedElementsCall : TemplateId -&gt; TemplateCallId\n    TemplateCallId : TemplateId -&gt; TemplateCallId\n    TemplateVarArgSort : list(FormalVarArg) -&gt; Sort\n    FormalVarArg : Id * Sort -&gt; FormalVarArg\n    MemberTemplateCall : Id * TemplateCall -&gt; TemplateCall\n    TemplateVarArgExp : list(ExpVarArg) -&gt; Exp\n    ExpVarArgFor : Id * Sort * Exp * OptFilter * list(ExpVarArg) -&gt; ExpVarArg\n    ExpVarArgForInferred : Id * Exp * OptFilter * list(ExpVarArg) -&gt; ExpVarArg\n    ExpVarArgForAll : Id * Sort * OptFilter * list(ExpVarArg) -&gt; ExpVarArg\n    ExpVarArgForCount : Id * Exp * Exp * list(ExpVarArg) -&gt; ExpVarArg\n    ExpVarArg : list(ExpOrTemplateArg) -&gt; ExpVarArg\n    ExpVarArgExp : Exp -&gt; ExpOrTemplateArg\n    ExpVarArgElements : list(TemplateElement) -&gt; ExpOrTemplateArg\n    HTMLWrapper : HTMLWrapperBody -&gt; HTMLWrapper\n    HTMLWrapperAssigns : list(HTMLWrapperAssign) -&gt; HTMLWrapperAssigns\n    HTMLWrapperAssignsNone : HTMLWrapperAssigns\n    HTMLWrapperAssign : Attribute -&gt; HTMLWrapperAssign\n    HTMLWrapperAssignComma : Attribute -&gt; HTMLWrapperAssign\n    HTMLWrapper2TemplateDefinition : HTMLWrapper -&gt; TemplateDefinition\n    HTMLWrapperMultiple : list(HTMLWrapperBody) -&gt; TemplateDefinition\n    HTMLWrapperBody : Id * Id * HTMLWrapperAssigns -&gt; HTMLWrapperBody\n    TemplateName : TemplateName\n    TemplateName2Exp : TemplateName -&gt; Exp\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-UI-sig.stx/#modal-h2","title":"WebDSL-UI-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-XML-sig.stx/","title":"<code>WebDSL-XML-sig.stx</code>","text":"<pre><code>module signatures/WebDSL-XML-sig\n\nimports\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-UI-sig\n  signatures/WebDSL-Attributes-sig\n\nsignature\n\n  sorts\n    HTML5VoidElement = string\n    XMLComment = string\n    XMLCommentChar = string\n    OneDash = string\n    TwoDashes = string\n    QualName = string\n    Qualifier = string\n    NCName = string\n    XMLTagName = string\n    CommonAttribute\n\n  constructors\n    CommonAttribute-Plhdr : CommonAttribute\n\nsignature\n\n  constructors\n    XMLEmptyElement : XMLTagName * list(Attribute) -&gt; TemplateElement\n    XMLElement : XMLTagName * list(Attribute) * list(TemplateElement) * XMLTagName -&gt; TemplateElement\n    XMLEmptyElementUnclosed : HTML5VoidElement * list(Attribute) -&gt; TemplateElement\n    XMLComment : XMLComment -&gt; TemplateElement\n    XMLAttributesIf : Exp * list(Attribute) -&gt; Attribute\n    XMLAttributesIfElse : Exp * list(Attribute) * list(Attribute) -&gt; Attribute\n    Attribute : QualName * Exp -&gt; Attribute\n    CommonAttribute2Attribute : CommonAttribute -&gt; Attribute\n    AllAttributes : CommonAttribute\n    AllAttributesExceptExp : Exp -&gt; CommonAttribute\n    AttributesExp : Exp -&gt; CommonAttribute\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/WebDSL-XML-sig.stx/#modal-h2","title":"WebDSL-XML-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/permissive-water-sig.stx/","title":"<code>permissive-water-sig.stx</code>","text":"<pre><code>module signatures/permissive-water-sig\n\nimports\n\nsignature\n\n  sorts\n    WATER = string\n    WATERTOKEN = string\n    WATERTOKENSTART = string\n    WATERTOKENSEPARATOR = string\n\n  constructors\n\nsignature\n\n  constructors\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/permissive-water-sig.stx/#modal-h2","title":"permissive-water-sig.stx","text":""},{"location":"webdslstatix/src-gen/statix/signatures/webdsl-statix-sig.stx/","title":"<code>webdsl-statix-sig.stx</code>","text":"<pre><code>module signatures/webdsl-statix-sig\n\nimports\n  signatures/WebDSL-AccessControl-sig\n  signatures/WebDSL-Action-sig\n  signatures/WebDSL-Ajax-sig\n  signatures/WebDSL-Attributes-sig\n  signatures/WebDSL-Core-sig\n  signatures/WebDSL-DataModel-sig\n  signatures/WebDSL-DataValidation-sig\n  signatures/WebDSL-Dispatch-sig\n  signatures/WebDSL-EntityDerive-sig\n  signatures/WebDSL-Exception-sig\n  signatures/WebDSL-Expand-sig\n  signatures/WebDSL-Generated-sig\n  signatures/WebDSL-JavaScript-sig\n  signatures/WebDSL-Lexical-sig\n  signatures/WebDSL-Native-sig\n  signatures/WebDSL-Prefetch-sig\n  signatures/WebDSL-Regex-sig\n  signatures/WebDSL-Routing-sig\n  signatures/WebDSL-Search-sig\n  signatures/WebDSL-Service-sig\n  signatures/WebDSL-Test-sig\n  signatures/WebDSL-TimeInterval-sig\n  signatures/WebDSL-Type-sig\n  signatures/WebDSL-UI-sig\n  signatures/WebDSL-XML-sig\n\nsignature\n\n  sorts\n\n  constructors\n\nsignature\n\n  constructors\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/statix/signatures/webdsl-statix-sig.stx/#modal-h2","title":"webdsl-statix-sig.stx","text":""},{"location":"webdslstatix/src-gen/syntax/permissive-water.sdf3/","title":"<code>permissive-water.sdf3</code>","text":"<pre><code>module permissive-water\n\n// Key idea: WATER is the inverse of LAYOUT\n\ncontext-free syntax\n  // Allow WATER on places where LAYOUT may occur\n  LAYOUT.WATER = WATER\n\nlexical sorts\n  WATER\n  WATERTOKEN\n  WATERTOKENSTART\n  WATERTOKENSEPARATOR\n\nlexical syntax\n  // Separate water regions into smaller chunks for recovery costs calculation\n  WATER = WATERTOKEN\n  WATER = WATERTOKENSEPARATOR\n\n  // Allow to skip over identifier strings\n  WATERTOKEN      = WATERTOKENSTART [A-Za-z0-9\\_]*\n  WATERTOKENSTART = [A-Za-z0-9\\_] {recover}\n\n  // Allow to skip over special characters that are neither part of identifiers nor whitespace characters\n  WATERTOKENSEPARATOR = ~[A-Za-z0-9\\_\\ \\t\\12\\r\\n\\*] {recover}\n\nlexical restrictions\n  WATERTOKEN -/- [A-Za-z0-9\\_]\n</code></pre> \u00d7"},{"location":"webdslstatix/src-gen/syntax/permissive-water.sdf3/#modal-h2","title":"permissive-water.sdf3","text":""},{"location":"webdslstatix/syntax/HQL.sdf3/","title":"<code>HQL.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/HQL.sdf3</p> <pre><code>module HQL\n\nimports\n\n  WebDSL-Action\n  WebDSL-Lexical\n  WebDSL-UI\n\nlexical sorts\n\n  HQLIdentifier HQLIdParameter HQLNumParameter HQLNumInt HQLQuotedString HQLQuotedStringChar\n\nlexical syntax\n\n  HQLIdentifier = [a-zA-Z\\_] [a-zA-Z0-9\\_]*\n  HQLIdParameter = \":\" HQLIdentifier\n  HQLNumParameter = \"?\" HQLNumInt\n  HQLNumInt = [0-9]+\n  HQLQuotedString = \"'\" HQLQuotedStringChar* \"'\"\n  HQLQuotedStringChar = ~[\\']\n  HQLQuotedStringChar = \"\\\\'\"\n\nlexical restrictions\n\n  HQLIdentifier -/- [a-zA-Z0-9\\_]\n  \"from\" -/- [a-zA-Z0-9\\_]\n  \"select\" -/- [a-zA-Z0-9\\_]\n\ncontext-free sorts\n\n  HQLStatement HQLDeleteStatement HQLSelectClauseOpt HQLFromClause HQLQueryRule HQLSelectFrom\n  HQLDistinctOpt HQLSelection HQLFromRangeJoin HQLFromJoin HQLJoinTypeOpt HQLFetchOpt\n  HQLWithClauseOpt HQLFromRange\n\ncontext-free syntax\n\n  HQLStatement.DeleteStatement = HQLDeleteStatement\n  HQLStatement.SelectStatement = HQLQueryRule\n\n  HQLDeleteStatement.HQLDeleteStatement = &lt;delete &lt;HQLFromClause&gt; &lt;HQLWhereClauseOpt&gt;&gt;\n\n  HQLQueryRule.QueryRule = &lt;&lt;HQLSelectFrom&gt; &lt;HQLWhereClauseOpt&gt; &lt;HQLGroupByClauseOpt&gt; &lt;HQLOrderByClauseOpt&gt;&gt;\n\n  HQLSelectFrom.SelectFrom = &lt;&lt;HQLSelectClauseOpt&gt; &lt;HQLFromClause&gt;&gt;\n\n  HQLSelectClauseOpt.Select     = &lt;select &lt;HQLDistinctOpt&gt; &lt;HQLSelection&gt;&gt;\n  HQLSelectClauseOpt.SelectNone = &lt;&gt;\n\n  HQLDistinctOpt.Distinct     = &lt;distinct&gt;\n  HQLDistinctOpt.NoneDistinct = &lt;&gt;\n\n  HQLSelection.NewExpression      = &lt;new &lt;HQLPath&gt; ( &lt;{HQLAliasedExpression \",\"}+&gt; )&gt;\n  HQLSelection.SelectObject       = &lt;object ( &lt;HQLIdentifier&gt; )&gt;\n  HQLSelection.SelectedProperties = &lt;&lt;{HQLAliasedExpression \",\"}+&gt;&gt;\n\n  HQLFromClause.FromClause = &lt;from &lt;{HQLFromRangeJoin \",\"}+&gt;&gt;\n\n  HQLFromRangeJoin.FromRangeJoin = &lt;&lt;HQLFromRange&gt; &lt;HQLFromJoin*&gt;&gt;\n\n  HQLFromJoin.FromJoin = &lt;&lt;HQLJoinTypeOpt&gt; join &lt;HQLFetchOpt&gt; &lt;HQLPath&gt; &lt;HQLAsAliasOpt&gt; &lt;HQLPropertyFetchOpt&gt; &lt;HQLWithClauseOpt&gt;&gt;\n  HQLJoinTypeOpt.LeftJoin       = &lt;left&gt;\n  HQLJoinTypeOpt.RightJoin      = &lt;right&gt;\n  HQLJoinTypeOpt.LeftOuterJoin  = &lt;left outer&gt;\n  HQLJoinTypeOpt.RightOuterJoin = &lt;right outer&gt;\n  HQLJoinTypeOpt.FullJoin       = &lt;full&gt;\n  HQLJoinTypeOpt.InnerJoin      = &lt;inner&gt;\n  HQLJoinTypeOpt.JoinTypeNone   = &lt;&gt;\n\n  HQLFetchOpt.Fetch     = &lt;fetch&gt;\n  HQLFetchOpt.FetchNone = &lt;&gt;\n\n  HQLWithClauseOpt.WithClause     = &lt;with &lt;HQLExpression&gt;&gt;\n  HQLWithClauseOpt.WithClauseNone = &lt;&gt;\n\n  HQLFromRange.FromClassOrOuterQueryPath        = &lt;&lt;HQLPath&gt; &lt;HQLAsAliasOpt&gt; &lt;HQLPropertyFetchOpt&gt;&gt;\n  HQLFromRange.InClassDeclaration               = &lt;&lt;HQLAlias&gt; in class &lt;HQLPath&gt;&gt;\n  HQLFromRange.InCollectionDeclaration          = &lt;in ( &lt;HQLPath&gt; ) &lt;HQLAlias&gt;&gt;\n  HQLFromRange.InCollectionElementsDeclaration  = &lt;&lt;HQLAlias&gt; in elements ( &lt;HQLPath&gt; )&gt;\n\ncontext-free sorts\n\n  HQLPropertyFetchOpt HQLAlias HQLAsAliasOpt HQLGroupByClauseOpt HQLOrderByClauseOpt\n  HQLOrderElement HQLAscOrDescOpt HQLHavingClauseOpt HQLWhereClauseOpt HQLAliasedExpression\n  HQLPath\n\ncontext-free syntax\n\n  HQLAsAliasOpt.AsAlias     = &lt;as &lt;HQLAlias&gt;&gt;\n  HQLAsAliasOpt.AsAliasNone = &lt;&gt;\n  HQLAlias.Alias = &lt;&lt;HQLIdentifier&gt;&gt;\n\n  HQLPropertyFetchOpt.PropertyFetch     = &lt;fetch all properties&gt;\n  HQLPropertyFetchOpt.PropertyFetchNone = &lt;&gt;\n\n  HQLGroupByClauseOpt.HQLGroupBy     = &lt;group by &lt;{HQLExpression \",\"}+&gt; &lt;HQLHavingClauseOpt&gt;&gt;\n  HQLGroupByClauseOpt.HQLGroupByNone = &lt;&gt;\n\n  HQLOrderByClauseOpt.OrderByClause = &lt;order by &lt;{HQLOrderElement \",\"}+&gt;&gt;\n  HQLOrderByClauseOpt.OrderByClauseNone = &lt;&gt;\n  HQLOrderElement.OrderElement = &lt;&lt;HQLExpression&gt; &lt;HQLAscOrDescOpt&gt;&gt;\n\n  HQLAscOrDescOpt.HQLAscending      = &lt;ascending&gt;\n  HQLAscOrDescOpt.HQLAscendingAbbr  = &lt;asc&gt;\n\n  HQLAscOrDescOpt.HQLDescending     = &lt;descending&gt;\n  HQLAscOrDescOpt.HQLDescendingAbbr = &lt;desc&gt;\n  HQLAscOrDescOpt.AscOrDescNone     = &lt;&gt;\n\n  HQLHavingClauseOpt.HavingClause     = &lt;having &lt;HQLExpression&gt;&gt;\n  HQLHavingClauseOpt.HavingClauseNone = &lt;&gt;\n\n  HQLWhereClauseOpt.WhereClause     = &lt;where &lt;HQLExpression&gt;&gt;\n  HQLWhereClauseOpt.WhereClauseNone = &lt;&gt;\n\n  HQLAliasedExpression.AliasedExpression = &lt;&lt;HQLExpression&gt; &lt;HQLAsAliasOpt&gt;&gt;\n\n  HQLPath.Path = &lt;&lt;{HQLIdentifier \".\"}+&gt;&gt;\n\nlexical syntax\n\n  HQLIdentifier = \"select\" {reject}\n  HQLIdentifier = \"from\" {reject}\n  HQLIdentifier = \"by\" {reject}\n  HQLIdentifier = \"order\" {reject}\n\n  TemplateId = \"by\" {reject}\n  TemplateId = \"order\" {reject}\n  TemplateId = \"having\" {reject}\n  TemplateId = \"where\" {reject}\n  TemplateId = \"as\" {reject}\n  TemplateId = \"in\" {reject}\n\ncontext-free syntax\n\n  TemplateCall = &lt;select&gt; {reject}\n\ncontext-free sorts\n\n  HQLExpression HQLConstant\n\ncontext-free syntax\n\n  HQLExpression.HQLDslExp = DslExp\n\n  HQLExpression.HQLPath = HQLPath\n\n  HQLExpression.HQLExpressions = &lt;( &lt;{HQLExpression \",\"}+&gt; )&gt;\n  HQLExpression.HQLQueryRule = &lt;( &lt;HQLQueryRule&gt; )&gt;\n  HQLExpression.HQLQueryRuleAlt = HQLQueryRule\n\n  HQLExpression.QueryOr   = &lt;&lt;HQLExpression&gt; or &lt;HQLExpression&gt;&gt;\n  HQLExpression.QueryAnd  = &lt;&lt;HQLExpression&gt; and &lt;HQLExpression&gt;&gt;\n  HQLExpression.QueryNot  = &lt;not &lt;HQLExpression&gt;&gt;\n\n  HQLExpression.QueryEq       = &lt;&lt;HQLExpression&gt; = &lt;HQLExpression&gt;&gt;\n  HQLExpression.QueryIs       = &lt;&lt;HQLExpression&gt; is &lt;HQLExpression&gt;&gt;\n  HQLExpression.QueryNe       = &lt;&lt;HQLExpression&gt; != &lt;HQLExpression&gt;&gt;\n  HQLExpression.QuerySqlNe    = &lt;&lt;HQLExpression&gt; \\&lt;\\&gt; &lt;HQLExpression&gt;&gt;\n  HQLExpression.QueryLike     = &lt;&lt;HQLExpression&gt; like &lt;HQLExpression&gt;&gt;\n  HQLExpression.QueryNotLike  = &lt;&lt;HQLExpression&gt; not like &lt;HQLExpression&gt;&gt;\n\n  HQLExpression.QueryLt = &lt;&lt;HQLExpression&gt; \\&lt; &lt;HQLExpression&gt;&gt;\n  HQLExpression.QueryLe = &lt;&lt;HQLExpression&gt; \\&lt;= &lt;HQLExpression&gt;&gt;\n  HQLExpression.QueryGt = &lt;&lt;HQLExpression&gt; \\&gt; &lt;HQLExpression&gt;&gt;\n  HQLExpression.QueryGe = &lt;&lt;HQLExpression&gt; \\&gt;= &lt;HQLExpression&gt;&gt;\n\n  HQLExpression.QueryIn           = &lt;&lt;HQLExpression&gt; in &lt;HQLExpression&gt;&gt;\n  HQLExpression.QueryNotIn        = &lt;&lt;HQLExpression&gt; not in &lt;HQLExpression&gt;&gt;\n  HQLExpression.QueryMemberOf     = &lt;&lt;HQLExpression&gt; member of &lt;HQLExpression&gt;&gt;\n  HQLExpression.QueryNotMemberOf  = &lt;&lt;HQLExpression&gt; not member of &lt;HQLExpression&gt;&gt;\n\n  HQLExpression.QueryConcat = &lt;&lt;HQLExpression&gt; || &lt;HQLExpression&gt;&gt;\n\n  HQLExpression.QueryPlus   = &lt;&lt;HQLExpression&gt; + &lt;HQLExpression&gt;&gt;\n  HQLExpression.QueryMinus  = &lt;&lt;HQLExpression&gt; - &lt;HQLExpression&gt;&gt;\n\n  HQLExpression.QueryMultiply = &lt;&lt;HQLExpression&gt; * &lt;HQLExpression&gt;&gt;\n  HQLExpression.QueryDivide   = &lt;&lt;HQLExpression&gt; / &lt;HQLExpression&gt;&gt;\n  HQLExpression.QueryModulo   = &lt;&lt;HQLExpression&gt; % &lt;HQLExpression&gt;&gt;\n\n  HQLExpression.QueryUMinus = &lt;- &lt;HQLExpression&gt;&gt;\n\n  HQLExpression.HQLFunCurDate       = &lt;current_date ( )&gt;\n  HQLExpression.HQLFunCurTime       = &lt;current_time ( )&gt;\n  HQLExpression.HQLFunCurTimestamp  = &lt;current_timestamp ( )&gt;\n  HQLExpression.HQLFunSecond        = &lt;second ( &lt;HQLExpression&gt; )&gt;\n  HQLExpression.HQLFunMinute        = &lt;minute ( &lt;HQLExpression&gt; )&gt;\n  HQLExpression.HQLFunHour          = &lt;hour   ( &lt;HQLExpression&gt; )&gt;\n  HQLExpression.HQLFunDay           = &lt;day    ( &lt;HQLExpression&gt; )&gt;\n  HQLExpression.HQLFunMonth         = &lt;month  ( &lt;HQLExpression&gt; )&gt;\n  HQLExpression.HQLFunYear          = &lt;year   ( &lt;HQLExpression&gt; )&gt;\n\n  HQLExpression.HQLAvg        = &lt;avg        ( &lt;HQLExpression&gt; )&gt;\n  HQLExpression.HQLSum        = &lt;sum        ( &lt;HQLExpression&gt; )&gt;\n  HQLExpression.HQLMin        = &lt;min        ( &lt;HQLExpression&gt; )&gt;\n  HQLExpression.HQLMax        = &lt;max        ( &lt;HQLExpression&gt; )&gt;\n  HQLExpression.HQLCountStar  = &lt;count      ( * )&gt;\n  HQLExpression.HQLCount      = &lt;count      ( &lt;HQLExpression&gt; )&gt;\n  HQLExpression.HQLSize       = &lt;size       ( &lt;HQLExpression&gt; )&gt;\n  HQLExpression.HQLSubString  = &lt;substring  ( &lt;HQLExpression&gt; , &lt;HQLExpression&gt; , &lt;HQLExpression&gt; )&gt;\n\n  HQLExpression.HQLElements = &lt;elements ( &lt;HQLPath&gt; )&gt;\n  HQLExpression.HQLIndices  = &lt;indices  ( &lt;HQLPath&gt; )&gt;\n\n  HQLExpression.HQLConstant = &lt;&lt;HQLConstant&gt;&gt;\n\n  HQLConstant.HQLTrue   = &lt;true&gt;\n  HQLConstant.HQLFalse  = &lt;false&gt;\n  HQLConstant.HQLEmpty  = &lt;empty&gt;\n  HQLConstant.HQLNull   = &lt;null&gt;\n  HQLConstant.HQLString = HQLQuotedString\n  HQLConstant.HQLNumInt = HQLNumInt\n\nlexical syntax\n\n  HQLIdentifier = \"true\" {reject}\n  HQLIdentifier = \"false\" {reject}\n  HQLIdentifier = \"empty\" {reject}\n  HQLIdentifier = \"null\" {reject}\n\n  TemplateId = \"or\" {reject}\n  TemplateId = \"and\" {reject}\n  TemplateId = \"not\" {reject}\n\ncontext-free syntax\n\n  TemplateCall = &lt;empty&gt; {reject}\n\ncontext-free priorities\n\n  {\n    HQLExpression.HQLPath\n    HQLExpression.HQLExpressions\n    HQLExpression.HQLAvg\n    HQLExpression.HQLSum\n    HQLExpression.HQLMin\n    HQLExpression.HQLMax\n    HQLExpression.HQLCountStar\n    HQLExpression.HQLCount\n    HQLExpression.HQLSize\n    HQLExpression.HQLSubString\n    HQLExpression.HQLElements\n    HQLExpression.HQLIndices\n    HQLExpression.QueryUMinus\n  }\n  &gt; {left:\n    HQLExpression.QueryMultiply\n    HQLExpression.QueryDivide\n    HQLExpression.QueryModulo\n    HQLExpression.QueryConcat\n  }\n  &gt; {left:\n    HQLExpression.QueryPlus\n    HQLExpression.QueryMinus\n  }\n  &gt; {left:\n    HQLExpression.QueryLike\n    HQLExpression.QueryNotLike\n    HQLExpression.QueryLt\n    HQLExpression.QueryLe\n    HQLExpression.QueryGt\n    HQLExpression.QueryGe\n    HQLExpression.QueryIn\n    HQLExpression.QueryNotIn\n    HQLExpression.QueryMemberOf\n    HQLExpression.QueryNotMemberOf\n  }\n  &gt; {left:\n    HQLExpression.QueryEq\n    HQLExpression.QueryIs\n    HQLExpression.QueryNe\n    HQLExpression.QuerySqlNe\n  }\n  &gt; HQLExpression.QueryNot\n  &gt; {left: HQLExpression.QueryAnd}\n  &gt; {left: HQLExpression.QueryOr}\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/HQL.sdf3/#modal-h2","title":"HQL.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-AccessControl.sdf3/","title":"<code>WebDSL-AccessControl.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-AccessControl.sdf3</p> <pre><code>module WebDSL-AccessControl\n\nimports\n  WebDSL-Action\n  WebDSL-Core\n  WebDSL-DataModel\n  WebDSL-Lexical\n  WebDSL-UI\n\ncontext-free sorts\n\n  // Optional sorts\n  OptMatchArgs OptId OptWildCardArg\n\n  // Access control sorts\n  AccessControlDefinition AccessControlRule AccessControlPointcutElement\n  AccessControlImportRulesArg PolicyExp MatchName\n\nsyntax\n\n  MatchName-CF.MatchNameWildCard = \"*\"\n  MatchName-CF.MatchName = PageId-LEX OptWildCardArg-CF\n\ncontext-free syntax\n\n  Section.AccessControlDefinition = &lt;\n    access control rules &lt;OptId&gt;\n      &lt;AccessControlDefinition*&gt;\n  &gt;\n  Section.AccessControlDefinitionAlt = &lt;\n    access control rules { &lt;OptId&gt;\n      &lt;AccessControlDefinition*&gt;\n    }\n  &gt;\n\n  Definition.Predicate = &lt;\n    predicate &lt;Id&gt; &lt;OptFormalArgs&gt; {\n      &lt;Exp&gt;\n    }\n  &gt;\n  Definition.AccessControlPrincipalDef = &lt;\n    principal is &lt;Id&gt; with credentials &lt;{Id \",\"}+&gt;\n  &gt;\n\n  AccessControlDefinition.PredicateAc = &lt;\n    predicate &lt;Id&gt; &lt;OptFormalArgs&gt; {\n      &lt;Exp&gt;\n    }\n  &gt;\n  AccessControlDefinition.AccessControlPrincipalAcDef = &lt;\n    principal is &lt;Id&gt; with credentials &lt;{Id \",\"}+&gt;\n  &gt;\n  AccessControlDefinition.AccessControlPointcut = &lt;\n    pointcut &lt;Id&gt; ( &lt;{FormalArg \",\"}*&gt; ) {\n      &lt;{AccessControlPointcutElement \",\"}*&gt;\n    }\n  &gt;\n  AccessControlDefinition.Rule = AccessControlRule\n\n  AccessControlRule.AccessControlRule = &lt;\n    rule &lt;AccessControlType&gt; &lt;MatchName&gt; &lt;OptMatchArgs&gt; {\n      &lt;Exp&gt; &lt;AccessControlRule*&gt;\n    }\n  &gt;\n  AccessControlRule.SpecialAccessControlRule = &lt;\n    rule logsql {\n      &lt;Exp&gt;\n    }\n  &gt;\n\n  AccessControlPointcutElement.AccessControlPointcutElement = &lt;\n    &lt;AccessControlType&gt; &lt;MatchName&gt; ( &lt;{Id \",\"}*&gt; &lt;OptWildCardArg&gt; )\n  &gt;\n\n  Section.ACPolicy = &lt;\n    access control policy &lt;PolicyExp&gt;\n  &gt;\n  PolicyExp.Name = Id\n  PolicyExp = &lt;( &lt;PolicyExp&gt; )&gt; {bracket}\n  PolicyExp.PolicyAnd = &lt;&lt;PolicyExp&gt; AND &lt;PolicyExp&gt;&gt;\n  PolicyExp.PolicyOr = &lt;&lt;PolicyExp&gt; OR &lt;PolicyExp&gt;&gt;\n\n  EntityBodyDeclaration.PredicateInEntity = &lt;\n    predicate &lt;Id&gt; &lt;OptFormalArgs&gt; {\n      &lt;Exp&gt;\n    }\n  &gt;\n\n  Modifier.IgnoreAccessControl = &lt;ignore-access-control&gt;\n\n  TemplateElement.AccessControlImportRules = &lt;\n    apply ac rules &lt;Id&gt; ( &lt;{AccessControlImportRulesArg \",\"}*&gt; )\n  &gt;\n\nlexical syntax\n\n  TemplateId = \"rules\" {reject}\n\ncontext-free syntax\n\n  AccessControlImportRulesArg.ACVar = Id\n\n  OptMatchArgs.MatchArgs = &lt;( &lt;{FormalArg \",\"}*&gt; &lt;OptWildCardArg&gt; )&gt;\n  OptMatchArgs.OptMatchArgsNone = &lt;&gt;\n\n  OptId.Id = Id\n  OptId.OptIdNone = &lt;&gt;\n\n  OptWildCardArg.WildCardArg = &lt;*&gt;\n  OptWildCardArg.OptWildCardArgNone = &lt;&gt;\n\ncontext-free sorts\n\n  AccessControlType\n\ncontext-free syntax\n\n  AccessControlType.ACTypePage          = &lt;page&gt;\n  AccessControlType.ACTypeAction        = &lt;action&gt;\n  AccessControlType.ACTypeTemplate      = &lt;template&gt;\n  AccessControlType.ACTypeAjaxTemplate  = &lt;ajaxtemplate&gt;\n  AccessControlType.ACTypePointcut      = &lt;pointcut&gt;\n\ncontext-free priorities\n\n  {left: PolicyExp.PolicyAnd} &gt;\n  {left: PolicyExp.PolicyOr}\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-AccessControl.sdf3/#modal-h2","title":"WebDSL-AccessControl.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Action.sdf3/","title":"<code>WebDSL-Action.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Action.sdf3</p> <pre><code>module WebDSL-Action\n\nimports\n  WebDSL-Core\n  WebDSL-DataModel\n  WebDSL-Lexical\n  WebDSL-Search\n  WebDSL-UI\n  HQL\n\ncontext-free sorts\n\n  OptSort Block Function\n\ncontext-free syntax\n\n  Function.Function = &lt;\n    function &lt;FunId&gt; &lt;OptFormalArgs&gt; &lt;OptSort&gt; &lt;Block&gt;\n  &gt;\n  OptSort.OptSortNone = &lt;&gt;\n  OptSort.OptSortSome = &lt;: &lt;Sort&gt;&gt;\n  Definition.GlobalFunction = &lt;\n    &lt;Function&gt;\n  &gt;\n  Definition.CachedGlobalFunction = &lt;cached &lt;Function&gt;&gt;\n  Definition.ExtendGlobalFunction = &lt;extend &lt;Function&gt;&gt;\n  EntityBodyDeclaration.EntityFunction = &lt;&lt;Function&gt;&gt;\n  EntityBodyDeclaration.CachedFunction = &lt;cached &lt;Function&gt;&gt;\n  EntityBodyDeclaration.ExtendFunction = &lt;extend &lt;Function&gt;&gt;\n  EntityBodyDeclaration.StaticEntityFunction = &lt;static &lt;Function&gt;&gt;\n\ncontext-free syntax\n\n  Exp.FunctionExp = &lt;function &lt;OptFormalArgs&gt; &lt;OptSort&gt; &lt;Block&gt;&gt;\n  Exp.FunctionRef = &lt;function . &lt;FunId&gt; ( &lt;{Sort \",\"}*&gt; ) &lt;OptSort&gt;&gt;\n  Exp.FunctionRefCall = &lt;function . &lt;FunId&gt; ( &lt;{Sort \",\"}*&gt; ) &lt;OptSort&gt; ( &lt;{Exp \",\"}*&gt; )&gt;\n  Exp.FunctionRefCallPartial = &lt;function . &lt;FunId&gt; ( &lt;{Sort \",\"}*&gt; ) &lt;OptSort&gt; ( * , &lt;{Exp \",\"}*&gt; )&gt;\n\nlexical syntax\n\n  VarId = \"function\" {reject}\n\ncontext-free syntax\n\n  Block.Block = &lt;{\n    &lt;Statement*&gt;\n  }&gt;\n  Statement = Block\n  Statement.Stat = &lt;\n    &lt;Exp&gt;;\n  &gt;\n  Statement.Return = &lt;\n    return &lt;Exp&gt;;\n  &gt;\n  Statement.ReturnEmpty = &lt;\n    return;\n  &gt;\n\nlexical syntax\n\n  VarId = \"return\" {reject}\n  FunId = \"return\" {reject}\n\ncontext-free priorities\n\n  Statement.Stat &lt;0&gt; .&gt; Exp.Var\n\ncontext-free syntax\n\n  Statement.GoTo = &lt;\n    goto &lt;PageCall&gt;;\n  &gt;\n  Statement.GoToAlt = &lt;\n    goto ( &lt;PageCall&gt; );\n  &gt;\n\n  ThisCall = &lt;goto ( &lt;PageCall&gt; )&gt; {reject}\n\n  Statement.VarDecl = &lt;\n    var &lt;VarId&gt; : &lt;Sort&gt;;\n  &gt;\n  Statement.VarDeclInit = &lt;\n    var &lt;VarId&gt; : &lt;Sort&gt; := &lt;Exp&gt;;\n  &gt;\n  Statement.VarDeclInitInferred = &lt;\n    var &lt;VarId&gt; := &lt;Exp&gt;;\n  &gt;\n\ncontext-free sorts\n\n  ElseIfStatement OptElse Case TypeCaseAlt OptTypeAlias\n\ncontext-free syntax\n\n  Statement.If = &lt;\n    if ( &lt;Exp&gt; ) &lt;Block&gt; else &lt;Block&gt;\n  &gt;\n  Statement.IfNoElse = &lt;\n    if ( &lt;Exp&gt; ) &lt;Block&gt;\n  &gt;\n  Statement.IfWithElseIf = &lt;\n    if ( &lt;Exp&gt; ) &lt;Block&gt; &lt;ElseIfStatement+&gt; &lt;OptElse&gt;\n  &gt;\n  ElseIfStatement.ElseIf = &lt;else if ( &lt;Exp&gt; ) &lt;Block&gt;&gt;\n  OptElse.OptElseSome = &lt;else &lt;Block&gt;&gt;\n  OptElse.OptElseNone = &lt;&gt;\n\n  Statement.CaseStmt = &lt;\n    case ( &lt;{Exp \",\"}+&gt; ) {\n      &lt;Case*&gt;\n    }\n  &gt;\n  Case.CaseAlt = &lt;\n    &lt;CaseAltExps&gt; &lt;Block&gt;\n  &gt;\n  Case.CaseAltDefault = &lt;\n    default &lt;Block&gt;\n  &gt;\n\n  Statement.TypeCaseStmt = &lt;\n    typecase ( &lt;Exp&gt; &lt;OptTypeAlias&gt; ) {\n      &lt;TypeCaseAlt*&gt;\n    }\n  &gt;\n  OptTypeAlias.TypeAlias = &lt;as &lt;Id&gt;&gt;\n  OptTypeAlias.OptTypeAliasNone = &lt;&gt;\n  TypeCaseAlt.TypeCaseAlt = &lt;\n    &lt;Sort&gt; &lt;Block&gt;\n  &gt;\n  TypeCaseAlt.TypeCaseAltDefault = &lt;\n    default &lt;Block&gt;\n  &gt;\n\ncontext-free sorts\n\n  CaseAltExps\n\ncontext-free syntax\n\n  CaseAltExps.CaseExps = &lt;&lt;{Exp \",\"}+&gt;&gt;\n  CaseAltExps = &lt;default&gt; {reject}\n\ncontext-free priorities\n\n  Statement.TypeCaseStmt &lt;2&gt; .&gt; Exp.Cast\n\ncontext-free syntax\n\n  Statement.ForStmt = &lt;\n    for ( &lt;VarId&gt; : &lt;Sort&gt; in &lt;Exp&gt; &lt;OptFilter&gt; ) &lt;Block&gt;\n  &gt;\n  Statement.ForStmtInferred = &lt;\n    for ( &lt;VarId&gt; in &lt;Exp&gt; &lt;OptFilter&gt; ) &lt;Block&gt;\n  &gt;\n  Statement.ForAllStmt = &lt;\n    for ( &lt;VarId&gt; : &lt;Sort&gt; &lt;OptFilter&gt; ) &lt;Block&gt;\n  &gt;\n  Statement.ForCountStmt = &lt;\n    for ( &lt;VarId&gt; : Int from &lt;Exp&gt; to &lt;Exp&gt; ) &lt;Block&gt;\n  &gt;\n  Statement.WhileStmt = &lt;\n    while ( &lt;Exp&gt; ) &lt;Block&gt;\n  &gt;\n\nlexical sorts\n\n  ThisLex\n\nlexical syntax\n\n  ThisLex = \"this\"\n\nlexical restrictions\n\n  ThisLex -/- [a-zA-Z0-9]\n\ncontext-free sorts\n\n  ConstValue Exp PropAssignment ObjectPropertyAssignment Mapping ThisCall FAExp\n\ncontext-free syntax\n\n  Exp.Const = ConstValue\n\n  ConstValue.Int = Int\n  ConstValue.Long = Long\n  ConstValue.Float = Float\n  ConstValue.StringConst = String\n\n  Exp.Var = VarId\n  Exp.FieldAccess = &lt;&lt;FAExp&gt; . &lt;PropertyId&gt;&gt;\n  Exp.CollectionIndex = &lt;&lt;Exp&gt; [ &lt;Exp&gt; ]&gt;\n  Exp.This = &lt;&lt;ThisLex&gt;&gt;\n\n  FAExp.FAExp = &lt;&lt;Exp&gt;&gt;\n  FAExp.FAVar = &lt;&lt;FAVarId&gt;&gt;\n  FAExp.FAGlobal = &lt;global&gt;\n  FAExp.FASession = &lt;session&gt;\n\ncontext-free priorities\n\n  FAExp.FAExp &lt;0&gt; .&gt; Exp.Var\n\nlexical syntax\n\n  VarId = \"this\" {reject}\n  PropertyId = \"this\" {reject}\n\n  FAVarId = \"global\" {reject}\n  FAVarId = \"session\" {reject}\n\ncontext-free syntax\n\n  Exp.ObjectCreation = &lt;&lt;SimpleSortLex&gt; {\n    &lt;PropAssignment*&gt;\n  }&gt;\n\n  PropAssignment.PropAssignment = &lt;&lt;ObjectPropertyAssignment&gt;&gt;\n  PropAssignment.PropAssignmentComma = &lt;&lt;ObjectPropertyAssignment&gt; ,&gt;\n  ObjectPropertyAssignment.ObjectPropertyAssignment = &lt;\n    &lt;Id&gt; := &lt;Exp&gt;\n  &gt;\n\n/*\n  used in sdf2 definition as workaround to get working autocompletion:\n  ObjectPropertyAssignment.IncompleteObjectPropertyAssignment = &lt;\n    &lt;Id&gt;\n  &gt;\n*/\n\n  Statement.Assignment = &lt;\n    &lt;Exp&gt; := &lt;Exp&gt; ;\n  &gt;\n\n  Exp.MapCreation = &lt;[ &lt;Mapping+&gt; ]&gt;\n  Mapping.Mapping = &lt;&lt;Exp&gt; -\\&gt; &lt;Exp&gt;&gt;\n  Exp.ListCreation = &lt;[ &lt;{Exp \",\"}*&gt; ]&gt;\n  Exp.SetCreation = &lt;{ &lt;{Exp \",\"}+&gt; }&gt;\n  Exp.TypedListCreation = &lt;List \\&lt; &lt;Sort&gt; \\&gt; ( &lt;{Exp \",\"}*&gt; )&gt;\n  Exp.TypedSetCreation = &lt;Set \\&lt; &lt;Sort&gt; \\&gt; ( &lt;{Exp \",\"}*&gt; )&gt;\n\nlexical syntax\n\n  VarId = \"List\" {reject}\n  VarId = \"Set\" {reject}\n\ncontext-free syntax\n\n  Exp = ThisCall\n  ThisCall.ThisCall = &lt;&lt;FunId&gt; ( &lt;{Exp \",\"}*&gt; )&gt;\n  Exp.Call = &lt;&lt;Exp&gt; . &lt;Id&gt; ( &lt;{Exp \",\"}*&gt; )&gt;\n  Exp.IsA = &lt;&lt;Exp&gt; is a &lt;Sort&gt;&gt;\n  Exp.Cast = &lt;&lt;Exp&gt; as &lt;Sort&gt;&gt;\n  Exp.InColl = &lt;&lt;Exp&gt; in &lt;Exp&gt;&gt;\n\n  Exp.IfExp = &lt;if ( &lt;Exp&gt; ) &lt;Exp&gt; else &lt;Exp&gt;&gt;\n\n  OutputShorthand.OutputShorthand = &lt;~ ( &lt;Exp&gt; )&gt;\n  SimpleExp.SimpleThisCall = ThisCall\n  SimpleExp.SimpleCall = &lt;&lt;SimpleExp&gt; . &lt;Id&gt; ( &lt;{Exp \",\"}*&gt; )&gt;\n\nlexical syntax\n\n  VarId = \"if\" {reject}\n  VarId = \"else\" {reject}\n\nsyntax\n\n  StringPart-CF.InterpExp = \"~\" \"(\" Exp-CF \")\"\n\ncontext-free restrictions\n\n  \"in\" -/- [a-zA-Z0-9\\_]\n\ncontext-free sorts\n\n  OptGroupBy GroupBy ForExp\n\ncontext-free syntax\n\n  Exp.Eq = &lt;&lt;Exp&gt; == &lt;Exp&gt;&gt; {left}\n  Exp.NotEq = &lt;&lt;Exp&gt; != &lt;Exp&gt;&gt; {left}\n  Exp.LargerThan = &lt;&lt;Exp&gt; \\&gt; &lt;Exp&gt;&gt; {left}\n  Exp.LargerThanOrEqual = &lt;&lt;Exp&gt; \\&gt;= &lt;Exp&gt;&gt; {left}\n  Exp.SmallerThan = &lt;&lt;Exp&gt; \\&lt; &lt;Exp&gt;&gt; {left}\n  Exp.SmallerThanOrEqual = &lt;&lt;Exp&gt; \\&lt;= &lt;Exp&gt;&gt; {left}\n\n  Exp.True = &lt;true&gt;\n  Exp.False = &lt;false&gt;\n  Exp.Null = &lt;null&gt;\n\nlexical syntax\n\n  VarId = \"true\" {reject}\n  VarId = \"false\" {reject}\n  VarId = \"null\" {reject}\n\n  TemplateId = \"true\" {reject}\n  TemplateId = \"false\" {reject}\n  TemplateId = \"null\" {reject}\n\ncontext-free syntax\n\n  Exp.And = &lt;&lt;Exp&gt; &amp;&amp; &lt;Exp&gt;&gt; {left}\n  Exp.Or = &lt;&lt;Exp&gt; || &lt;Exp&gt;&gt; {left}\n  Exp.Not = &lt;! &lt;Exp&gt;&gt;\n  Exp = &lt;( &lt;Exp&gt; )&gt; {bracket}\n  ForExp.ForExp                           = &lt;[ &lt;Exp&gt; | &lt;VarId&gt; : &lt;Sort&gt; in &lt;Exp&gt; &lt;OptFilter&gt; &lt;OptGroupBy&gt; ]&gt;\n  ForExp.ForExpInferred                   = &lt;[ &lt;Exp&gt; | &lt;VarId&gt; in &lt;Exp&gt; &lt;OptFilter&gt; &lt;OptGroupBy&gt; ]&gt;\n  ForExp.ForExpShort                      = &lt;[ &lt;VarId&gt; : &lt;Sort&gt; in &lt;Exp&gt; ]&gt;\n  ForExp.ForExpShortFilter                = &lt;[ &lt;VarId&gt; : &lt;Sort&gt; in &lt;Exp&gt; &lt;Filter&gt; ]&gt;\n  ForExp.ForExpShortFilterInferred        = &lt;[ &lt;VarId&gt; in &lt;Exp&gt; &lt;Filter&gt; ]&gt;\n  ForExp.ForExpShortGroupBy               = &lt;[ &lt;VarId&gt; : &lt;Sort&gt; in &lt;Exp&gt; &lt;GroupBy&gt; ]&gt;\n  ForExp.ForExpShortGroupByInferred       = &lt;[ &lt;VarId&gt; in &lt;Exp&gt; &lt;GroupBy&gt; ]&gt;\n  ForExp.ForExpShortFilterGroupBy         = &lt;[ &lt;VarId&gt; : &lt;Sort&gt; in &lt;Exp&gt; &lt;Filter&gt; &lt;GroupBy&gt; ]&gt;\n  ForExp.ForExpShortFilterGroupByInferred = &lt;[ &lt;VarId&gt; in &lt;Exp&gt; &lt;Filter&gt; &lt;GroupBy&gt; ]&gt;\n  Exp = ForExp\n  OptGroupBy.OptGroupBySome = GroupBy\n  OptGroupBy.OptGroupByNone = &lt;&gt;\n  GroupBy.GroupBy = &lt;group by &lt;Exp&gt;&gt;\n  Exp.AndForExp = &lt;And &lt;ForExp&gt;&gt;\n  Exp.OrForExp = &lt;Or &lt;ForExp&gt;&gt;\n  Exp.Mul = &lt;&lt;Exp&gt; * &lt;Exp&gt;&gt; {left}\n  Exp.Div = &lt;&lt;Exp&gt; / &lt;Exp&gt;&gt; {left}\n  Exp.Mod = &lt;&lt;Exp&gt; % &lt;Exp&gt;&gt; {left}\n  Exp.Add = &lt;&lt;Exp&gt; + &lt;Exp&gt;&gt; {left}\n  Exp.Sub = &lt;&lt;Exp&gt; - &lt;Exp&gt;&gt; {left}\n\ncontext-free sorts\n\n  HqlExp LimitValueExp DslExp\n\ncontext-free syntax\n\n  Exp.HqlExp = HqlExp\n\n  HqlExp.HqlQuery             = &lt;&lt;HQLQueryRule&gt;&gt;\n  HqlExp.HqlQueryLimit        = &lt;&lt;HQLQueryRule&gt; limit &lt;LimitValueExp&gt;&gt;\n  HqlExp.HqlQueryLimitOffset  = &lt;&lt;HQLQueryRule&gt; limit &lt;LimitValueExp&gt; , &lt;LimitValueExp&gt;&gt;\n\n  LimitValueExp.LimitValueExp     = &lt;&lt;Exp&gt;&gt;\n  LimitValueExp.LimitValueDslExp  = &lt;&lt;DslExp&gt;&gt;\n\n  DslExp.DslExp = &lt;~ &lt;Exp&gt;&gt;\n\n  Statement.HqlStatement = &lt;\n    &lt;HQLDeleteStatement&gt; ;\n  &gt;\n\ncontext-free priorities\n\n  {left :\n    Exp.Call\n    Exp.FieldAccess\n    Exp.CollectionIndex\n  } &gt;\n  {non-assoc :\n    Exp.IsA\n    Exp.Cast\n    Exp.InColl\n  } &gt;\n  {\n    Exp.Not\n  } &gt;\n  {left :\n    Exp.Mul\n    Exp.Div\n    Exp.Mod\n  } &gt;\n  {left:\n    Exp.Add\n    Exp.Sub\n  } &gt;\n  {left : Exp.RetrievalExp } &gt;\n  {left :\n    Exp.Eq\n    Exp.NotEq\n    Exp.LargerThan\n    Exp.LargerThanOrEqual\n    Exp.SmallerThan\n    Exp.SmallerThanOrEqual\n  } &gt;\n  {left : Exp.And } &gt;\n  {left : Exp.Or } &gt;\n  { Exp.HqlExp } &gt;\n  { Exp.SearcherDef } &gt;\n  { Exp.IfExp }\n\ncontext-free sorts\n\n  EmailCall\n\ncontext-free syntax\n\n  Exp.RenderEmailFunctionCall = &lt;renderemail ( &lt;EmailCall&gt; )&gt;\n  Exp.EmailFunctionCall = &lt;email ( &lt;EmailCall&gt; )&gt;\n  Exp.EmailFunctionCallAlt = &lt;email &lt;EmailCall&gt;&gt;\n  Exp.SendEmailFunctionCall = &lt;sendemail ( &lt;EmailCall&gt; )&gt;\n  EmailCall.EmailCall = &lt;&lt;Id&gt; ( &lt;{Exp \",\"}*&gt; )&gt;\n\n  Exp.RenderTemplateFunctionCall = &lt;rendertemplate ( &lt;TemplateCall&gt; )&gt;\n  Exp.ValidateTemplateFunctionCall = &lt;validatetemplate ( &lt;TemplateCall&gt; )&gt;\n\ncontext-free syntax\n\n  ThisCall = &lt;renderemail ( &lt;EmailCall&gt; )&gt; {reject}\n  ThisCall = &lt;email ( &lt;EmailCall&gt; )&gt; {reject}\n  ThisCall = &lt;email &lt;EmailCall&gt;&gt; {reject}\n  ThisCall = &lt;sendemail ( &lt;EmailCall&gt; )&gt; {reject}\n\n  ThisCall = &lt;rendertemplate ( &lt;TemplateCall&gt; )&gt; {reject}\n  ThisCall = &lt;validatetemplate ( &lt;TemplateCall&gt; )&gt; {reject}\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Action.sdf3/#modal-h2","title":"WebDSL-Action.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Ajax.sdf3/","title":"<code>WebDSL-Ajax.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Ajax.sdf3</p> <pre><code>module WebDSL-Ajax\n\nimports\n  WebDSL-Action\n  WebDSL-Lexical\n  WebDSL-UI\n  WebDSL-Core\n\ncontext-free sorts\n\n  AjaxStatement Placeholder PlaceholderWithAjaxCall PlaceholderVar AjaxVisibility AjaxReplaceTemplateCall\n\ncontext-free syntax\n\n  Statement.AjaxStatement = &lt;\n    &lt;AjaxStatement&gt; ;\n  &gt;\n\n  AjaxStatement.AjaxReplace = &lt;replace ( &lt;Exp&gt; , &lt;AjaxReplaceTemplateCall&gt; )&gt;\n  AjaxStatement.AjaxAppend = &lt;append ( &lt;Exp&gt; , &lt;TemplateCall&gt; )&gt;\n  AjaxStatement.AjaxVisibility = &lt;visibility ( &lt;Exp&gt; , &lt;AjaxVisibility&gt; )&gt;\n  AjaxVisibility.Show = &lt;show&gt;\n  AjaxVisibility.Toggle = &lt;toggle&gt;\n  AjaxVisibility.Hide = &lt;hide&gt;\n  AjaxStatement.AjaxRelocate = &lt;relocate ( &lt;PageCall&gt; )&gt;\n  AjaxStatement.AjaxRestyle = &lt;restyle ( &lt;Exp&gt; , &lt;Exp&gt; )&gt;\n  AjaxStatement.AjaxClear = &lt;clear ( &lt;Exp&gt; )&gt;\n  AjaxStatement.AjaxRefresh = &lt;refresh ( )&gt;\n  AjaxStatement.AjaxRunScript = &lt;runscript ( &lt;Exp&gt; )&gt;\n\ncontext-free syntax\n\n  AjaxReplaceTemplateCall.AjaxReplaceTemplateCall = &lt;&lt;TemplateCall&gt;&gt;\n  AjaxReplaceTemplateCall.AjaxReplaceEmpty = &lt;&lt;EmptyLex&gt;&gt;\n\nlexical sorts\n\n  EmptyLex\n\nlexical syntax\n\n  EmptyLex = \"empty\"\n\ncontext-free syntax\n\n  ThisCall = &lt;replace ( &lt;Exp&gt; , &lt;AjaxReplaceTemplateCall&gt; )&gt; {reject}\n  ThisCall = &lt;append ( &lt;Exp&gt; , &lt;TemplateCall&gt; )&gt; {reject}\n  ThisCall = &lt;visibility ( &lt;Exp&gt; , &lt;AjaxVisibility&gt; )&gt; {reject}\n  ThisCall = &lt;relocate ( &lt;PageCall&gt; )&gt; {reject}\n  ThisCall = &lt;restyle ( &lt;Exp&gt; , &lt;Exp&gt; )&gt; {reject}\n  ThisCall = &lt;clear ( &lt;Exp&gt; )&gt; {reject}\n  ThisCall = &lt;refresh ( )&gt; {reject}\n  ThisCall = &lt;runscript ( &lt;Exp&gt; )&gt; {reject}\n\ncontext-free syntax\n\n  TemplateElement.TEPlaceholder = &lt;\n    &lt;Placeholder&gt;\n  &gt;\n  TemplateElement.TEPlaceholderWithAjaxCall = &lt;\n    &lt;PlaceholderWithAjaxCall&gt;\n  &gt;\n\n  Placeholder.PlaceholderHtml = &lt;placeholder \\&lt; &lt;Id&gt; \\&gt; &lt;Id&gt; {\n    &lt;TemplateElement*&gt;\n  }&gt;\n  Placeholder.PlaceholderHtmlExp = &lt;placeholder \\&lt; &lt;Id&gt; \\&gt; &lt;Exp&gt; {\n    &lt;TemplateElement*&gt;\n  }&gt;\n  Placeholder.Placeholder = &lt;placeholder &lt;Id&gt; {\n    &lt;TemplateElement*&gt;\n  }&gt;\n  Placeholder.PlaceholderExp = &lt;placeholder &lt;Exp&gt; {\n    &lt;TemplateElement*&gt;\n  }&gt;\n\n  PlaceholderWithAjaxCall.PlaceholderAjaxHtml = &lt;placeholder \\&lt; &lt;Id&gt; \\&gt; &lt;Id&gt; &lt;TemplateCall&gt;&gt;\n  PlaceholderWithAjaxCall.PlaceholderAjaxHtmlExp = &lt;placeholder \\&lt; &lt;Id&gt; \\&gt; &lt;PHExp&gt; &lt;TemplateCall&gt;&gt;\n  PlaceholderWithAjaxCall.PlaceholderAjax = &lt;placeholder &lt;Id&gt; &lt;TemplateCall&gt;&gt;\n  PlaceholderWithAjaxCall.PlaceholderAjaxExp = &lt;placeholder &lt;PHExp&gt; &lt;TemplateCall&gt;&gt;\n\n  TemplateElement = PlaceholderVar\n\n  PlaceholderVar.PlaceholderVar = &lt;placeholdervar &lt;Id&gt;&gt;\n\nlexical syntax\n\n  TemplateId = \"placeholder\" {reject}\n  TemplateId = \"placeholdervar\" {reject}\n\nlexical restrictions\n\n  \"placeholder\" -/- [a-zA-Z0-9]\n\ncontext-free priorities\n\n  Placeholder.PlaceholderHtmlExp &lt;4&gt; .&gt; Exp.Var,\n  Placeholder.PlaceholderExp &lt;1&gt; .&gt; Exp.Var\n\ncontext-free sorts\n\n  PHExp\n\ncontext-free syntax\n\n  PHExp.PHThisCall = ThisCall\n  PHExp.PHCall = &lt;&lt;Exp&gt; . &lt;Id&gt; ( &lt;{Exp \",\"}*&gt; )&gt;\n  PHExp.PHFieldAccess = &lt;&lt;Exp&gt; . &lt;PropertyId&gt;&gt;\n  PHExp.PHCollectionIndex = &lt;&lt;Exp&gt; [ &lt;Exp&gt; ]&gt;\n  PHExp.PHAdd = &lt;&lt;Exp&gt; + &lt;Exp&gt;&gt;\n  PHExp.PHConst = ConstValue\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Ajax.sdf3/#modal-h2","title":"WebDSL-Ajax.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Attributes.sdf3/","title":"<code>WebDSL-Attributes.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Attributes.sdf3</p> <pre><code>module WebDSL-Attributes\n\nimports\n  WebDSL-Action\n  WebDSL-Lexical\n  WebDSL-Core\n  WebDSL-UI\n\ncontext-free sorts\n\n  AttributeSelection AttributeCollectionOverride AttributeElem AttributeIncludeIgnore Attribute\n\ncontext-free syntax\n\n  Definition.AttributeCollection = &lt;\n    &lt;AttributeCollectionOverride&gt; attributes &lt;Id&gt; {\n      &lt;AttributeElem*&gt;\n    }\n  &gt;\n  AttributeElem.AttributeAssign = &lt;&lt;AttributeId&gt; = &lt;Exp&gt;&gt;\n  AttributeElem.AttributeInclude = &lt;&lt;AttributeId&gt; attributes &lt;AttributeIncludeIgnore&gt;&gt;\n  AttributeElem.AttributeIgnore = &lt;ignore &lt;AttributeId&gt; attributes&gt;\n  AttributeIncludeIgnore.AttributeIncludeIgnoreNone = &lt;&gt;\n  AttributeIncludeIgnore.AttributeIncludeIgnore = &lt;ignore &lt;AttributeId+&gt;&gt;\n  AttributeCollectionOverride.AttributeCollectionOverrideNone = &lt;&gt;\n  AttributeCollectionOverride.AttributeCollectionOverride = &lt;override&gt;\n\nlexical sorts\n\n  AttributeId\n\nlexical syntax\n\n  AttributeId = Id\n  AttributeId = \"all\" {reject}\n  AttributeId = \"attributes\" {reject}\n\ncontext-free syntax\n\n  AttributeSelection.AttributeSelection = &lt;&lt;AttributeId&gt; attributes&gt;\n  AttributeSelection.AttributeIgnoreDefault = &lt;ignore default &lt;AttributeId&gt;&gt;\n\n  PropertyAssignment = AttributeSelection\n  Attribute = AttributeSelection\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Attributes.sdf3/#modal-h2","title":"WebDSL-Attributes.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Core.sdf3/","title":"<code>WebDSL-Core.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Core.sdf3</p> <pre><code>module WebDSL-Core\n\nimports\n  WebDSL-Action\n  WebDSL-DataModel\n  WebDSL-Lexical\n\ncontext-free sorts\n\n  FormalArg OptFormalArgs FunctionSortParams FunctionSortParam FunctionSortReturn OptCallArgs Sort\n\ncontext-free syntax %% Types\n\n  Sort.SimpleSort = &lt;&lt;SimpleSortLex&gt;&gt;\n  Sort.GenericSort = &lt;&lt;GenericSortLex&gt; \\&lt; &lt;{Sort \",\"}+&gt; \\&gt;&gt;\n  Sort.ListSort = &lt;[ &lt;Sort&gt; ]&gt;\n  Sort.SetSort = &lt;{ &lt;Sort&gt; }&gt;\n  Sort.RefSort = &lt;ref &lt;Sort&gt;&gt;\n  Sort.RefSortAlt = &lt;Ref \\&lt; &lt;Sort&gt; \\&gt;&gt;\n  Sort.FunctionSort = &lt;function &lt;FunctionSortParams&gt; &lt;FunctionSortReturn&gt;&gt;\n\nlexical syntax\n\n  SimpleSortLex = \"function\" {reject}\n\ncontext-free syntax\n\n  %% function type; optionally specify (named) args and return type\n  FunctionSortParams.FunctionSortParams = &lt;( &lt;{FunctionSortParam \",\"}*&gt; )&gt;\n  FunctionSortParams.FunctionSortParamsNone = &lt;&gt;\n  FunctionSortParam.UnnamedArg = Sort\n  FunctionSortParam.NamedArg = &lt;&lt;VarId&gt; : &lt;Sort&gt;&gt;\n  FunctionSortReturn.FunctionSortReturn = &lt;: &lt;Sort&gt;&gt;\n  FunctionSortReturn.FunctionSortReturnNone = &lt;&gt;\n\n  FormalArg.Arg = &lt;&lt;VarId&gt; : &lt;Sort&gt;&gt;\n  OptFormalArgs.FormalArgs = &lt;( &lt;{FormalArg \",\"}*&gt; )&gt;\n  OptFormalArgs.OptFormalArgsNone = &lt;&gt;\n\n  OptCallArgs.CallArgs = &lt;( &lt;{Exp \",\"}*&gt; )&gt;\n  OptCallArgs.OptCallArgsNone = &lt;&gt;\n\ncontext-free sorts\n\n  Unit Section Definition EnumValue\n\nsyntax\n\n  Section-CF.Section = \"section\" SectionName-CF LAYOUT?-CF Definition*-CF\n\ncontext-free syntax\n\n  Unit.ApplicationDefs = &lt;\n    application &lt;QId&gt;\n      &lt;Definition+&gt;\n    &lt;Section*&gt;\n  &gt;\n\n  Unit.Application = &lt;\n    application &lt;QId&gt;\n    &lt;Section*&gt;\n  &gt;\n\n  Unit.ModuleDefs = &lt;\n    module &lt;ModuleName&gt;\n      &lt;Definition+&gt;\n    &lt;Section*&gt;\n  &gt;\n\n  Unit.Module = &lt;\n    module &lt;ModuleName&gt;\n    &lt;Section*&gt;\n  &gt;\n\n  Unit.BuiltInDefs = &lt;\n    built-in\n      &lt;Definition+&gt;\n    &lt;Section*&gt;\n  &gt;\n\n  Unit.BuiltIn = &lt;\n    built-in\n    &lt;Section*&gt;\n  &gt;\n\n  Unit.BuiltInLibraryDefs = &lt;\n    built-in-library\n      &lt;Definition+&gt;\n    &lt;Section*&gt;\n  &gt;\n\n  Unit.BuiltInLibrary = &lt;\n    built-in-library\n    &lt;Section*&gt;\n  &gt;\n\n  Unit.EmptyUnit = &lt;&gt;\n\n  Definition.Imports = &lt;\n    imports &lt;ImportName&gt;\n  &gt;\n\n  Definition.ImportsBuiltIn = &lt;\n    imports built-in\n  &gt;\n\n  ImportName = \"built-in\" {reject}\n\ncontext-free syntax\n\n  Definition.Description = &lt;\n    description { &lt;Word*&gt; }\n  &gt;\n  Definition.Note = &lt;\n    note { &lt;Word*&gt; }\n  &gt;\n\n  Definition.Enum = &lt;\n    enum &lt;Id&gt; {\n      &lt;{EnumValue \",\"}*&gt;\n    }\n  &gt;\n  EnumValue.EnumValue = &lt;&lt;Id&gt; ( &lt;String&gt; )&gt;\n\ncontext-free sorts\n\n  Action Statement\n\ncontext-free syntax\n\n  Definition = Action\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Core.sdf3/#modal-h2","title":"WebDSL-Core.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-DataModel.sdf3/","title":"<code>WebDSL-DataModel.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-DataModel.sdf3</p> <pre><code>module WebDSL-DataModel\n\nimports\n  WebDSL-Action\n  WebDSL-Core\n  WebDSL-Lexical\n\ncontext-free sorts\n\n  EntityBodyDeclaration\n\ncontext-free syntax\n\n  Definition.Entity = &lt;\n    entity &lt;Id&gt; : &lt;Id&gt; {\n      &lt;EntityBodyDeclaration*&gt;\n    }\n  &gt;\n  Definition.EntityNoSuper = &lt;\n    entity &lt;Id&gt; {\n      &lt;EntityBodyDeclaration*&gt;\n    }\n  &gt;\n  Definition.SessionEntity = &lt;\n    session &lt;Id&gt; {\n      &lt;EntityBodyDeclaration*&gt;\n    }\n  &gt;\n\n  Definition.ExtendEntity = &lt;\n    extend entity &lt;Id&gt; {\n      &lt;EntityBodyDeclaration*&gt;\n    }\n  &gt;\n  Definition.ExtendSessionEntity = &lt;\n    extend session &lt;Id&gt; {\n      &lt;EntityBodyDeclaration*&gt;\n    }\n  &gt;\n\ncontext-free restrictions\n\n  \"cache\" -/- [a-zA-Z0-9\\_]\n\ncontext-free syntax\n\n  Definition.GlobalVarDecl = &lt;\n    var &lt;VarId&gt; : &lt;Sort&gt;\n  &gt;\n  Definition.GlobalVarDeclDepr = &lt;\n    var &lt;VarId&gt; : &lt;Sort&gt; ;\n  &gt; {deprecated(\"remove ;\")}\n  Definition.GlobalVarDeclInit = &lt;\n    var &lt;VarId&gt; : &lt;Sort&gt; := &lt;Exp&gt;\n  &gt;\n  Definition.GlobalVarDeclInitDepr = &lt;\n    var &lt;VarId&gt; : &lt;Sort&gt; := &lt;Exp&gt; ;\n  &gt; {deprecated(\"remove ;\")}\n  Definition.GlobalVarDeclInitInferred = &lt;\n    var &lt;VarId&gt; := &lt;Exp&gt;\n  &gt;\n  Definition.GlobalVarDeclInitInferredDepr = &lt;\n    var &lt;VarId&gt; := &lt;Exp&gt; ;\n  &gt; {deprecated(\"remove ;\")}\n  Definition.RequestVarDecl = &lt;\n    request var &lt;VarId&gt; : &lt;Sort&gt;\n  &gt;\n  Definition.RequestVarDeclDepr = &lt;\n    request var &lt;VarId&gt; : &lt;Sort&gt; ;\n  &gt; {deprecated(\"remove ;\")}\n  Definition.RequestVarDeclInit = &lt;\n    request var &lt;VarId&gt; : &lt;Sort&gt; := &lt;Exp&gt;\n  &gt;\n  Definition.RequestVarDeclInitDepr = &lt;\n    request var &lt;VarId&gt; : &lt;Sort&gt; := &lt;Exp&gt; ;\n  &gt; {deprecated(\"remove ;\")}\n  Definition.RequestVarDeclInitInferred = &lt;\n    request var &lt;VarId&gt; := &lt;Exp&gt;\n  &gt;\n  Definition.RequestVarDeclInitInferredDepr = &lt;\n    request var &lt;VarId&gt; := &lt;Exp&gt; ;\n  &gt; {deprecated(\"remove ;\")}\n\ncontext-free sorts\n\n  OptPropAnnos PropKind\n\ncontext-free syntax\n\n  EntityBodyDeclaration.Property = &lt;\n    &lt;PropertyId&gt; &lt;PropKind&gt; &lt;Sort&gt; &lt;OptPropAnnos&gt;\n  &gt;\n  EntityBodyDeclaration.DerivedProperty = &lt;\n    &lt;PropertyId&gt; &lt;PropKind&gt; &lt;Sort&gt; &lt;OptPropAnnos&gt; := &lt;Exp&gt;\n  &gt;\n  EntityBodyDeclaration.CachedEntity = &lt;\n    cache\n  &gt;\n  OptPropAnnos.PropAnnos = &lt;( &lt;{Annotation \",\"}*&gt; )&gt;\n  OptPropAnnos.OptPropAnnosNone = &lt;&gt;\n  PropKind.Simple = &lt;::&gt;\n  PropKind.Ref = &lt;-\\&gt;&gt;\n  PropKind.Comp = &lt;\\&lt;\\&gt;&gt;\n  PropKind.AnyProp = &lt;:&gt;\n\ncontext-free sorts\n\n  Annotation\n\ncontext-free syntax\n\n  Annotation.SimpleAnno = AnnotationId\n  Annotation.TransientAnno = &lt;transient&gt;\n  Annotation.IdAnno = &lt;id&gt;\n  Annotation.NameAnno = &lt;name&gt;\n  Annotation.CacheAnno = &lt;cache&gt;\n  Annotation.InverseAnno = &lt;inverse = &lt;Id&gt; . &lt;Id&gt;&gt;\n  Annotation.IncompleteInverseAnno = &lt;inverse = &lt;Id&gt;&gt;\n  Annotation.InverseSlaveAnno = &lt;inverseSlave = &lt;Id&gt; . &lt;Id&gt;&gt;\n  Annotation.InverseReferenceOnlyAnno = &lt;inverse-reference-only&gt;\n  Annotation.InlineAnno = &lt;inline ( &lt;{Id \",\"}*&gt; )&gt;\n  Annotation.SelectAnno = &lt;select = &lt;Id&gt;&gt;\n  Annotation.NotNullAnno = &lt;not null&gt;\n  Annotation.NotEmptyAnno = &lt;not empty&gt;\n  Annotation.AllowedAnno = &lt;allowed = &lt;Exp&gt;&gt;\n  Annotation.DefaultAnno = &lt;default = &lt;Exp&gt;&gt;\n  Annotation.LengthAnno = &lt;length = &lt;Int&gt;&gt;\n  Annotation.FormatAnno = &lt;format = &lt;String&gt;&gt;\n  Annotation.IndexEmptyAnno = &lt;index ( )&gt;\n  Annotation.IndexAnno = &lt;index ( &lt;Int&gt; )&gt;\n  Annotation.CollationAnno = &lt;collation ( &lt;Id&gt; )&gt;\n  Annotation.IdErrorAnno = &lt;iderror = &lt;String&gt;&gt;\n  Annotation.IdEmptyErrorAnno = &lt;idemptyerror = &lt;String&gt;&gt;\n\nlexical sorts\n\n  AnnotationId\n\nlexical syntax\n\n  AnnotationId = Id\n  AnnotationId = \"searchable\" {reject}\n  AnnotationId = \"transient\" {reject}\n  AnnotationId = \"id\" {reject}\n  AnnotationId = \"name\" {reject}\n  AnnotationId = \"cache\" {reject}\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-DataModel.sdf3/#modal-h2","title":"WebDSL-DataModel.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-DataValidation.sdf3/","title":"<code>WebDSL-DataValidation.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-DataValidation.sdf3</p> <pre><code>module WebDSL-DataValidation\n\nimports\n  WebDSL-Action\n  WebDSL-Lexical\n  WebDSL-UI\n  WebDSL-DataModel\n  WebDSL-Core\n\ncontext-free syntax\n\n  Annotation.ValidateCreateAnno = &lt;validatecreate ( &lt;Exp&gt; , &lt;Exp&gt; )&gt;\n  Annotation.ValidateUpdateAnno = &lt;validateupdate ( &lt;Exp&gt; , &lt;Exp&gt; )&gt;\n  Annotation.ValidateDeleteAnno = &lt;validatedelete ( &lt;Exp&gt; , &lt;Exp&gt; )&gt;\n  Annotation.ValidateAnno = &lt;validate ( &lt;Exp&gt; , &lt;Exp&gt; )&gt;\n  Annotation.NamedValidateAnno = &lt;&lt;Id&gt; : validate ( &lt;Exp&gt; , &lt;Exp&gt; )&gt;\n\n  EntityBodyDeclaration.ValidateEntity = &lt;\n    validate ( &lt;Exp&gt; , &lt;Exp&gt; )\n  &gt;\n\n  Statement.ValidateStatement = &lt;\n    validate ( &lt;Exp&gt; , &lt;Exp&gt; ) ;\n  &gt;\n\n  Statement.NamedValidateStatement = &lt;\n    &lt;Id&gt; : validate ( &lt;Exp&gt; , &lt;Exp&gt; ) ;\n  &gt;\n\n  ThisCall = &lt;validate ( &lt;Exp&gt; , &lt;Exp&gt; )&gt; {reject}\n\n  TemplateCall.ValidationErrors = &lt;validationErrors ( &lt;Id&gt; )&gt;\n  TemplateCall.ValidationErrorsEmpty = &lt;validationErrors ( )&gt;\n\nlexical syntax\n\n  TemplateId = \"validationErrors\" {reject}\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-DataValidation.sdf3/#modal-h2","title":"WebDSL-DataValidation.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Dispatch.sdf3/","title":"<code>WebDSL-Dispatch.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Dispatch.sdf3</p> <pre><code>module WebDSL-Dispatch\n\nimports\n  WebDSL-Action\n  WebDSL-Core\n  WebDSL-Lexical\n  WebDSL-UI\n\ncontext-free sorts\n\n  DispatchEntry DispatchDefault DispatchNavigateCall DispatchNavigate DispatchNavigateButton\n\ncontext-free syntax\n\n  TemplateElement.Dispatch = &lt;\n    dispatch {\n      &lt;DispatchEntry*&gt;\n      &lt;DispatchDefault&gt;\n    }\n  &gt;\n  TemplateCall = &lt;dispatch { &lt;TemplateElement*&gt; }&gt; {reject}\n\n  DispatchEntry.DispatchEntry = &lt;\n    &lt;Id&gt; &lt;OptFormalArgs&gt; { &lt;TemplateElement*&gt; }\n  &gt;\n  DispatchEntry.DispatchEntity = &lt;\n    &lt;Id&gt; : &lt;Sort&gt; { &lt;TemplateElement*&gt; }\n  &gt;\n  DispatchDefault.DispatchDefault = &lt;\n    default { &lt;TemplateElement*&gt; }\n  &gt;\n  DispatchDefault.DispatchDefaultNone = &lt;&gt;\n  DispatchEntry = &lt;default ( &lt;{FormalArg \",\"}*&gt; ) { &lt;TemplateElement*&gt; }&gt; {reject}\n  DispatchEntry = &lt;default { &lt;TemplateElement*&gt; }&gt; {reject}\n\n  TemplateElement = DispatchNavigate\n  TemplateElement = DispatchNavigateButton\n  DispatchNavigate.DispatchNavigate = &lt;\n    navigate ( &lt;{DispatchNavigateCall \"/\"}+&gt; ) {\n      &lt;TemplateElement*&gt;\n    }\n  &gt;\n  DispatchNavigateButton.DispatchNavigateButton = &lt;\n    navigate ( &lt;Exp&gt; , &lt;{DispatchNavigateCall \"/\"}+&gt; )\n  &gt;\n  DispatchNavigateCall.DispatchNavigateCall = &lt;&lt;Id&gt; ( &lt;{Exp \",\"}*&gt; )&gt;\n  DispatchNavigateCall.DispatchNavigateCallNoArg = Id\n\n  DispatchNavigate = &lt;navigate ( &lt;DispatchNavigateCall&gt; ) { &lt;TemplateElement*&gt; }&gt; {reject}\n\nlexical syntax\n\n  TemplateId = \"navigate\" {reject}\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Dispatch.sdf3/#modal-h2","title":"WebDSL-Dispatch.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-EntityDerive.sdf3/","title":"<code>WebDSL-EntityDerive.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-EntityDerive.sdf3</p> <pre><code>module WebDSL-EntityDerive\n\nimports\n  WebDSL-Action\n  WebDSL-Core\n  WebDSL-Lexical\n  WebDSL-UI\n\ncontext-free sorts\n\n  ExpEntityDeriveProp\n\ncontext-free syntax\n\n  TemplateArgExp.ExpEntityDerive = &lt;&lt;Exp&gt; with &lt;ExpEntityDeriveProp*&gt;&gt;\n  ExpEntityDeriveProp.ExpEntityDeriveProp = &lt;&lt;DeriveArgPropId&gt; &lt;OptCallArgs&gt;&gt;\n\n  Sort.ArgEntityDerive = &lt;&lt;Id&gt; with &lt;DeriveArgPropId&gt; &lt;OptFormalArgs&gt;&gt;\n\n  TemplateElement.ForeachElementEntityDerive = &lt;\n    foreach &lt;Id&gt; {\n      &lt;TemplateElement*&gt;\n    }\n  &gt;\n  Statement.ForeachStatementEntityDerive = &lt;\n    foreach &lt;Id&gt; {\n      &lt;Statement*&gt;\n    }\n  &gt;\n\nlexical sorts\n\n  DeriveArgPropId\n\nlexical syntax\n\n  DeriveArgPropId = Id\n  DeriveArgPropId = \"filter\" {reject}\n  DeriveArgPropId = \"filters\" {reject}\n  DeriveArgPropId = \"facet\" {reject}\n  DeriveArgPropId = \"facets\" {reject}\n  DeriveArgPropId = \"tags\" {reject}\n\n  TemplateId = \"foreach\" {reject}\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-EntityDerive.sdf3/#modal-h2","title":"WebDSL-EntityDerive.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Exception.sdf3/","title":"<code>WebDSL-Exception.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Exception.sdf3</p> <pre><code>module WebDSL-Exception\n\nimports\n  WebDSL-Action\n  WebDSL-Core\n  WebDSL-Lexical\n  WebDSL-UI\n\ncontext-free sorts\n\n  Catch\n\ncontext-free syntax\n\n  Statement.ThrowStatement = &lt;\n    throw &lt;{Exp \",\"}+&gt; ;\n  &gt;\n  TemplateCall.ThrowTemplate = &lt;\n    throw &lt;{Exp \",\"}+&gt;\n  &gt;\n\n  Statement.TryStatement = &lt;\n    try &lt;Block&gt; &lt;Catch+&gt;\n  &gt;\n  TemplateCall.TryTemplate = &lt;\n    try &lt;Block&gt; &lt;Catch+&gt;\n  &gt;\n\n  Catch.Catch = &lt;catch ( &lt;VarId&gt; : &lt;Sort&gt; ) &lt;Block&gt;&gt;\n\nlexical syntax\n\n  TemplateId = \"try\" {reject}\n  TemplateId = \"throw\" {reject}\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Exception.sdf3/#modal-h2","title":"WebDSL-Exception.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Expand.sdf3/","title":"<code>WebDSL-Expand.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Expand.sdf3</p> <pre><code>module WebDSL-Expand\n\nimports\n  WebDSL-Action\n  WebDSL-Lexical\n  WebDSL-Core\n  WebDSL-UI\n  WebDSL-DataModel\n  WebDSL-Attributes\n\ncontext-free sorts\n\n  DeriveProperty DeriveBody DeriveBodyElement\n\ncontext-free syntax\n\n  TemplateElement.DeriveNoBody = &lt;\n    derive &lt;Id&gt; from &lt;Exp&gt; for ( &lt;{DeriveProperty \",\"}*&gt; )\n  &gt;\n  TemplateElement.DeriveNoForNoBody = &lt;\n    derive &lt;Id&gt; from &lt;Exp&gt;\n  &gt;\n  TemplateElement.Derive = &lt;\n    derive &lt;Id&gt; from &lt;Exp&gt; for ( &lt;{DeriveProperty \",\"}*&gt; ) &lt;DeriveBody&gt;\n  &gt;\n  TemplateElement.DeriveNoFor = &lt;\n    derive &lt;Id&gt; from &lt;Exp&gt; &lt;DeriveBody&gt;\n  &gt;\n  TemplateElement.DeriveNoFromNoFor = &lt;\n    derive &lt;Id&gt; &lt;DeriveBody&gt;\n  &gt;\n\n  DeriveProperty.DeriveDefault = Id\n  DeriveProperty.DeriveMode = &lt;&lt;Id&gt; ( &lt;Id&gt; )&gt;\n  DeriveBody.DeriveBody = &lt;{\n    &lt;DeriveBodyElement*&gt;\n  }&gt;\n  DeriveBodyElement.DeriveBodyElement = &lt;\n    &lt;Id&gt; { &lt;TemplateElement*&gt; }\n  &gt;\n\n  Definition.DeriveCrud = &lt;derive crud &lt;Id&gt;&gt; {case-insensitive}\n\ncontext-free syntax\n\n  TemplateCall = &lt;from&gt; {reject}\n\nlexical syntax\n\n  TemplateId = \"derive\" {reject}\n  TemplateId = \"for\" {reject}\n\ncontext-free priorities\n\n  TemplateElement.DeriveNoForNoBody &lt;3&gt; .&gt; Exp.ObjectCreation\n\ncontext-free syntax\n\n  Definition.ExpandTemplateCall = &lt;\n    expand &lt;ExpandId+&gt; to &lt;Id&gt;\n  &gt;\n  Definition.ExpandTemplateDefinition = &lt;\n    expandtemplate &lt;Id&gt; to &lt;ExpandArgId+&gt; {\n      &lt;Definition*&gt;\n    }\n  &gt;\n  TemplateElement.TemplateElementExpandLocal = &lt;\n    expand &lt;ExpandId+&gt; to &lt;ExpandArgId+&gt; {\n      &lt;TemplateElement*&gt;\n    }\n  &gt;\n  EntityBodyDeclaration.EntityBodyDeclarationExpandLocal = &lt;\n    expand &lt;ExpandId+&gt; to &lt;ExpandArgId+&gt; {\n      &lt;EntityBodyDeclaration*&gt;\n    }\n  &gt;\n  Statement.StatementExpandLocal = &lt;\n    expand &lt;ExpandId+&gt; to &lt;ExpandArgId+&gt; {\n      &lt;Statement*&gt;\n    }\n  &gt;\n  ObjectPropertyAssignment.ObjectPropertyAssignmentExpandLocal = &lt;\n    expand &lt;ExpandId+&gt; to &lt;ExpandArgId+&gt; {\n      &lt;ObjectPropertyAssignment*&gt;\n    }\n  &gt;\n  Definition.DefinitionExpandLocal = &lt;\n    expand &lt;ExpandId+&gt; to &lt;ExpandArgId+&gt; {\n      &lt;Definition*&gt;\n    }\n  &gt;\n  Exp.ExpExpandLocal = &lt;expand &lt;ExpandId+&gt; to &lt;ExpandArgId+&gt; { &lt;Exp&gt; }&gt;\n  Attribute.AttributeExpandLocal = &lt;expand &lt;ExpandId+&gt; to &lt;ExpandArgId+&gt; { &lt;Attribute&gt; }&gt;\n  PropertyAssignment.PropertyAssignmentExpandLocal = &lt;expand &lt;ExpandId+&gt; to &lt;ExpandArgId+&gt; { &lt;PropertyAssignment&gt; }&gt;\n  FormalArg.FormalArgExpandLocal = &lt;expand &lt;ExpandId+&gt; to &lt;ExpandArgId+&gt; { &lt;FormalArg&gt; }&gt;\n  Case.CaseAltExpandLocal = &lt;\n    expand &lt;ExpandId+&gt; to &lt;ExpandArgId+&gt; {\n      &lt;Case&gt;\n    }\n  &gt;\n  TemplateCaseAlt.TemplateCaseAltExpandLocal = &lt;\n    expand &lt;ExpandId+&gt; to &lt;ExpandArgId+&gt; {\n      &lt;TemplateCaseAlt&gt;\n    }\n  &gt;\n  TypeCaseAlt.TypeCaseAltExpandLocal = &lt;\n    expand &lt;ExpandId+&gt; to &lt;ExpandArgId+&gt; {\n      &lt;ExpandArgId&gt; &lt;Block&gt;\n    }\n  &gt;\n  TemplateTypeCaseAlt.TemplateTypeCaseAltExpandLocal = &lt;\n    expand &lt;ExpandId+&gt; to &lt;ExpandArgId+&gt; {\n      &lt;ExpandArgId&gt; { &lt;TemplateElement*&gt; }\n    }\n  &gt;\n\n\n\nlexical sorts\n\n  ExpandId ExpandArgId\n\nlexical syntax\n\n  ExpandId = [a-zA-Z0-9\\_\\-]+\n  ExpandArgId = Id\n\n  ExpandId = \"expandtemplate\" {reject}\n  ExpandId = \"template\" {reject}\n  ExpandId = \"expand\" {reject}\n  ExpandId = \"to\" {reject}\n\n  ExpandArgId = \"expandtemplate\" {reject}\n  ExpandArgId = \"template\" {reject}\n  ExpandArgId = \"expand\" {reject}\n  ExpandArgId = \"to\" {reject}\n\n  TemplateId = \"expand\" {reject}\n\nlexical restrictions\n\n  ExpandId -/- [a-zA-Z0-9\\_\\-]\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Expand.sdf3/#modal-h2","title":"WebDSL-Expand.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Generated.sdf3/","title":"<code>WebDSL-Generated.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Generated.sdf3</p> <pre><code>module WebDSL-Generated\n\nimports\n  WebDSL-Core\n  WebDSL-Lexical\n\n/*\n  Add sort and constructors for elements that can be generated durig the desugaring phase.\n  This is a workaround for the lack of string manipulation in Statix at the time of writing.\n\n  The GeneratedElement is never supposed to be the result of parsing.\n*/\n\ncontext-free sorts\n\n  GeneratedElement\n\ncontext-free syntax\n\n  GeneratedElement.Generated = &lt;&lt;Id*&gt;&gt;\n\n  Definition.GeneratedDefinition = &lt;&lt;GeneratedElement&gt;&gt;\n  EntityBodyDeclaration.GeneratedEntityBodyDeclaration = &lt;&lt;GeneratedElement&gt;&gt;\n\ncontext-free priorities\n\n  Definition.GeneratedDefinition &lt;0&gt; .&gt; GeneratedElement.Generated,\n  EntityBodyDeclaration.GeneratedEntityBodyDeclaration &lt;0&gt; .&gt; GeneratedElement.Generated\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Generated.sdf3/#modal-h2","title":"WebDSL-Generated.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-JavaScript.sdf3/","title":"<code>WebDSL-JavaScript.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-JavaScript.sdf3</p> <pre><code>module WebDSL-JavaScript\n\nimports\n  WebDSL-Action\n  WebDSL-Attributes\n  WebDSL-UI\n  WebDSL-XML\n\ncontext-free syntax\n\n  TemplateElement.JSElement = &lt;\n    \\&lt; script &lt;Attribute*&gt; \\&gt;\n      &lt;JSPart*&gt;\n    \\&lt;/ script \\&gt;\n  &gt;\n  TemplateElement.StyleElement = &lt;\n    \\&lt; style &lt;Attribute*&gt; \\&gt;\n      &lt;JSPart*&gt;\n    \\&lt;/ style \\&gt;\n  &gt;\n\ncontext-free sorts\n\n  JSPart\n\nsyntax\n\n  JSPart-CF.JSExp = \"~\" Exp-CF\n  JSPart-CF.JSString = JSString-LEX\n\nlexical sorts\n\n  JSChar JSString JSSmallerThan JSTilde\n\nlexical syntax\n\n  JSString = JSChar+\n  JSString = JSChar* \"\\\\\" {reject}\n\n  JSChar = ~[\\&lt;\\~]\n\n  JSChar = JSSmallerThan\n  JSSmallerThan = [\\&lt;]\n\n  JSChar = JSTilde\n  JSTilde = \"\\\\~\"\n\n  XMLTagName = \"script\" {reject}\n  XMLTagName = \"style\" {reject}\n\nlexical restrictions\n\n  JSSmallerThan -/- [\\/]\n  JSString -/- ~[\\&lt;\\~]\n  JSString -/- [\\&lt;] . ~[\\/]\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-JavaScript.sdf3/#modal-h2","title":"WebDSL-JavaScript.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Lexical.sdf3/","title":"<code>WebDSL-Lexical.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Lexical.sdf3</p> <pre><code>module WebDSL-Lexical\n\nlexical sorts\n\n  QId TemplateId VarId FAVarId FunId PropertyId Id PageId ExtendedId SectionName\n\nlexical syntax\n\n  QId = Id\n  QId = QId \".\" Id\n  TemplateId = Id %% hook for reject rules on templatecall names\n  VarId = Id\n  FAVarId = VarId\n  FunId = Id\n  PropertyId = Id\n  Id = [a-zA-Z] [a-zA-Z0-9\\_]*\n  PageId = [a-zA-Z] [a-zA-Z0-9\\_\\-]*\n  ExtendedId = [a-zA-Z0-9\\_\\.] [a-zA-Z0-9\\-\\_\\.]*\n  SectionName = ~[\\n\\r]*\n\ncontext-free sorts\n\n  ModuleName ModulePart ImportName OptWildcardImport\n\ncontext-free syntax\n\n  ModulePart.ModulePart = &lt;&lt;ExtendedId&gt;&gt;\n  OptWildcardImport.WildcardImport = \"/-\"\n  OptWildcardImport.NoWildcardImport = &lt;&gt;\n\nsyntax\n\n  ModuleName-CF.ModuleName = { ModulePart-CF \"/\"}+\n  ImportName-CF.ImportName = ModuleName-CF OptWildcardImport-CF\n\nlexical restrictions\n\n  Id -/- [a-zA-Z0-9\\_]\n  PageId -/- [a-zA-Z0-9\\_\\-]\n  ModuleName -/- [a-zA-Z0-9\\/]\n\nlexical sorts\n\n   Int Long Float FloatDigits ExponentPart SignedInteger\n\nlexical syntax\n\n  Int = \"-\"? [0-9]+\n  Long = \"-\"? [0-9]+ \"L\"\n  Float = \"-\"? FloatDigits ExponentPart? [fFdD]?\n  FloatDigits = [0-9]* \".\" [0-9]+\n  FloatDigits = [0-9]+\n  ExponentPart = [eE] SignedInteger\n  SignedInteger = [\\+\\-]? [0-9]+\n  Float = \"-\"? [0-9]+ {reject}\n  FloatDigits = \".\" {reject}\n\nlexical restrictions\n\n  Int -/- [0-9]\n  Int -/- [L]             // to avoid longs getting parsed as an integer followed by a template call\n  Int -/- [eEfFdD]        // to avoid floats getting parsed as an integer followed by a template call\n  Float -/- [fFdD]\n  FloatDigits -/- [0-9]\n  SignedInteger -/- [0-9]\n\ncontext-free sorts\n\n  String StringPart StringInterpExp\n\n%% Kernel syntax is required here since we do not want LAYOUT to be parsed between\n%% the first QMLex and StringLex\nsyntax\n\n  String-CF.String = \"\\\"\" StringPart-CF* \"\\\"\"\n\n  StringPart-CF.StringValue = StringLex-LEX\n  StringPart-CF.InterpValue = \"~\" StringInterpExp-CF\n\n  StringInterpExp-CF.InterpSimpleExp = SimpleExp-CF\n\ncontext-free restrictions\n\n  StringInterpExp -/- [\\.\\(]\n\ncontext-free sorts\n\n  OutputShorthand\n\ncontext-free syntax\n%% ~SimpleExp and ~(Exp) shorthand for output template call\n\n  OutputShorthand.OutputShorthandSimpleExp = \"~\" SimpleExp\n\ncontext-free sorts\n\n  SimpleExp\n\ncontext-free syntax\n%% SimpleExp: specific commonly occuring expressions allowed directly after '~' inside string\n%% allowing all expressions directly after '~' causes too many ambiguities\n%% parentheses expression is used as delimiter for inserting any expression\n%% allowed after '~': var/fieldaccess/thiscall/call/brackets a, a.b, a(), a.b(), (exp)\n%% a '.' after a SimpleExp must be rejected as part of String to avoid amb, e.g. not allowed: \"~a.\"\n%% in these cases, use '()' if a '.' is needed as part of the string,       e.g.     allowed: \"~(a).\"\n\n  SimpleExp.SimpleVar = Id\n  SimpleExp.SimpleFieldAccess = &lt;&lt;SimpleExp&gt; . &lt;PropertyId&gt;&gt;\n\nlexical sorts\n\n  QMLex StringLex StringChar HexPart\n\nlexical syntax\n\n  QMLex = \"\\\"\"\n  StringLex = StringChar+\n  StringChar = ~[\\\"\\n\\~\\\\]\n  StringChar = \"\\\\\" [0-9btnfr\\'\\\"\\\\\\~]\n  HexPart = [0-9a-fA-F]\n  StringChar = \"\\\\u\" HexPart HexPart HexPart HexPart\n\nlexical restrictions\n\n  StringLex -/- ~[\\\"\\n\\~]\n\nlexical sorts\n\n  InsideComment CommentChar NewLineEOF EOF\n\nlexical syntax\n  LAYOUT     = [\\ \\t\\n\\r]\n  LAYOUT     = \"//\" ~[\\n\\r]* NewLineEOF\n  LAYOUT     = \"/*\" InsideComment* \"*/\"\n  InsideComment  = ~[\\*]\n  InsideComment  = CommentChar\n  CommentChar    = [\\*]\n  NewLineEOF = [\\n\\r]\n  NewLineEOF = EOF\n  EOF        =\n\nlexical restrictions\n  CommentChar -/- [\\/]\n  EOF         -/- ~[]\n\ncontext-free restrictions\n\n  LAYOUT? -/- [\\ \\t\\n\\r]\n  LAYOUT? -/- [\\/].[\\/]\n  LAYOUT? -/- [\\/].[\\*]\n  SectionName -/- ~[\\n\\r]\n\nlexical sorts\n\n  Word\n\nlexical syntax\n\n  Word = ~[\\ \\t\\n\\r\\}]+\n\nlexical restrictions\n\n  Word -/- ~[\\ \\t\\n\\r\\}]\n\nlexical sorts\n\n  SimpleSortLex GenericSortLex\n\nlexical syntax\n\n  SimpleSortLex = [A-Z] [a-zA-Z0-9\\_]*\n  GenericSortLex = Id\n  GenericSortLex = \"Ref\" {reject}\n\nlexical restrictions\n\n  SimpleSortLex -/- [a-zA-Z0-9\\_]\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Lexical.sdf3/#modal-h2","title":"WebDSL-Lexical.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Native.sdf3/","title":"<code>WebDSL-Native.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Native.sdf3</p> <pre><code>module WebDSL-Native\n\nimports\n  WebDSL-Core\n  WebDSL-Lexical\n\ncontext-free sorts\n\n  NCAlias NCSuper\n\ncontext-free syntax\n\n  Definition.NativeClass = &lt;\n    native class &lt;QId&gt; &lt;NCAlias&gt; &lt;NCSuper&gt; {\n      &lt;NCElement*&gt;\n    }\n  &gt;\n\n  Definition.ExtendNativeClass = &lt;\n    extend native class &lt;QId&gt; &lt;NCAlias&gt; {\n      &lt;NCElement*&gt;\n    }\n  &gt;\n\n  NCAlias.NCAlias = &lt;as &lt;Id&gt;&gt;\n  NCAlias.NCAliasNone = &lt;&gt;\n  NCSuper.NCSuper = &lt;: &lt;Id&gt;&gt;\n  NCSuper.NCSuperNone = &lt;&gt;\n\ncontext-free sorts\n\n  NCElement NativeType NCFunction NCFunctionReturn\n  NCFunctionStatic NCFunctionFromStatic\n\ncontext-free syntax\n\n  NCElement.NCProperty = &lt;\n    &lt;Id&gt; : &lt;NativeType&gt;\n  &gt;\n  NCElement.NCFunctionElement = NCFunction\n  NCFunction.NCFunction = &lt;\n    &lt;NCFunctionStatic&gt; &lt;NativeFunId&gt; ( &lt;{NativeType \",\"}*&gt; ) &lt;NCFunctionReturn&gt;\n  &gt;\n  NCFunctionReturn.NCFunctionReturn = &lt;: &lt;NativeType&gt;&gt;\n  NCFunctionReturn.NCFunctionReturnNone = &lt;&gt;\n  NCFunctionStatic.NCFunctionStatic = &lt;static&gt;\n  NCFunctionStatic.NCFunctionStaticNone = &lt;&gt;\n  NCFunctionFromStatic.NCFunctionFromStatic = &lt;\n    &lt;QId&gt; as &lt;NCFunction&gt;\n  &gt;\n  NCElement.NCFunctionFromStaticElement = NCFunctionFromStatic\n  NCElement.NCConstructor = &lt;\n    constructor ( &lt;{NativeType \",\"}*&gt; )\n  &gt;\n  NCElement.NCConstructorFromStatic = &lt;\n    &lt;QId&gt; as constructor ( &lt;{NativeType \",\"}*&gt; )\n  &gt;\n  NativeType.NativeGenericType = &lt;&lt;Id&gt; \\&lt; &lt;{NativeType \",\"}*&gt; \\&gt;&gt;\n  NativeType.NativeGenericTypeList = &lt;[ &lt;{NativeType \",\"}*&gt; ]&gt;\n  NativeType.NativeGenericTypeSet = &lt;{ &lt;{NativeType \",\"}*&gt; }&gt;\n  NativeType.NativeSimpleType = Id\n\n  NCElement = &lt;constructor ( &lt;{NativeType \",\"}*&gt; ) &lt;NCFunctionReturn&gt;&gt; {reject}\n\nlexical sorts\n\n  NativeFunId\n\nlexical syntax\n\n  NativeFunId = Id\n  NativeFunId = \"constructor\" {reject}\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Native.sdf3/#modal-h2","title":"WebDSL-Native.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Prefetch.sdf3/","title":"<code>WebDSL-Prefetch.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Prefetch.sdf3</p> <pre><code>module WebDSL-Prefetch\n\nimports\n  WebDSL-Action\n  WebDSL-Core\n  WebDSL-Lexical\n  WebDSL-UI\n\ncontext-free sorts\n\n  PrefetchChildren PrefetchNode PrefetchTemplateArgsOpt PrefetchNodeMod PrefetchCondition PrefetchCondVal PrefetchCond PrefetchWhereOpt PrefetchWhereMod\n  OptSimpleSort PrefetchChildrenOpt OptPrefetchOwnerCast SortOrThis TemplateArgOrThis\n\ncontext-free syntax\n\n  TemplateElement.PrefetchFor = &lt;\n    prefetch-for &lt;Id&gt; &lt;PrefetchTemplateArgsOpt&gt; &lt;PrefetchWhereOpt&gt; &lt;PrefetchChildren&gt;\n  &gt;\n  Statement.PrefetchForStmt = &lt;\n    prefetch-for &lt;Id&gt; &lt;PrefetchTemplateArgsOpt&gt; &lt;PrefetchWhereOpt&gt; &lt;PrefetchChildren&gt;\n  &gt;\n\n  PrefetchChildren.PrefetchChildren = &lt;{\n    &lt;PrefetchNode*&gt;\n  }&gt;\n  PrefetchChildrenOpt.PrefetchChildrenOptNone = &lt;&gt;\n  PrefetchChildrenOpt = PrefetchChildren\n\n  PrefetchNode.PrefetchNode = &lt;&lt;OptPrefetchOwnerCast&gt; &lt;Id&gt; &lt;PrefetchNodeMod*&gt; &lt;PrefetchTemplateArgsOpt&gt; &lt;PrefetchCondition&gt; &lt;PrefetchWhereOpt&gt; &lt;PrefetchChildrenOpt&gt;&gt;\n  OptPrefetchOwnerCast.OptPrefetchOwnerCastNone = &lt;&gt;\n  OptPrefetchOwnerCast.PrefetchOwnerCast = &lt;&lt;SimpleSortLex&gt; .&gt;\n  PrefetchNodeMod.NoEmptyBatch = &lt;no-empty-batch&gt;\n  PrefetchNodeMod.FetchEarly = &lt;fetch-early&gt;\n\n  PrefetchTemplateArgsOpt.PrefetchTemplateArgsOptNone = &lt;&gt;\n  PrefetchTemplateArgsOpt.PrefetchTemplateArgs = &lt;templates [ &lt;{TemplateArgOrThis \",\"}+&gt; ]&gt;\n  TemplateArgOrThis.TemplateArgOrThis = &lt;&lt;Id&gt; ( &lt;{SortOrThis \",\"}*&gt; )&gt;\n  SortOrThis.Sort = Sort\n  SortOrThis.TArgThis = &lt;this&gt;\n  SortOrThis.PrefetchThisCast = &lt;this as &lt;Sort&gt;&gt;\n\ncontext-free syntax\n\n  PrefetchCondition.PrefetchConditionNone = &lt;&gt;\n  PrefetchCondition.PrefetchCondition = &lt;if ( &lt;PrefetchCond&gt; )&gt;\n  PrefetchWhereOpt.PrefetchWhereOptNone = &lt;&gt;\n  PrefetchWhereOpt.PrefetchWhere = &lt;where &lt;PrefetchWhereMod*&gt; ( &lt;PrefetchCond&gt; )&gt;\n  PrefetchWhereMod.Hint = &lt;hint&gt;\n  PrefetchCond.PrefetchEq                 = &lt;&lt;PrefetchCondVal&gt; == &lt;PrefetchCondVal&gt;&gt; {left}\n  PrefetchCond.PrefetchNotEq              = &lt;&lt;PrefetchCondVal&gt; != &lt;PrefetchCondVal&gt;&gt; {left}\n  PrefetchCond.PrefetchLargerThan         = &lt;&lt;PrefetchCondVal&gt; \\&gt; &lt;PrefetchCondVal&gt;&gt; {left}\n  PrefetchCond.PrefetchLargerThanOrEqual  = &lt;&lt;PrefetchCondVal&gt; \\&gt;= &lt;PrefetchCondVal&gt;&gt; {left}\n  PrefetchCond.PrefetchSmallerThan        = &lt;&lt;PrefetchCondVal&gt; \\&lt; &lt;PrefetchCondVal&gt;&gt; {left}\n  PrefetchCond.PrefetchSmallerThanOrEqual = &lt;&lt;PrefetchCondVal&gt; \\&lt;= &lt;PrefetchCondVal&gt;&gt; {left}\n  PrefetchCond.PrefetchAnd                = &lt;&lt;PrefetchCond&gt; &amp;&amp; &lt;PrefetchCond&gt;&gt; {left}\n  PrefetchCond.PrefetchOr                 = &lt;&lt;PrefetchCond&gt; || &lt;PrefetchCond&gt;&gt; {left}\n  PrefetchCond.PrefetchNot                = &lt;! &lt;PrefetchCond&gt;&gt;\n  PrefetchCond = PrefetchCondVal\n  PrefetchCond = &lt;( &lt;PrefetchCond&gt; )&gt; {bracket}\n\n  PrefetchCondVal.PrefetchTrue = &lt;true&gt;\n  PrefetchCondVal.PrefetchFalse = &lt;false&gt;\n  PrefetchCondVal.PrefetchNull = &lt;null&gt;\n  PrefetchCondVal.PrefetchConst = ConstValue\n  PrefetchCondVal.PrefetchCondVar = VarId\n  PrefetchCondVal.RelativeFieldAccess = &lt;&lt;OptSimpleSort&gt; . &lt;PropertyId&gt;&gt; {left}\n  PrefetchCondVal.PrefetchMul = &lt;&lt;PrefetchCondVal&gt; * &lt;PrefetchCondVal&gt;&gt; {left}\n  PrefetchCondVal.PrefetchDiv = &lt;&lt;PrefetchCondVal&gt; / &lt;PrefetchCondVal&gt;&gt; {left}\n  PrefetchCondVal.PrefetchMod = &lt;&lt;PrefetchCondVal&gt; % &lt;PrefetchCondVal&gt;&gt; {left}\n  PrefetchCondVal.PrefetchAdd = &lt;&lt;PrefetchCondVal&gt; + &lt;PrefetchCondVal&gt;&gt; {left}\n  PrefetchCondVal.PrefetchSub = &lt;&lt;PrefetchCondVal&gt; - &lt;PrefetchCondVal&gt;&gt; {left}\n\n  OptSimpleSort.OptSimpleSortNone = &lt;&gt;\n  OptSimpleSort.OptSimpleSortSome = SimpleSortLex\n\ncontext-free priorities\n\n  {left :\n    PrefetchCondVal.RelativeFieldAccess\n  } &gt;\n  {\n    PrefetchCond.PrefetchNot\n  } &gt;\n  {left :\n    PrefetchCondVal.PrefetchMul\n    PrefetchCondVal.PrefetchDiv\n    PrefetchCondVal.PrefetchMod\n  } &gt;\n  {left:\n    PrefetchCondVal.PrefetchAdd\n    PrefetchCondVal.PrefetchSub\n  } &gt;\n  {left :\n    PrefetchCond.PrefetchEq\n    PrefetchCond.PrefetchNotEq\n    PrefetchCond.PrefetchLargerThan\n    PrefetchCond.PrefetchLargerThanOrEqual\n    PrefetchCond.PrefetchSmallerThan\n    PrefetchCond.PrefetchSmallerThanOrEqual\n  } &gt;\n  {left : PrefetchCond.PrefetchAnd } &gt;\n  {left : PrefetchCond.PrefetchOr }\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Prefetch.sdf3/#modal-h2","title":"WebDSL-Prefetch.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Regex.sdf3/","title":"<code>WebDSL-Regex.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Regex.sdf3</p> <pre><code>module WebDSL-Regex\n\nimports\n  WebDSL-Action\n  WebDSL-Lexical\n  WebDSL-DataModel\n\ncontext-free sorts\n\n  Pattern RegexExp\n\ncontext-free syntax\n\n  Exp.RegexCall = &lt;&lt;RegexExp&gt; . &lt;Id&gt; ( &lt;{Exp \",\"}*&gt; )&gt;\n  RegexExp.RegexPattern = &lt;/ &lt;Pattern&gt; /&gt;\n  Pattern.SingleBranch = Branche\n  Pattern.TupleBranch = &lt;&lt;Pattern&gt; | &lt;Pattern&gt;&gt; {right}\n\ncontext-free sorts\n\n  Branche Piece\n\ncontext-free syntax\n\n  Branche.Pieces = &lt;&lt;Piece+&gt;&gt;\n  Piece.SingleAtom = Atom\n  Piece.QuantifiedAtom = &lt;&lt;Atom&gt; &lt;Quantifier&gt;&gt;\n\ncontext-free sorts\n\n  Quantifier\n\ncontext-free syntax\n\n  Quantifier.GreedyExactBound = &lt;{ &lt;Integer&gt; }&gt;\n  Quantifier.GreedyLowerBound = &lt;{ &lt;Integer&gt; , }&gt;\n  Quantifier.GreedyLowerUpperBound = &lt;{ &lt;Integer&gt; , &lt;Integer&gt; }&gt;\n  Quantifier.GreedyOnceOrNot = &lt;?&gt;\n  Quantifier.GreedyZeroOrMore = &lt;*&gt;\n  Quantifier.GreedyOneOrMore = &lt;+&gt;\n  Quantifier.ReluctantExactBound = &lt;{ &lt;Integer&gt; }?&gt;\n  Quantifier.ReluctantLowerBound = &lt;{ &lt;Integer&gt; , }?&gt;\n  Quantifier.ReluctantLowerUpperBound = &lt;{ &lt;Integer&gt; , &lt;Integer&gt; }?&gt;\n  Quantifier.ReluctantOnceOrNot = &lt;??&gt;\n  Quantifier.ReluctantZeroOrMore = &lt;*?&gt;\n  Quantifier.ReluctantOneOrMore = &lt;+?&gt;\n  Quantifier.PossessiveExactBound = &lt;{ &lt;Integer&gt; }+&gt;\n  Quantifier.PossessiveLowerBound = &lt;{ &lt;Integer&gt; , }+&gt;\n  Quantifier.PossessiveLowerUpperBound = &lt;{ &lt;Integer&gt; , &lt;Integer&gt; }+&gt;\n  Quantifier.PossessiveOnceOrNot = &lt;?+&gt;\n  Quantifier.PossessiveZeroOrMore = &lt;*+&gt;\n  Quantifier.PossessiveOneOrMore = &lt;++&gt;\n\ncontext-free sorts\n\n  Atom\n\ncontext-free syntax\n\n  Atom.Capture = &lt;( &lt;Pattern&gt; )&gt;\n  Atom.NonCapture = &lt;(?: &lt;Pattern&gt; )&gt;\n  Atom.PositiveLookahead = &lt;(?= &lt;Pattern&gt; )&gt;\n  Atom.NegativeLookahead = &lt;(?! &lt;Pattern&gt; )&gt;\n  Atom.PositiveLookbehind = &lt;(?\\&lt;= &lt;Pattern&gt; )&gt;\n  Atom.NegativeLookbehind = &lt;(?\\&lt;! &lt;Pattern&gt; )&gt;\n  Atom.PythonCapture = &lt;(?P\\&lt; &lt;RegexId&gt; \\&gt; &lt;Pattern&gt; )&gt;\n  Atom.RegexCapture = &lt;( &lt;Pattern&gt; )@{ &lt;RegexId&gt; }&gt;\n  Atom.Empty = &lt;()&gt;\n  Atom.SingleCharacter = &lt;.&gt;\n  Atom.LineStart = &lt;^&gt;\n  Atom.LineEnd = &lt;$&gt;\n  Atom.CharacterClass = CharacterClass\n  Atom.AtomLiteral = AtomLiteral\n  Atom.AtomCharacter = AtomCharacter\n  Atom.QuotedAtom = &lt;\\\\Q &lt;AllChars&gt; \\\\E&gt;\n\ncontext-free sorts\n\n  CharacterClass BracketItem BracketLiteralOrBracketCharacter\n\ncontext-free syntax\n\n  CharacterClass.BracketList = &lt;[ &lt;BracketItem+&gt; ]&gt;\n  CharacterClass.NegatedBracketList = &lt;[^ &lt;BracketItem+&gt; ]&gt;\n  BracketItem.Range = &lt;&lt;BracketLiteralOrBracketCharacter&gt; - &lt;BracketLiteralOrBracketCharacter&gt;&gt;\n  BracketLiteralOrBracketCharacter = BracketLiteral\n  BracketLiteralOrBracketCharacter = BracketCharacter\n  BracketItem.Union = CharacterClass\n  BracketItem.BracketLiteral = BracketLiteral\n  BracketItem.BracketCharacter = BracketCharacter\n\ncontext-free sorts\n\n  ClassKeyword\n\ncontext-free syntax\n\n  ClassKeyword.LowerClass = &lt;Lower&gt;\n  ClassKeyword.UpperClass = &lt;Upper&gt;\n  ClassKeyword.ASCIIClass = &lt;ASCII&gt;\n  ClassKeyword.AlphaClass = &lt;Alpha&gt;\n  ClassKeyword.DigitClass = &lt;Digit&gt;\n  ClassKeyword.AlnumClass = &lt;Alnum&gt;\n  ClassKeyword.PunctClass = &lt;Punct&gt;\n  ClassKeyword.GraphClass = &lt;Graph&gt;\n  ClassKeyword.PrintClass = &lt;Print&gt;\n  ClassKeyword.BlankClass = &lt;Blank&gt;\n  ClassKeyword.CntrlClass = &lt;Cntrl&gt;\n  ClassKeyword.XDigitClass = &lt;XDigit&gt;\n  ClassKeyword.WhiteSpace = &lt;Space&gt;\n  ClassKeyword.JavaIsLowerCase = &lt;javaLowerCase&gt;\n  ClassKeyword.JavaIsUpperCase = &lt;javaUpperCase&gt;\n  ClassKeyword.JavaIsWhitespace = &lt;javaWhitespace&gt;\n  ClassKeyword.JavaIsMirrored = &lt;javaMirrored&gt;\n  ClassKeyword.GreekBlock = &lt;InGreek&gt;\n  ClassKeyword.UppercaseLetter = &lt;Lu&gt;\n  ClassKeyword.CurrencySymbol = &lt;Sc&gt;\n\nlexical sorts\n\n  BracketLiteral AtomLiteral AllChars\n\nlexical syntax\n\n  BracketLiteral = [a-zA-Z0-9\\!\\#\\%\\'\\,\\:\\;\\&lt;\\=\\&gt;\\@\\_\\`\\~\\$\\*\\+\\?\\.\\}\\|]\n  BracketLiteral = \"/\"\n  BracketLiteral = [\\&amp;\\]\\-] {reject}\n  AtomLiteral = [a-zA-Z0-9\\!\\#\\%\\'\\,\\:\\;\\&lt;\\=\\&gt;\\@\\_\\`\\~\\&amp;\\]\\-]\n  AtomLiteral = \"/\"\n  AtomLiteral = [\\}\\)\\|\\[] {reject}\n  AllChars = [\\\\\\|\\$\\*\\+\\?\\.\\{\\}\\(\\)\\&amp;\\]\\-\\[\\^\\!\\#\\%\\'\\,\\:\\;\\&lt;\\=\\&gt;\\@\\_\\`\\~a-zA-Z0-9\\t\\n\\r]*\n  AllChars = \"/\"\n  AllChars = DoubleQuote\n\ncontext-free sorts\n\n  BracketCharacter AtomCharacter DoubleQuote OctalChar HexHexChar DecHexChar Tab Newline ReturnAtom Formfeed Alarm Escape\n  WordChar NonWordChar WhiteSpaceChar DigitChar NonDigitChar ControlCharacter WordBoundry NonWordBoundry InputBeginBoundry\n  PrevMatchEndBoundry EndInputBoundry EndInputFinalBoundry Space NonWhiteSpaceChar BackReference\n\ncontext-free syntax\n\n  DoubleQuote.DoubleQuote = &lt;\"&gt;\n  OctalChar.OctalChar = &lt;\\\\0 &lt;OctalValue&gt;&gt;\n  HexHexChar.HexHexChar = &lt;\\\\x &lt;TwoHexValue&gt;&gt;\n  DecHexChar.DecHexChar = &lt;\\\\u &lt;FourHexValue&gt;&gt;\n  Tab.Tab = &lt;\\\\t&gt;\n  Newline.Newline = &lt;\\\\n&gt;\n  ReturnAtom.ReturnAtom = &lt;\\\\r&gt;\n  Formfeed.Formfeed = &lt;\\\\f&gt;\n  Alarm.Alarm = &lt;\\\\a&gt;\n  Escape.Escape = &lt;\\\\e&gt;\n  WordChar.WordChar = &lt;\\\\w&gt;\n  NonWordChar.NonWordChar = &lt;\\\\W&gt;\n  WhiteSpaceChar.WhiteSpaceChar = &lt;\\\\s&gt;\n  NonWhiteSpaceChar.NonWhiteSpaceChar = &lt;\\\\S&gt;\n  DigitChar.DigitChar = &lt;\\\\d&gt;\n  NonDigitChar.NonDigitChar = &lt;\\\\D&gt;\n  ControlCharacter.ControlCharacter = &lt;\\\\c &lt;ControlValue&gt;&gt;\n  WordBoundry.WordBoundry = &lt;\\\\b&gt;\n  NonWordBoundry.NonWordBoundry = &lt;\\\\B&gt;\n  InputBeginBoundry.InputBeginBoundry = &lt;\\\\A&gt;\n  PrevMatchEndBoundry.PrevMatchEndBoundry = &lt;\\\\G&gt;\n  EndInputBoundry.EndInputBoundry = &lt;\\\\Z&gt;\n  EndInputFinalBoundry.EndInputFinalBoundry = &lt;\\\\z&gt;\n  BackReference.BackReference = &lt;\\\\ &lt;BackReferenceLex&gt;&gt;\n  Space.Space = \"\\\\ \"\n  BracketCharacter = DoubleQuote\n  BracketCharacter = OctalChar\n  BracketCharacter = HexHexChar\n  BracketCharacter = DecHexChar\n  BracketCharacter = Tab\n  BracketCharacter = Newline\n  BracketCharacter = ReturnAtom\n  BracketCharacter = Formfeed\n  BracketCharacter = Alarm\n  BracketCharacter = Escape\n  BracketCharacter = WordChar\n  BracketCharacter = NonWordChar\n  BracketCharacter = WhiteSpaceChar\n  BracketCharacter = NonWhiteSpaceChar\n  BracketCharacter = DigitChar\n  BracketCharacter = NonDigitChar\n  BracketCharacter = ControlCharacter\n  BracketCharacter = WordBoundry\n  BracketCharacter = NonWordBoundry\n  BracketCharacter = InputBeginBoundry\n  BracketCharacter = PrevMatchEndBoundry\n  BracketCharacter = EndInputBoundry\n  BracketCharacter = EndInputFinalBoundry\n  BracketCharacter = BackReference\n  BracketCharacter = Space\n  AtomCharacter = DoubleQuote\n  AtomCharacter = OctalChar\n  AtomCharacter = HexHexChar\n  AtomCharacter = DecHexChar\n  AtomCharacter = Tab\n  AtomCharacter = Newline\n  AtomCharacter = ReturnAtom\n  AtomCharacter = Formfeed\n  AtomCharacter = Alarm\n  AtomCharacter = Escape\n  AtomCharacter = WordChar\n  AtomCharacter = NonWordChar\n  AtomCharacter = WhiteSpaceChar\n  AtomCharacter = NonWhiteSpaceChar\n  AtomCharacter = DigitChar\n  AtomCharacter = NonDigitChar\n  AtomCharacter = ControlCharacter\n  AtomCharacter = WordBoundry\n  AtomCharacter = NonWordBoundry\n  AtomCharacter = InputBeginBoundry\n  AtomCharacter = PrevMatchEndBoundry\n  AtomCharacter = EndInputBoundry\n  AtomCharacter = EndInputFinalBoundry\n  AtomCharacter = BackReference\n  AtomCharacter = Space\n\ncontext-free sorts\n\n  QuotablePatternSymbol Quoted\n\ncontext-free syntax\n\n  Quoted.Quoted = &lt;\\\\ &lt;QuotablePatternSymbol&gt;&gt;\n  AtomCharacter = Quoted\n  BracketCharacter = Quoted\n\nlexical sorts\n\n  QuotablePatternSymbolLex\n\nlexical syntax\n\n  QuotablePatternSymbolLex = [\\|\\$\\*\\+\\?\\.\\{\\}\\(\\)\\&amp;\\]\\[\\-\\^\\\\\\!\\#\\%\\'\\,\\:\\;\\&lt;\\=\\&gt;\\@\\_\\`\\~\\/]\n\ncontext-free syntax\n\n  QuotablePatternSymbol.QuotablePatternSymbol = QuotablePatternSymbolLex\n  QuotablePatternSymbol = DoubleQuote\n\nlexical sorts\n\n  Integer OctalValue TwoHexValue FourHexValue BackReferenceLex ControlValue\n\nlexical syntax\n\n  Integer = [0-9]+\n  BackReferenceLex = [1-9] [0-9]*\n  OctalValue = [0-7]\n  OctalValue = [0-7] [0-7]\n  OctalValue = [0-3] [0-7] [0-7]\n  TwoHexValue = [0-9A-Fa-f] [0-9A-Fa-f]\n  FourHexValue = [0-9A-Fa-f] [0-9A-Fa-f] [0-9A-Fa-f] [0-9A-Fa-f]\n  ControlValue = [0-9]\n  ControlValue = [0-9] [0-9]\n\ncontext-free sorts\n\n  RegexId\n\ncontext-free syntax\n\n  RegexId.RegexId = RegexID\n\nlexical sorts\n\n  RegexID\n\nlexical syntax\n\n  RegexID = [A-Za-z\\_\\$] [A-Za-z0-9\\_\\$]*\n  RegexID = \"true\" {reject}\n  RegexID = \"false\" {reject}\n  RegexID = \"null\" {reject}\n\nlexical restrictions\n\n  RegexID -/- [a-zA-Z0-9\\_\\$]\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Regex.sdf3/#modal-h2","title":"WebDSL-Regex.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Routing.sdf3/","title":"<code>WebDSL-Routing.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Routing.sdf3</p> <pre><code>module WebDSL-Routing\n\nimports\n  WebDSL-Core\n  WebDSL-Action\n\ncontext-free sorts\n\n  RoutingElement\n\ncontext-free syntax\n\n  Definition.Routing = &lt;\n    routing {\n      &lt;RoutingElement*&gt;\n    }\n  &gt;\n  RoutingElement.RoutingReceive = &lt;\n    receive &lt;OptFormalArgs&gt; &lt;Block&gt;\n  &gt;\n  RoutingElement.RoutingConstruct = &lt;\n    construct &lt;OptFormalArgs&gt; &lt;Block&gt;\n  &gt;\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Routing.sdf3/#modal-h2","title":"WebDSL-Routing.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Search.sdf3/","title":"<code>WebDSL-Search.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Search.sdf3</p> <pre><code>module WebDSL-Search\n\nimports\n  WebDSL-Action\n  WebDSL-Core\n  WebDSL-Lexical\n  WebDSL-DataModel\n\nlexical sorts\n\n  SA-Value SearcherKW SearchFieldId SEARCHERREF\n\ncontext-free sorts\n\n  FullTextAnalyzerBody FullTextAnalyzerBodyDef CharFilter Tokenizer\n  TokenFilter AnalyzerArgument OptDefaultAnalyzer OptAnalyzerArguments\n\ncontext-free syntax\n\n  Definition.FullTextAnalyzer = &lt;\n    &lt;OptDefaultAnalyzer&gt; analyzer &lt;Id&gt; {\n      &lt;FullTextAnalyzerBody&gt;\n    }\n  &gt;\n\n  OptDefaultAnalyzer.NonDefaultAnalyzer     = &lt;&gt;\n  OptDefaultAnalyzer.DefaultAnalyzer        = &lt;default&gt;\n  OptDefaultAnalyzer.DefaultBuiltInAnalyzer = &lt;default_builtin_analyzer&gt;\n\n  FullTextAnalyzerBody.FullTextAnalyzerBody = &lt;\n    &lt;FullTextAnalyzerBodyDef&gt;\n  &gt;\n  FullTextAnalyzerBody.DualFullTextAnalyzerBody = &lt;\n    index {\n      &lt;FullTextAnalyzerBodyDef&gt;\n    }\n    query {\n      &lt;FullTextAnalyzerBodyDef&gt;\n    }&gt;\n\n  FullTextAnalyzerBodyDef.FullTextAnalyzerBodyDef = &lt;\n    &lt;CharFilter*&gt;\n    &lt;Tokenizer&gt;\n    &lt;TokenFilter*&gt;\n  &gt;\n\n  CharFilter.CharFilter = &lt;\n    char filter = &lt;Id&gt; &lt;OptAnalyzerArguments&gt;\n  &gt;\n  Tokenizer.Tokenizer = &lt;\n    tokenizer = &lt;Id&gt; &lt;OptAnalyzerArguments&gt;\n  &gt;\n  TokenFilter.TokenFilter = &lt;\n    token filter = &lt;Id&gt; &lt;OptAnalyzerArguments&gt;\n  &gt;\n\n  OptAnalyzerArguments.OptAnalyzerArgumentsNone = &lt;&gt;\n  OptAnalyzerArguments.AnalyzerArguments = &lt;( &lt;{AnalyzerArgument \",\"}*&gt; )&gt;\n\n  AnalyzerArgument.AnalyzerArgument = &lt;&lt;Id&gt; = &lt;String&gt;&gt;\n\ncontext-free sorts\n\n  SearchableAnno SearchNamespaceAnno SA-Argument OptSAArguments SA-Key\n\ncontext-free syntax\n\n  SearchableAnno.SearchableAnno = &lt;searchable &lt;OptSAArguments&gt;&gt;\n  SearchNamespaceAnno.SearchNamespaceAnno = &lt;search namespace&gt;\n  Annotation.SearchableAnnoBoost = &lt;&lt;SearchableAnno&gt; ^ &lt;Float&gt;&gt;\n  Annotation = SearchableAnno\n  Annotation = SearchNamespaceAnno\n\n  OptSAArguments.OptSAArgumentsNone = &lt;&gt;\n  OptSAArguments.OptSAArguments = &lt;( &lt;{SA-Argument \",\"}*&gt; )&gt;\n\n  SA-Argument.SA-Argument           = &lt;&lt;SA-Key&gt; = &lt;SA-Value&gt;&gt;\n  SA-Argument.Autocomplete-Argument = &lt;autocomplete&gt;\n  SA-Argument.Spellcheck-Argument   = &lt;spellcheck&gt;\n  SA-Argument.Numeric-Argument      = &lt;numeric&gt;\n  SA-Argument.DefaultSF-Argument    = &lt;default&gt;\n\n  SA-Key.SAKeyAnalyzer  = &lt;analyzer&gt;\n  SA-Key.SAKeyName      = &lt;name&gt;\n  SA-Key.SAKeyBoost     = &lt;boost&gt;\n  SA-Key.SAKeySubclass  = &lt;subclass&gt;\n  SA-Key.SAKeyDepth     = &lt;depth&gt;\n\ncontext-free sorts\n\n  SearchMappingContent MappingPart OptDefaultSearchField SearchMappingAnnoPart\n\ncontext-free syntax\n\n  Definition.SearchMapping = &lt;\n    search mapping &lt;Id&gt; {\n      &lt;SearchMappingContent*&gt;\n    }\n  &gt;\n\n  EntityBodyDeclaration.SearchMappingEmbedded = &lt;\n    search mapping {\n      &lt;SearchMappingContent*&gt;\n    }\n  &gt;\n\n  SearchMappingContent.SearchNamespaceMapping = &lt;\n    namespace by &lt;Id&gt;\n  &gt;\n  SearchMappingContent.SearchNamespaceMappingAlt = &lt;\n    namespace by &lt;Id&gt; ;\n  &gt;\n  SearchMappingContent.SearchFieldMapping = &lt;\n    &lt;OptDefaultSearchField&gt; &lt;SearchMappingId&gt; &lt;MappingPart*&gt;\n  &gt;\n  SearchMappingContent.SearchFieldMappingAlt = &lt;\n    &lt;OptDefaultSearchField&gt; &lt;SearchMappingId&gt; &lt;MappingPart*&gt; ;\n  &gt;\n  SearchMappingContent.SearchFieldMappingIndex = &lt;\n    &lt;OptDefaultSearchField&gt; index &lt;Id&gt; &lt;MappingPart*&gt;\n  &gt;\n  SearchMappingContent.SearchFieldMappingIndexAlt = &lt;\n    &lt;OptDefaultSearchField&gt; index &lt;Id&gt; &lt;MappingPart*&gt; ;\n  &gt;\n\n  MappingPart.FieldName         = &lt;as &lt;Id&gt;&gt;\n  MappingPart.AnalyzerName      = &lt;using &lt;Id&gt;&gt;\n  MappingPart.BoostAlt          = &lt;boosted to &lt;Float&gt;&gt;\n  MappingPart.TargetEntity      = &lt;for subclass &lt;Id&gt;&gt;\n  MappingPart.SearchMappingAnno = &lt;( &lt;{SearchMappingAnnoPart \",\"}*&gt; )&gt;\n  MappingPart.EmbeddedDepth     = &lt;depth &lt;Int&gt;&gt;\n  MappingPart.EmbeddedDepthAlt  = &lt;with depth &lt;Int&gt;&gt;\n  MappingPart.Boost             = &lt;^ &lt;Float&gt;&gt;\n\n  SearchMappingAnnoPart.SearchMappingAnnoSpellCheck   = &lt;spellcheck&gt;\n  SearchMappingAnnoPart.SearchMappingAnnoAutoComplete = &lt;autocomplete&gt;\n\n  OptDefaultSearchField.OptDefaultSearchFieldNone = &lt;&gt;\n  OptDefaultSearchField.DefaultSearchField        = &lt;+&gt;\n\nlexical sorts\n\n  SearchMappingId\n\nlexical syntax\n\n  SearchMappingId = Id\n  SearchMappingId = \"as\" {reject}\n  SearchMappingId = \"using\" {reject}\n  SearchMappingId = \"boosted\" {reject}\n  SearchMappingId = \"by\" {reject}\n  SearchMappingId = \"with\" {reject}\n  SearchMappingId = \"index\" {reject}\n  SearchMappingId = \"depth\" {reject}\n  SearchMappingId = \"for\" {reject}\n\n  SA-Value = Id\n  SA-Value = Float\n  SA-Value = Int\n\ncontext-free sorts\n\n  SearcherDef SearcherPart QueryDef Offset MaxResults SortBy ConstraintFilter FacetDef SearchAttributes\n  NamespaceConstraint SearchAttribute FacetExp FilterConstraint FieldsConstraint QuerySearchField QueryConstraint\n  QueryBoost MatchGroup QueryExp Slop Range ExpOrWildCard RangeOpen RangeClose BoolOp QueryTerm SortExp Direction\n  Highlight RetrievalExp SuggestType SearchField PlainField SuggestionPart OptQueryBoost OptBoolOp\n  OptFieldsConstraint OptSlop OptDirection GroupDef\n\ncontext-free syntax\n\n  Exp.SearcherDef = SearcherDef\n  SearcherDef.SearcherInit = &lt;search &lt;SimpleSortLex&gt; &lt;SearcherPart*&gt;&gt;\n  SearcherDef.SearcherRefMod = &lt;~ &lt;Exp&gt; &lt;SearcherPart+&gt;&gt;\n  SearcherPart = ConstraintFilter\n  SearcherPart = QueryDef\n  SearcherPart = Offset\n  SearcherPart = MaxResults\n  SearcherPart = SortBy\n  SearcherPart = FacetDef\n  SearcherPart = SearchAttributes\n  SearcherPart = NamespaceConstraint\n  QueryDef.QueryDef = &lt;matching &lt;MatchGroup+&gt;&gt;\n  Offset.Start = &lt;offset &lt;Exp&gt;&gt;\n  MaxResults.MaxResults = &lt;limit &lt;Exp&gt;&gt;\n  SortBy.SortBy = &lt;order by &lt;{SortExp \",\"}+&gt;&gt;\n  ConstraintFilter.ConstraintFilter = &lt;with filter &lt;{FilterConstraint \",\"}+&gt;&gt;\n  ConstraintFilter.ConstraintFilterAlt = &lt;with filters &lt;{FilterConstraint \",\"}+&gt;&gt;\n  FacetDef.FacetDef = &lt;with facet &lt;{FacetExp \",\"}+&gt;&gt;\n  FacetDef.FacetDefAlt = &lt;with facets &lt;{FacetExp \",\"}+&gt;&gt;\n  SearchAttributes.SearchAttributes = &lt;[ &lt;{SearchAttribute \",\"}+&gt; ]&gt;\n  NamespaceConstraint.NamespaceConstraint = &lt;in namespace &lt;Exp&gt;&gt;\n  SearchAttribute.NoLucene = &lt;no lucene&gt;\n  SearchAttribute.Lucene = &lt;lucene&gt;\n  SearchAttribute.DefaultAnd = &lt;strict matching&gt;\n  SearchAttribute.DefaultOr = &lt;loose matching&gt;\n\nlexical syntax\n\n  VarId = \"nolucene\" {reject}\n  VarId = \"lucene\" {reject}\n  VarId = \"strictmatching\" {reject}\n  VarId = \"loosematching\" {reject}\n\ncontext-free syntax\n\n  FacetExp.DiscreteFacetDef = &lt;&lt;SearchField&gt; ( &lt;Exp&gt; )&gt;\n  FacetExp.RangeFacetDef = &lt;&lt;SearchField&gt; ( &lt;{Range \",\"}+&gt; )&gt;\n  FilterConstraint.FieldFilterConstraint = &lt;&lt;SearchField&gt; : &lt;Exp&gt;&gt;\n  FieldsConstraint.FieldsConstraint = &lt;&lt;{QuerySearchField \",\"}+&gt; :&gt;\n  QuerySearchField.QuerySearchField = &lt;&lt;SearchField&gt; &lt;OptQueryBoost&gt;&gt;\n  QueryConstraint.QueryConstraint = &lt;&lt;{QueryExp \",\"}+&gt;&gt;\n  QueryBoost.QueryBoost = &lt;^ &lt;Exp&gt;&gt;\n  MatchGroup.Clause = &lt;&lt;OptBoolOp&gt; ( &lt;MatchGroup+&gt; )&gt;\n  MatchGroup.Query = &lt;&lt;OptFieldsConstraint&gt; &lt;QueryConstraint&gt;&gt;\n  MatchGroup.MatchAllQuery = &lt;* : *&gt;\n  QueryExp.TermDef = &lt;&lt;OptBoolOp&gt; &lt;QueryTerm&gt; &lt;OptSlop&gt;&gt;\n  QueryExp.RangeDef = &lt;&lt;OptBoolOp&gt; &lt;Range&gt;&gt;\n  QueryExp.QueryExpGroupDef = GroupDef\n  GroupDef.GroupDef = &lt;&lt;OptBoolOp&gt; ( &lt;QueryExp+&gt; ) &lt;OptSlop&gt;&gt;\n  GroupDef = &lt;&lt;OptBoolOp&gt; ( &lt;Exp&gt; ) &lt;OptSlop&gt;&gt; {reject}\n  Slop.Slop = &lt;~ &lt;Exp&gt;&gt;\n  Range.Range = &lt;&lt;RangeOpen&gt; &lt;ExpOrWildCard&gt; to &lt;ExpOrWildCard&gt; &lt;RangeClose&gt;&gt;\n  Range.RangeAlt = &lt;&lt;RangeOpen&gt; &lt;ExpOrWildCard&gt; TO &lt;ExpOrWildCard&gt; &lt;RangeClose&gt;&gt;\n  ExpOrWildCard = Exp\n  ExpOrWildCard.WildCard = &lt;*&gt;\n  RangeOpen.ExcludingOpen = &lt;{&gt;\n  RangeClose.ExcludingClose = &lt;}&gt;\n  RangeOpen.IncludingOpen = &lt;[&gt;\n  RangeClose.IncludingClose = &lt;]&gt;\n  BoolOp.Must = &lt;+&gt;\n  BoolOp.MustNot = &lt;-&gt;\n  QueryTerm.QueryTermExp = &lt;&lt;Exp&gt;&gt;\n  QueryTerm = SearcherDef {reject}\n\n  SortExp.SortDef = &lt;&lt;SearchField&gt; &lt;OptDirection&gt;&gt;\n  Direction.AscendingAbbr = &lt;asc&gt;\n  Direction.Ascending = &lt;ascending&gt;\n  Direction.DescendingAbbr = &lt;desc&gt;\n  Direction.Descending = &lt;descending&gt;\n  Highlight.NormalHighlight = &lt;highlight&gt;\n  Highlight.HTMLHighlight = &lt;highlightHTML&gt;\n  RetrievalExp.Highlight = &lt;&lt;Highlight&gt; &lt;SearchField&gt; : &lt;Exp&gt; from &lt;Exp&gt;&gt;\n  RetrievalExp.HighlightTags = &lt;&lt;Highlight&gt; &lt;SearchField&gt; : &lt;Exp&gt; from &lt;Exp&gt; with tags ( &lt;Exp&gt; , &lt;Exp&gt; )&gt;\n  RetrievalExp.SearchResults = &lt;results from &lt;Exp&gt;&gt;\n  RetrievalExp.FacetResults = &lt;&lt;SearchField&gt; facets from &lt;Exp&gt;&gt;\n  RetrievalExp.SearchResultsSize = &lt;count from &lt;Exp&gt;&gt;\n  RetrievalExp.SearchTimeString = &lt;searchtime from &lt;Exp&gt;&gt;\n  RetrievalExp.Suggest = &lt;&lt;SimpleSortLex&gt; &lt;SuggestType&gt; &lt;SuggestionPart+&gt;&gt;\n  SuggestType.AutoComplete = &lt;completions&gt;\n  SuggestType.SpellCheck = &lt;corrections&gt;\n  Exp.RetrievalExp = RetrievalExp\n  SearchField.SearchFieldExp = &lt;~ &lt;Exp&gt;&gt;\n  SearchField = PlainField\n  PlainField.SearchFieldPlainBase = SearchFieldId\n  PlainField.SearchFieldPlain = &lt;&lt;SearchFieldId&gt; . &lt;PlainField&gt;&gt;\n  SuggestionPart.Similarity = &lt;similarity &lt;Exp&gt;&gt;\n  SuggestionPart.SuggestTerm = &lt;matching &lt;FieldsConstraint&gt; &lt;Exp&gt;&gt;\n  SuggestionPart = NamespaceConstraint\n  SuggestionPart = MaxResults\n\ncontext-free priorities\n\n  RetrievalExp.SearchResultsSize &lt;2&gt; .&gt; Exp.Eq,\n  RetrievalExp.SearchResultsSize &lt;2&gt; .&gt; Exp.NotEq,\n  RetrievalExp.SearchResultsSize &lt;2&gt; .&gt; Exp.LargerThan,\n  RetrievalExp.SearchResultsSize &lt;2&gt; .&gt; Exp.LargerThanOrEqual,\n  RetrievalExp.SearchResultsSize &lt;2&gt; .&gt; Exp.SmallerThan,\n  RetrievalExp.SearchResultsSize &lt;2&gt; .&gt; Exp.SmallerThanOrEqual\n\ncontext-free syntax\n\n  QueryTerm = SearcherKW {reject}\n  QueryTerm = &lt;&lt;SearcherKW&gt; ( &lt;Exp&gt; )&gt; {reject}\n  QueryTerm = &lt;[ &lt;{Exp \",\"}*&gt; ]&gt; {reject}\n\n  OptQueryBoost.OptQueryBoostNone = &lt;&gt;\n  OptQueryBoost = QueryBoost\n  OptBoolOp.OptBoolOpNone = &lt;&gt;\n  OptBoolOp = BoolOp\n  OptFieldsConstraint.OptFieldsConstraintNone = &lt;&gt;\n  OptFieldsConstraint = FieldsConstraint\n  OptSlop.OptSlopNone = &lt;&gt;\n  OptSlop = Slop\n  OptDirection.OptDirectionNone = &lt;&gt;\n  OptDirection = Direction\n\ncontext-free priorities\n\n  QueryTerm.QueryTermExp &lt;0&gt; .&gt; Exp.Sub,\n  QueryTerm.QueryTermExp &lt;0&gt; .&gt; Exp.Add\n\ncontext-free restrictions\n\n  BoolOp -/- [0-9]\n  QueryTerm -/- [\\(]\n\nlexical syntax\n\n  SearchFieldId = Id\n  SearchFieldId = \"_id\"\n  SEARCHERREF = Id\n  SearcherKW = \"limit\"\n  SearcherKW = \"offset\"\n  SearcherKW = \"with\"\n  SearcherKW = \"order\"\n  SearcherKW = \"in\"\n  SearcherKW = \"matching\"\n\nlexical restrictions\n\n  \"as\"\n  \"asc\"\n  \"ascending\"\n  \"analyzer\"\n  \"autocomplete\"\n  \"boost\"\n  \"boosted\"\n  \"by\" -/- [a-zA-Z0-9]\n  \"desc\"\n  \"descending\"\n  \"default\"\n  \"default_builtin_analyzer\"\n  \"depth\"\n  \"extend\"\n  \"for\" -/- [a-zA-Z0-9]\n  \"facet\"\n  \"facets\"\n  \"from\"\n  \"get\"\n  \"highlight\"\n  \"index\"\n  \"limit\" -/- [a-zA-Z0-9]\n  \"matching\"\n  \"name\"\n  \"namespace\"\n  \"nolucene\"\n  \"on\"\n  \"query\" -/- [a-zA-Z0-9]\n  \"results\"\n  \"search\"\n  \"sort\"\n  \"spellcheck\"\n  \"start\"\n  \"subclass\" -/- [a-zA-Z0-9]\n  \"using\"\n  \"with\"\n  \"where\" -/- [a-zA-Z0-9]\n\ncontext-free syntax\n\n  EntityBodyDeclaration.SearchMappingEmbeddedDepr = &lt;\n    searchmapping {\n      &lt;SearchMappingContent*&gt;\n    }\n  &gt; {deprecated(\"keyword `searchmapping` is replaced with `search mapping`\")}\n  Definition.SearchMappingDepr = &lt;\n    searchmapping &lt;Id&gt; {\n      &lt;SearchMappingContent*&gt;\n    }\n  &gt; {deprecated(\"keyword `searchmapping` is replaced with `search mapping`\")}\n  CharFilter.CharFilterDepr = &lt;charfilter = &lt;Id&gt; &lt;OptAnalyzerArguments&gt;&gt; {deprecated(\"keyword `charfilter` is replaced with `char filter`\")}\n  TokenFilter.TokenFilterDepr = &lt;tokenfilter = &lt;Id&gt; &lt;OptAnalyzerArguments&gt;&gt; {deprecated(\"keyword `tokenfilter` is replaced with `token filter`\")}\n  RetrievalExp.AllFacetResults = &lt;all &lt;SearchField&gt; facets from &lt;Exp&gt;&gt; {deprecated(\"the `all` keyword has been deprecated and has no effect on facet retrieval anymore\")}\n  FacetExp.DiscreteFacetDefDepr = &lt;( &lt;SearchField&gt; , &lt;Exp&gt; )&gt; {deprecated(\"the notation: (field,topN) has been replaced with field(topN) \")}\n  FacetExp.RangeFacetDefDepr = &lt;( &lt;SearchField&gt; : &lt;{Range \",\"}+&gt; )&gt; {deprecated(\"the notation: (field:[min to max], ...) has been replaced with field([min to max], ...) \")}\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Search.sdf3/#modal-h2","title":"WebDSL-Search.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Service.sdf3/","title":"<code>WebDSL-Service.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Service.sdf3</p> <pre><code>module WebDSL-Service\n\nimports\n  WebDSL-Action\n  WebDSL-Core\n  WebDSL-Lexical\n  WebDSL-UI\n  WebDSL-DataModel\n\ncontext-free sorts\n\n  SyncConfigEmbedded SyncOption\n\ncontext-free syntax\n\n  Definition.ServiceFunction = &lt;\n    service &lt;Modifier*&gt; &lt;Id&gt; ( &lt;{FormalArg \",\"}*&gt; ) &lt;Block&gt;\n  &gt;\n  Definition.DeriveWebServices = &lt;\n    derive webservices for &lt;Id&gt; , with nameproperty &lt;Id&gt;\n  &gt;\n  EntityBodyDeclaration = SyncConfigEmbedded\n  SyncConfigEmbedded.SyncConfigEmbedded = &lt;\n    synchronization configuration { &lt;SyncOption*&gt; }\n  &gt;\n  SyncOption.SyncTopLevelNameProperty = &lt;toplevel name property : &lt;Id&gt;&gt;\n  SyncOption.SyncRestrictedProperties = &lt;restricted properties : &lt;{Id \",\"}*&gt;&gt;\n  SyncOption.SyncACRead = &lt;access read : &lt;Exp&gt;&gt;\n  SyncOption.SyncACWrite = &lt;access write : &lt;Exp&gt;&gt;\n  SyncOption.SyncACCreate = &lt;access create : &lt;Exp&gt;&gt;\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Service.sdf3/#modal-h2","title":"WebDSL-Service.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Test.sdf3/","title":"<code>WebDSL-Test.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Test.sdf3</p> <pre><code>module WebDSL-Test\n\nimports\n  WebDSL-Action\n  WebDSL-Lexical\n  WebDSL-Core\n\ncontext-free syntax\n\n  Definition.Test = &lt;\n    test &lt;Id&gt; &lt;Block&gt;\n  &gt;\n  Definition.UnnamedTest = &lt;\n    test &lt;Block&gt;\n  &gt;\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Test.sdf3/#modal-h2","title":"WebDSL-Test.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-TimeInterval.sdf3/","title":"<code>WebDSL-TimeInterval.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-TimeInterval.sdf3</p> <pre><code>module WebDSL-TimeInterval\n\nimports\n  WebDSL-Action\n  WebDSL-Core\n\ncontext-free sorts\n\n  TimeIntervalPart TimeInterval\n\ncontext-free syntax\n\n  TimeIntervalPart.Weeks = &lt;&lt;Exp&gt; weeks&gt;\n  TimeIntervalPart.Days = &lt;&lt;Exp&gt; days&gt;\n  TimeIntervalPart.Hours = &lt;&lt;Exp&gt; hours&gt;\n  TimeIntervalPart.Minutes = &lt;&lt;Exp&gt; minutes&gt;\n  TimeIntervalPart.Seconds = &lt;&lt;Exp&gt; seconds&gt;\n  TimeIntervalPart.Milliseconds = &lt;&lt;Exp&gt; milliseconds&gt;\n  TimeInterval.TimeInterval = &lt;&lt;TimeIntervalPart*&gt;&gt;\n\ncontext-free syntax\n\n  Definition.InvokeEvery = &lt;\n    invoke &lt;Exp&gt; every &lt;TimeInterval&gt;\n  &gt;\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-TimeInterval.sdf3/#modal-h2","title":"WebDSL-TimeInterval.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-Type.sdf3/","title":"<code>WebDSL-Type.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-Type.sdf3</p> <pre><code>module WebDSL-Type\n\nimports\n  WebDSL-Action\n  WebDSL-DataModel\n  WebDSL-Lexical\n  WebDSL-Native\n  WebDSL-Core\n\ncontext-free sorts\n\n  TypeElement\n\ncontext-free syntax\n\n  Definition.TypeDef = &lt;\n    type &lt;Id&gt; {\n      &lt;TypeElement*&gt;\n    }\n  &gt;\n  TypeElement.TypeAnno = Annotation\n  TypeElement.TypeFunction = NCFunction\n  TypeElement = &lt;static&gt; {reject}\n  TypeElement.TypeFunctionFromStatic = NCFunctionFromStatic\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-Type.sdf3/#modal-h2","title":"WebDSL-Type.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-UI.sdf3/","title":"<code>WebDSL-UI.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-UI.sdf3</p> <pre><code>module WebDSL-UI\n\nimports\n  WebDSL-Action\n  WebDSL-Attributes\n  WebDSL-Core\n  WebDSL-Lexical\n  WebDSL-XML\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\-\\_]\n\ncontext-free sorts\n\n  TemplateDefinition Modifier TemplateElement OptFilter PageCall TemplateCall PropertyAssignment\n  TemplateArgExp TemplateCaseAlt TemplateTypeCaseAlt OptTemplateArgs TemplateArg OptLocalRedefineArgs\n  LocalRedefineArg\n\nlexical sorts\n\n  SubmitProp\n\ncontext-free syntax\n\n  Definition.TemplateDefinition = TemplateDefinition\n  TemplateDefinition.Define = &lt;\n    define &lt;Modifier*&gt; &lt;Id&gt; &lt;OptFormalArgs&gt; &lt;OptTemplateArgs&gt; {\n      &lt;TemplateElement*&gt;\n    }\n  &gt;\n  OptTemplateArgs.TemplateArgs = &lt;requires &lt;{TemplateArg \",\"}*&gt;&gt;\n  OptTemplateArgs.OptTemplateArgsNone = &lt;&gt;\n  TemplateArg.TemplateArg = &lt;&lt;TemplateId&gt; ( &lt;{Sort \",\"}*&gt; )&gt;\n  TemplateDefinition.LocalRedefine = &lt;\n    define &lt;Modifier*&gt; &lt;TemplateId&gt; ( &lt;{FormalArg \",\"}*&gt; ) = &lt;TemplateId&gt; &lt;OptLocalRedefineArgs&gt;\n  &gt;\n  OptLocalRedefineArgs.OptLocalRedefineArgsNone = &lt;&gt;\n  OptLocalRedefineArgs.LocalRedefineArgs = &lt;( * , &lt;{LocalRedefineArg \",\"}+&gt; )&gt;\n  LocalRedefineArg.LocalRedefineArg = Id\n  TemplateDefinition.DefinePage = &lt;\n    &lt;Modifier*&gt; page &lt;PageId&gt; &lt;OptFormalArgs&gt; &lt;OptTemplateArgs&gt; {\n      &lt;TemplateElement*&gt;\n    }\n  &gt;\n  TemplateDefinition.DefineTemplate = &lt;\n    &lt;Modifier*&gt; template &lt;TemplateId&gt; &lt;OptFormalArgs&gt; &lt;OptTemplateArgs&gt; {\n      &lt;TemplateElement*&gt;\n    }\n  &gt;\n  TemplateDefinition.DefineEmail = &lt;\n    &lt;Modifier*&gt; email &lt;Id&gt; &lt;OptFormalArgs&gt; &lt;OptTemplateArgs&gt; {\n      &lt;TemplateElement*&gt;\n    }\n  &gt;\n  Modifier.Page = &lt;page&gt;\n  Modifier.Email = &lt;email&gt;\n  Modifier.AjaxTemplate = &lt;ajax&gt;\n  Modifier.Template = &lt;template&gt;\n  Modifier.Feed = &lt;feed&gt;\n  Modifier.Local = &lt;local&gt;\n  Modifier.NoSpan = &lt;no-span&gt;\n  Modifier.TemplateModSpan = &lt;span&gt;\n  Modifier.TemplateModInline = &lt;inline&gt;\n  Modifier.TempateModSecure = &lt;secure&gt;\n  Modifier.TemplateModNotSecure = &lt;not-secure&gt;\n  Modifier.TemplateModOverride = &lt;override&gt;\n  Modifier.TemplateDeprecated = &lt;deprecated&gt;\n  Modifier.ExpireCache = &lt;expire-cache&gt;\n  Modifier.ReadOnlyPage = &lt;read-only&gt;\n  Modifier.WebService = &lt;service&gt;\n  TemplateElement.Init = &lt;\n    init &lt;Block&gt;\n  &gt;\n  TemplateElement = Action\n\n  TemplateCall = &lt;&lt;Modifier&gt;&gt; {reject}\n\nlexical syntax\n\n  TemplateId = \"template\" {reject}\n  TemplateId = \"define\" {reject}\n\ncontext-free sorts\n\n  VarDecl\n\ncontext-free syntax\n\n  VarDecl.TemplateVarDecl = &lt;\n    var &lt;VarId&gt; : &lt;Sort&gt;\n  &gt;\n  VarDecl.TemplateVarDeclDepr = &lt;\n    var &lt;VarId&gt; : &lt;Sort&gt; ;\n  &gt; {deprecated(\"remove ;\")}\n  VarDecl.TemplateVarDeclInit = &lt;\n    var &lt;VarId&gt; : &lt;Sort&gt; := &lt;Exp&gt;\n  &gt;\n  VarDecl.TemplateVarDeclInitDepr = &lt;\n    var &lt;VarId&gt; : &lt;Sort&gt; := &lt;Exp&gt; ;\n  &gt; {deprecated(\"remove ;\")}\n  VarDecl.TemplateVarDeclInitInferred = &lt;\n    var &lt;VarId&gt; := &lt;Exp&gt;\n  &gt;\n  VarDecl.TemplateVarDeclInitInferredDepr = &lt;\n    var &lt;VarId&gt; := &lt;Exp&gt; ;\n  &gt; {deprecated(\"remove ;\")}\n  TemplateElement.TEVarDecl = VarDecl\n  TemplateElement.RequestScopeTemplate = &lt;\n    request &lt;VarDecl&gt;\n  &gt;\n  TemplateElement.LocalScopeTemplate = &lt;\n    local &lt;VarDecl&gt;\n  &gt;\n  TemplateElement = TemplateDefinition\n  TemplateElement = TemplateCall\n\nlexical syntax\n\n  TemplateId = \"request\" {reject}\n  TemplateId = \"local\" {reject}\n\ncontext-free sorts\n\n  Filter OrderExp Limit\n\ncontext-free syntax\n\n  Filter.FilterNoOrderByNoLimit = &lt;where &lt;Exp&gt;&gt;\n  Filter.FilterNoWhereNoLimit = &lt;order by &lt;{OrderExp \",\"}+&gt;&gt;\n  Filter.FilterNoLimit = &lt;where &lt;Exp&gt; order by &lt;{OrderExp \",\"}+&gt;&gt;\n  Filter.FilterNoOrderBy = &lt;where &lt;Exp&gt; &lt;Limit&gt;&gt;\n  Filter.FilterNoWhere = &lt;order by &lt;{OrderExp \",\"}+&gt; &lt;Limit&gt;&gt;\n  Filter.FilterNoWhereNoOrderBy = Limit\n  Filter.Filter = &lt;where &lt;Exp&gt; order by &lt;{OrderExp \",\"}+&gt; &lt;Limit&gt;&gt;\n  OrderExp.OrderNonSpecific = Exp\n  OrderExp.OrderAscending = &lt;&lt;Exp&gt; asc&gt;\n  OrderExp.OrderDescending = &lt;&lt;Exp&gt; desc&gt;\n  Limit.Limit = &lt;limit &lt;Exp&gt; offset &lt;Exp&gt;&gt;\n  Limit.LimitNoOffset = &lt;limit &lt;Exp&gt;&gt;\n  Limit.LimitNoLimit = &lt;offset &lt;Exp&gt;&gt;\n  OptFilter.OptFilterSome = Filter\n  OptFilter.OptFilterNone = &lt;&gt;\n\ncontext-free sorts\n\n  ForSeparator ElseIfTempl OptElseTempl\n\ncontext-free syntax\n\n  TemplateElement.For = &lt;\n    for ( &lt;VarId&gt; : &lt;Sort&gt; in &lt;Exp&gt; &lt;OptFilter&gt; ) {\n      &lt;TemplateElement*&gt;\n    } &lt;ForSeparator&gt;\n  &gt;\n  TemplateElement.ForInferred = &lt;\n    for ( &lt;VarId&gt; in &lt;Exp&gt; &lt;OptFilter&gt; ) {\n      &lt;TemplateElement*&gt;\n    } &lt;ForSeparator&gt;\n  &gt;\n  TemplateElement.ForAll = &lt;\n    for ( &lt;VarId&gt; : &lt;Sort&gt; &lt;OptFilter&gt; ) {\n      &lt;TemplateElement*&gt;\n    } &lt;ForSeparator&gt;\n  &gt;\n  TemplateElement.ForCount = &lt;\n    for ( &lt;VarId&gt; : Int from &lt;Exp&gt; to &lt;Exp&gt; ) {\n      &lt;TemplateElement*&gt;\n    } &lt;ForSeparator&gt;\n  &gt;\n  ForSeparator.ForSeparator = &lt;separated-by { &lt;TemplateElement*&gt; }&gt;\n  ForSeparator.ForSeparatorNone = &lt;&gt;\n\n  TemplateElement.IfTempl = &lt;\n    if ( &lt;Exp&gt; ) {\n      &lt;TemplateElement*&gt;\n    } else {\n      &lt;TemplateElement*&gt;\n    }\n  &gt;\n  TemplateElement.IfNoElseTempl = &lt;\n    if ( &lt;Exp&gt; ) {\n      &lt;TemplateElement*&gt;\n    }\n  &gt;\n  TemplateElement.IfElseIfTempl = &lt;\n    if ( &lt;Exp&gt; ) {\n      &lt;TemplateElement*&gt;\n    } &lt;ElseIfTempl+&gt; &lt;OptElseTempl&gt;\n  &gt;\n  OptElseTempl.OptElseTemplNone = &lt;&gt;\n  OptElseTempl.ElseTempl = &lt;else {\n    &lt;TemplateElement*&gt;\n  }&gt;\n\n  ElseIfTempl.ElseIfTempl = &lt;else if ( &lt;Exp&gt; ) {\n    &lt;TemplateElement*&gt;\n  }&gt;\n\nlexical syntax\n\n  TemplateId = \"if\" {reject}\n  TemplateId = \"else\" {reject}\n\ncontext-free syntax\n\n  TemplateElement.TemplateCase = &lt;\n    case ( &lt;{Exp \",\"}+&gt; ) {\n      &lt;TemplateCaseAlt*&gt;\n    }\n  &gt;\n  TemplateCaseAlt.TemplateCaseAlt = &lt;\n    &lt;TemplateCaseAltExps&gt; { &lt;TemplateElement*&gt; }\n  &gt;\n  TemplateCaseAlt.TemplateCaseAltDefault = &lt;\n    default { &lt;TemplateElement*&gt; }\n  &gt;\n  TemplateElement.TemplateTypeCase = &lt;\n    typecase ( &lt;Exp&gt; &lt;OptTypeAlias&gt; ) {\n      &lt;TemplateTypeCaseAlt*&gt;\n    }\n  &gt;\n  TemplateTypeCaseAlt.TemplateTypeCaseAlt = &lt;\n    &lt;Sort&gt; { &lt;TemplateElement*&gt; }\n  &gt;\n  TemplateTypeCaseAlt.TemplateTypeCaseDefault = &lt;\n    default { &lt;TemplateElement*&gt; }\n  &gt;\n\nlexical syntax\n\n  TemplateId = \"case\" {reject}\n  TemplateId = \"typecase\" {reject}\n\ncontext-free sorts\n\n  TemplateCaseAltExps\n\ncontext-free syntax\n\n  TemplateCaseAltExps.TemplateCaseExps = &lt;&lt;{Exp \",\"}+&gt;&gt;\n  TemplateCaseAltExps = &lt;default&gt; {reject}\n\ncontext-free priorities\n\n  TemplateElement.TemplateTypeCase &lt;2&gt; .&gt; Exp.Cast\n\ncontext-free sorts\n\n  OptTCallArgs OptTCallPropAssigns TemplateBody ArgDefine\n\ncontext-free syntax\n\n  TemplateCall.TemplateCall = &lt;\n    &lt;TemplateCallId&gt; &lt;OptTCallArgs&gt; &lt;OptTCallPropAssigns&gt; &lt;TemplateBody&gt;\n  &gt;\n  OptTCallArgs.TCallArgs = &lt;( &lt;{TemplateArgExp \",\"}*&gt; )&gt;\n  OptTCallArgs.OptTCallArgsNone = &lt;&gt;\n  TemplateArgExp.Exp = Exp\n  TemplateArgExp.TemplateElementsArgument = &lt;{ &lt;TemplateElement*&gt; }&gt;\n  OptTCallPropAssigns.TCallPropAssigns = &lt;[ &lt;{PropertyAssignment \",\"}*&gt; ]&gt;\n  OptTCallPropAssigns.OptTCallPropAssignsNone = &lt;&gt;\n  TemplateBody.TemplateBody = &lt;{\n    &lt;TemplateElement*&gt;\n  }&gt;\n  TemplateBody.TemplateBodyNone = &lt;&gt;\n  TemplateBody.TemplateWith = &lt;with {\n    &lt;ArgDefine*&gt;\n  }&gt;\n  ArgDefine.ArgDefine = &lt;\n    &lt;TemplateCallId&gt; ( &lt;{FormalArg \",\"}*&gt; ) {\n      &lt;TemplateElement*&gt;\n    }\n  &gt;\n  TemplateCall = &lt;with { &lt;TemplateElement*&gt; }&gt; {reject}\n\ncontext-free syntax\n\n  TemplateElement.NavigateCallParenthesesNoProps = &lt;\n    navigate ( &lt;PageCall&gt; ) { &lt;TemplateElement*&gt; }\n  &gt;\n  TemplateElement.NavigateCallParentheses = &lt;\n    navigate ( &lt;PageCall&gt; ) [ &lt;{PropertyAssignment \",\"}*&gt; ] { &lt;TemplateElement*&gt; }\n  &gt;\n  TemplateElement.NavigateCallNoProps = &lt;\n    navigate &lt;PageCall&gt; { &lt;TemplateElement*&gt; }\n  &gt;\n  TemplateElement.NavigateCall = &lt;\n    navigate &lt;PageCall&gt; [ &lt;{PropertyAssignment \",\"}*&gt; ] { &lt;TemplateElement*&gt; }\n  &gt;\n  PageCall.PageCall = &lt;\n    &lt;PageId&gt; ( &lt;{Exp \",\"}*&gt; )\n  &gt;\n\ncontext-free sorts\n\n  ActionCallOrInline\n\ncontext-free syntax\n\n  TemplateElement.SubmitActionNoProps = &lt;\n    action ( &lt;Exp&gt; , &lt;ActionCallOrInline&gt; )\n  &gt;\n  TemplateElement.SubmitAction = &lt;\n    action ( &lt;Exp&gt; , &lt;ActionCallOrInline&gt; ) [ &lt;{PropertyAssignment \",\"}*&gt; ]\n  &gt;\n  TemplateElement.SubmitLinkActionNoProps = &lt;\n    actionLink ( &lt;Exp&gt; , &lt;ActionCallOrInline&gt; )\n  &gt;\n  TemplateElement.SubmitLinkAction = &lt;\n    actionLink ( &lt;Exp&gt; , &lt;ActionCallOrInline&gt; ) [ &lt;{PropertyAssignment \",\"}*&gt; ]\n  &gt;\n  TemplateElement.SubmitNoProps = &lt;\n    submit ( &lt;Exp&gt; , &lt;ActionCallOrInline&gt; )\n  &gt;\n  TemplateElement.Submit = &lt;\n    submit ( &lt;Exp&gt; , &lt;ActionCallOrInline&gt; ) [ &lt;{PropertyAssignment \",\"}*&gt; ]\n  &gt;\n  TemplateElement.SubmitLinkNoProps = &lt;\n    submitlink ( &lt;Exp&gt; , &lt;ActionCallOrInline&gt; )\n  &gt;\n  TemplateElement.SubmitLink = &lt;\n    submitlink ( &lt;Exp&gt; , &lt;ActionCallOrInline&gt; ) [ &lt;{PropertyAssignment \",\"}*&gt; ]\n  &gt;\n  TemplateElement.SubmitElemNoProps = &lt;\n    submit &lt;ActionCallOrInline&gt; { &lt;TemplateElement*&gt; }\n  &gt;\n  TemplateElement.SubmitElem = &lt;\n    submit &lt;ActionCallOrInline&gt; [ &lt;{PropertyAssignment \",\"}*&gt; ] { &lt;TemplateElement*&gt; }\n  &gt;\n  TemplateElement.SubmitLinkElemNoProps = &lt;\n    submitlink &lt;ActionCallOrInline&gt; { &lt;TemplateElement*&gt; }\n  &gt;\n  TemplateElement.SubmitLinkElem = &lt;\n    submitlink &lt;ActionCallOrInline&gt; [ &lt;{PropertyAssignment \",\"}*&gt; ] { &lt;TemplateElement*&gt; }\n  &gt;\n  TemplateElement.DownloadLinkNoProps = &lt;\n    downloadlink &lt;ActionCallOrInline&gt; { &lt;TemplateElement*&gt; }\n  &gt;\n  TemplateElement.DownloadLink = &lt;\n    downloadlink &lt;ActionCallOrInline&gt; [ &lt;{PropertyAssignment \",\"}*&gt; ] { &lt;TemplateElement*&gt; }\n  &gt;\n  TemplateElement.OutputImageNoProps = &lt;\n    outputimage &lt;ActionCallOrInline&gt; { &lt;TemplateElement*&gt; }\n  &gt;\n  TemplateElement.OutputImage = &lt;\n    outputimage &lt;ActionCallOrInline&gt; [ &lt;{PropertyAssignment \",\"}*&gt; ] { &lt;TemplateElement*&gt; }\n  &gt;\n  ActionCallOrInline.ActionCall = ThisCall\n  ActionCallOrInline.InlineAction = &lt;action &lt;Block&gt;&gt;\n\nlexical syntax\n\n  TemplateId = \"action\" {reject}\n  TemplateId = \"actionLink\" {reject}\n  TemplateId = \"submit\" {reject}\n  TemplateId = \"submitlink\" {reject}\n  TemplateId = \"downloadlink\" {reject}\n  TemplateId = \"outputimage\" {reject}\n\ncontext-free sorts\n\n  ActionCallOrInlineOrExp PropertySubmitMultiple PropertySubmitExp\n\ncontext-free syntax\n\n  PropertyAssignment.PropertySubmitColon = &lt;&lt;SubmitProp&gt; : &lt;ActionCallOrInlineOrExp&gt;&gt;\n  PropertyAssignment.PropertySubmitAssign = &lt;&lt;SubmitProp&gt; := &lt;ActionCallOrInlineOrExp&gt;&gt;\n  PropertyAssignment.PropertySubmit = &lt;&lt;SubmitProp&gt; = &lt;ActionCallOrInlineOrExp&gt;&gt;\n  PropertyAssignment.PropertyAssignmentColon = &lt;&lt;PropertyAssignmentId&gt; : &lt;Exp&gt;&gt;\n  PropertyAssignment.PropertyAssignmentAssign = &lt;&lt;PropertyAssignmentId&gt; := &lt;Exp&gt;&gt;\n  PropertyAssignment.PropertyAssignment = &lt;&lt;PropertyAssignmentId&gt; = &lt;Exp&gt;&gt;\n  PropertyAssignment.TemplateCallPropertyAjax = &lt;ajax&gt;\n  PropertyAssignment.TemplateCallPropertyNoLoadingFeedback = &lt;no loading feedback&gt;\n  PropertyAssignment.TemplateCallPropertySecure = &lt;secure&gt;\n  PropertyAssignment.TemplateCallPropertyIgnoreValidation = &lt;ignore-validation&gt;\n  PropertyAssignment.TemplateCallPropertyNotSecure = &lt;not-secure&gt;\n  PropertyAssignment.TemplateCallPropertyNotNull = &lt;not null&gt;\n  PropertyAssignment = CommonAttribute\n  PropertyAssignment = PropertySubmitMultiple\n  PropertySubmitMultiple.PropertySubmitMultiple = &lt;&lt;SubmitProp&gt; = &lt;{ActionCallOrInlineOrExp \";\"}+&gt;&gt;\n  ActionCallOrInlineOrExp.ActionCallOrInline = ActionCallOrInline\n  ActionCallOrInlineOrExp.ActionCallOrInlineExp = PropertySubmitExp\n  PropertySubmitExp.PropertySubmitExp = Exp\n  TemplateElement = OutputShorthand\n\n  // require at least two actions to get this constructor\n  PropertySubmitMultiple = &lt;&lt;SubmitProp&gt; = &lt;ActionCallOrInlineOrExp&gt;&gt; {reject}\n\n  PropertySubmitExp = ThisCall {reject}\n\nlexical sorts\n\n  PropertyAssignmentId\n\nlexical syntax\n\n  PropertyAssignmentId = ExtendedId\n  PropertyAssignmentId = SubmitProp {reject}\n\nsyntax\n\n  TemplateElement-CF.Text = \"\\\"\" StringPart-CF* \"\\\"\"\n\nlexical syntax\n\n  SubmitProp = \"onabort\"\n  SubmitProp = \"onblur\"\n  SubmitProp = \"onchange\"\n  SubmitProp = \"onclick\"\n  SubmitProp = \"ondblclick\"\n  SubmitProp = \"onerror\"\n  SubmitProp = \"onfocus\"\n  SubmitProp = \"onkeydown\"\n  SubmitProp = \"onkeypress\"\n  SubmitProp = \"onkeyup\"\n  SubmitProp = \"onload\"\n  SubmitProp = \"onmousedown\"\n  SubmitProp = \"onmousemove\"\n  SubmitProp = \"onmouseout\"\n  SubmitProp = \"onmouseover\"\n  SubmitProp = \"onmouseup\"\n  SubmitProp = \"onreset\"\n  SubmitProp = \"onresize\"\n  SubmitProp = \"onselect\"\n  SubmitProp = \"onsubmit\"\n  SubmitProp = \"onunload\"\n  SubmitProp = \"oninput\"\n\ncontext-free sorts\n\n  ActionModifier TemplateCallId\n\ncontext-free syntax\n\n  TemplateCall = &lt;separated-by { &lt;TemplateElement*&gt; }&gt; {reject}\n  Definition.GlobalInit = &lt;\n    init &lt;Block&gt;\n  &gt;\n  TemplateElement.DataBindAction = &lt;databind &lt;Block&gt;&gt;\n  TemplateElement.RenderAction = &lt;render &lt;Block&gt;&gt;\n  TemplateElement.AllPhasesAction = &lt;allphases &lt;Block&gt;&gt;\n  TemplateElement.ValidateAction = &lt;validate &lt;Block&gt;&gt;\n  Action.Action = &lt;action &lt;ActionModifier*&gt; &lt;Id&gt; &lt;OptFormalArgs&gt; &lt;Block&gt;&gt;\n  ActionModifier.ActionModifierIgnoreValidation = &lt;ignore-validation&gt;\n  TemplateCallId.QualifiedElementsCall = &lt;&lt;TemplateId&gt; .elements&gt;\n  TemplateCallId.TemplateCallId = TemplateId\n\ncontext-free syntax // reject rules\n\n  TemplateCall = &lt;init &lt;Block&gt;&gt; {reject}\n  TemplateCall = &lt;databind &lt;Block&gt;&gt; {reject}\n  TemplateCall = &lt;render &lt;Block&gt;&gt; {reject}\n  TemplateCall = &lt;allphases &lt;Block&gt;&gt; {reject}\n  TemplateCall = &lt;action&gt; {reject}\n  TemplateCall = &lt;validate &lt;Block&gt;&gt; {reject}\n\ncontext-free sorts\n\n  FormalVarArg ExpVarArg ExpOrTemplateArg\n\ncontext-free syntax\n\n  Sort.TemplateVarArgSort = &lt;[ &lt;{FormalVarArg \",\"}+&gt; ]&gt;\n  FormalVarArg.FormalVarArg = &lt;&lt;Id&gt; : &lt;Sort&gt;&gt;\n  TemplateCall.MemberTemplateCall = &lt;\n    &lt;Id&gt; . &lt;TemplateCall&gt;\n  &gt;\n  Exp.TemplateVarArgExp = &lt;[ &lt;{ExpVarArg \",\"}+&gt; ]&gt;\n  ExpVarArg.ExpVarArgFor = &lt;for ( &lt;Id&gt; : &lt;Sort&gt; in &lt;Exp&gt; &lt;OptFilter&gt; ) { &lt;{ExpVarArg \",\"}*&gt; }&gt;\n  ExpVarArg.ExpVarArgForInferred = &lt;for ( &lt;Id&gt; in &lt;Exp&gt; &lt;OptFilter&gt; ) { &lt;{ExpVarArg \",\"}*&gt; }&gt;\n  ExpVarArg.ExpVarArgForAll = &lt;for ( &lt;Id&gt; : &lt;Sort&gt; &lt;OptFilter&gt; ) { &lt;{ExpVarArg \",\"}*&gt; }&gt;\n  ExpVarArg.ExpVarArgForCount = &lt;for ( &lt;Id&gt; : Int from &lt;Exp&gt; to &lt;Exp&gt; ) { &lt;{ExpVarArg \",\"}*&gt; }&gt;\n  ExpVarArg.ExpVarArg = &lt;( &lt;{ExpOrTemplateArg \",\"}*&gt; )&gt;\n\n  ExpOrTemplateArg.ExpVarArgExp = &lt;&lt;Exp&gt;&gt;\n  ExpOrTemplateArg.ExpVarArgElements = &lt;{ &lt;TemplateElement*&gt; }&gt;\n\ncontext-free priorities\n\n  ExpOrTemplateArg.ExpVarArgExp &lt;0&gt; .&gt; Exp.SetCreation\n\ncontext-free sorts\n\n  HTMLWrapper HTMLWrapperAssigns HTMLWrapperBody HTMLWrapperAssign\n\ncontext-free syntax\n\n  HTMLWrapper.HTMLWrapper = &lt;\n    htmlwrapper &lt;HTMLWrapperBody&gt;\n  &gt;\n  HTMLWrapperAssigns.HTMLWrapperAssigns = &lt;[&lt;HTMLWrapperAssign*&gt; ]&gt;\n  HTMLWrapperAssigns.HTMLWrapperAssignsNone = &lt;&gt;\n\n  HTMLWrapperAssign.HTMLWrapperAssign = &lt;&lt;Attribute&gt;&gt;\n  HTMLWrapperAssign.HTMLWrapperAssignComma = &lt;&lt;Attribute&gt; ,&gt;\n\n  TemplateDefinition = HTMLWrapper\n  TemplateDefinition.HTMLWrapperMultiple = &lt;\n    htmlwrapper {\n      &lt;HTMLWrapperBody*&gt;\n    }\n  &gt;\n  HTMLWrapperBody.HTMLWrapperBody = &lt;&lt;Id&gt; &lt;Id&gt; &lt;HTMLWrapperAssigns&gt;&gt;\n\nlexical syntax\n\n  TemplateId = \"htmlwrapper\" {reject}\n\ncontext-free sorts\n\n  TemplateName\n\ncontext-free syntax\n\n  TemplateName.TemplateName = &lt;id&gt;\n  Exp = TemplateName\n\nlexical syntax\n\n  VarId = \"id\" {reject}\n\ncontext-free restrictions\n\n  TemplateName -/- [a-zA-Z0-9\\_]\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-UI.sdf3/#modal-h2","title":"WebDSL-UI.sdf3","text":""},{"location":"webdslstatix/syntax/WebDSL-XML.sdf3/","title":"<code>WebDSL-XML.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/WebDSL-XML.sdf3</p> <pre><code>module WebDSL-XML\n\nimports\n  WebDSL-Action\n  WebDSL-UI\n  WebDSL-Attributes\n\nlexical sorts\n\n  HTML5VoidElement XMLComment XMLCommentChar OneDash TwoDashes QualName Qualifier NCName\n  XMLTagName\n\ncontext-free syntax\n\n  TemplateElement.XMLEmptyElement = &lt;\n    \\&lt; &lt;XMLTagName&gt; &lt;Attribute*&gt; /\\&gt;\n  &gt;\n  TemplateElement.XMLElement = &lt;\n    \\&lt; &lt;XMLTagName&gt; &lt;Attribute*&gt; \\&gt;\n      &lt;TemplateElement*&gt;\n    \\&lt;/ &lt;XMLTagName&gt; \\&gt;\n  &gt;\n\ncontext-free syntax\n\n  TemplateElement.XMLEmptyElementUnclosed = &lt;\\&lt; &lt;HTML5VoidElement&gt; &lt;Attribute*&gt; \\&gt;&gt;\n\nlexical syntax\n\n  HTML5VoidElement = \"area\"\n  HTML5VoidElement = \"base\"\n  HTML5VoidElement = \"br\"\n  HTML5VoidElement = \"col\"\n  HTML5VoidElement = \"embed\"\n  HTML5VoidElement = \"hr\"\n  HTML5VoidElement = \"img\"\n  HTML5VoidElement = \"input\"\n  HTML5VoidElement = \"keygen\"\n  HTML5VoidElement = \"link\"\n  HTML5VoidElement = \"menuitem\"\n  HTML5VoidElement = \"meta\"\n  HTML5VoidElement = \"param\"\n  HTML5VoidElement = \"source\"\n  HTML5VoidElement = \"track\"\n  HTML5VoidElement = \"wbr\"\n\ncontext-free syntax\n\n  TemplateElement.XMLComment = XMLComment\n\nlexical syntax\n\n  XMLComment = \"&lt;!--\" XMLCommentChar* \"--&gt;\"\n  XMLCommentChar = ~[\\-]\n  XMLCommentChar = OneDash\n  XMLCommentChar = TwoDashes\n  OneDash = [\\-]\n  TwoDashes = [\\-] [\\-]\n\nlexical restrictions\n\n  OneDash -/- [\\-]\n  TwoDashes -/- [\\&gt;]\n\ncontext-free syntax\n\n  Attribute.XMLAttributesIf = &lt;if ( &lt;Exp&gt; ) { &lt;Attribute*&gt; }&gt;\n  Attribute.XMLAttributesIfElse = &lt;if ( &lt;Exp&gt; ) { &lt;Attribute*&gt; } else { &lt;Attribute*&gt; }&gt;\n\ncontext-free sorts\n\n  CommonAttribute\n\ncontext-free syntax\n\n  Attribute.Attribute = &lt;&lt;QualName&gt; = &lt;Exp&gt;&gt;\n  Attribute = CommonAttribute\n  CommonAttribute.AllAttributes = &lt;all attributes&gt;\n  CommonAttribute.AllAttributesExceptExp = &lt;all attributes except &lt;Exp&gt;&gt;\n  CommonAttribute.AttributesExp = &lt;attributes &lt;Exp&gt;&gt;\n\nlexical syntax\n\n  XMLTagName = QualName\n  QualName = Qualifier? NCName\n  Qualifier = NCName \":\"\n  NCName = [A-Za-z\\_] [A-Za-z0-9\\.\\-\\_]*\n\nlexical restrictions\n\n  NCName -/- [A-Za-z0-9\\.\\-\\_]\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/WebDSL-XML.sdf3/#modal-h2","title":"WebDSL-XML.sdf3","text":""},{"location":"webdslstatix/syntax/webdsl-statix.sdf3/","title":"<code>webdsl-statix.sdf3</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/syntax/webdsl-statix.sdf3</p> <pre><code>module webdsl-statix\n\nimports\n  WebDSL-AccessControl\n  WebDSL-Action\n  WebDSL-Ajax\n  WebDSL-Attributes\n  WebDSL-Core\n  WebDSL-DataModel\n  WebDSL-DataValidation\n  WebDSL-Dispatch\n  WebDSL-EntityDerive\n  WebDSL-Exception\n  WebDSL-Expand\n  WebDSL-Generated\n  WebDSL-JavaScript\n  WebDSL-Lexical\n  WebDSL-Native\n  WebDSL-Prefetch\n  WebDSL-Regex\n  WebDSL-Routing\n  WebDSL-Search\n  WebDSL-Service\n  WebDSL-Test\n  WebDSL-TimeInterval\n  WebDSL-Type\n  WebDSL-UI\n  WebDSL-XML\n\ncontext-free start-symbols\n\n  Unit\n\n</code></pre> \u00d7"},{"location":"webdslstatix/syntax/webdsl-statix.sdf3/#modal-h2","title":"webdsl-statix.sdf3","text":""},{"location":"webdslstatix/trans/statics.stx/","title":"<code>statics.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/statics.stx</p> <pre><code>module statics\n\nimports\n  static-semantics/webdsl\n\n// see README.md for details on how to switch to multi-file analysis\n\nrules // single-file entry point\n\n//  applicationOk : Unit\n//  applicationOk(u) :- {s_init}\n//    new s_init,\n//    init(s_init),\n//    programOk(s_init, u).\n\nrules // multi-file entry point\n\n  projectOk : scope\n  projectOk(s_global).\n\n  fileOk : scope * Unit\n  fileOk(s_global, u) :-\n    unitOk(s_global, u).\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/statics.stx/#modal-h2","title":"statics.stx","text":""},{"location":"webdslstatix/trans/static-semantics/webdsl-ac.stx/","title":"<code>webdsl-ac.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/webdsl-ac.stx</p> <pre><code>module static-semantics/webdsl-ac\n\nimports\n  static-semantics/actions/functions\n\n  static-semantics/entities/annotations\n\n  static-semantics/types/built-ins\n\n  static-semantics/ui/template-calls\n\n  static-semantics/webdsl-actions\n  static-semantics/webdsl-built-ins\n  static-semantics/webdsl-entities\n  static-semantics/webdsl-types\n  static-semantics/webdsl\n\nrules // built-ins\n\n  declareACBuiltIns : scope * scope\n  declareACBuiltIns(s_decl, s_resolve) :- { s_securityContext bool entity }\n    bool == bool(s_resolve),\n    entity == entity(s_resolve),\n\n    new s_securityContext,\n    declareEntityAnnotation(s_securityContext, SESSIONENTITY()),\n    declareExtendScope(s_decl, \"securityContext\", s_securityContext), // declare s_type to be linked to type name\n    extendScopes(resolveExtendScope(s_decl, \"securityContext\"), s_securityContext),\n    declareType(s_decl, \"securityContext\", ENTITY(\"securityContext\", s_securityContext)),\n    declareVar(s_decl, \"securityContext\", ENTITY(\"securityContext\", s_securityContext)),\n\n    declareBuiltInFunction(s_decl, \"loggedIn\", [], bool),\n    declareBuiltInFunction(s_decl, \"logout\", [], entity),\n    declareBuiltInFunction(s_decl, \"principalAsEntity\", [], entity),\n\n    declareTemplate(s_decl, \"login\", []),\n    declareTemplate(s_decl, \"logout\", []),\n    declareTemplate(s_decl, \"authentication\", []).\n\n  typeOfFunctionCall(s, \"loggedIn\", []) = bool(s) :- principalDefined(s).\n  typeOfFunctionCall(s, \"logout\", []) = VOID() :- principalDefined(s).\n  typeOfFunctionCall(s, \"principalAsEntity\", []) = entity(s) :- principalDefined(s).\n  typeOfFunctionCall(s, \"authenticate\", argExps) = bool(s) :- { argTypes credentialTypes }\n    principalDefined(s),\n    argTypes == typesOfExps(s, argExps),\n    credentialTypes == credentialTypes(s),\n    typesCompatible(argTypes, credentialTypes) == TRUE() | error $[Argument types [argTypes] not compatible with credential types [credentialTypes]].\n\n  templateCallMatchesSig(s, \"login\", [], _) :- principalDefined(s).\n  templateCallMatchesSig(s, \"logout\", [], _) :- principalDefined(s).\n  templateCallMatchesSig(s, \"authenticate\", [], _) :- principalDefined(s).\n\nrules\n\n  sectionOk(s, AccessControlDefinition(_, defs)) :- acDefsOk(s, defs).\n\n  acDefsOk maps acDefOk(*, list(*))\n  acDefOk : scope * AccessControlDefinition\n  acDefOk(_,_) :- false | error $[This access control definition is not yet supported].\n\nrules // securitycontext and principal\n\n  defOk(s, AccessControlPrincipalDef(ent, properties)) :- principalDefOk(s, ent, properties).\n  acDefOk(s, AccessControlPrincipalAcDef(ent, properties)) :- principalDefOk(s, ent, properties).\n\n  principalDefOk : scope * string * list(string)\n  principalDefOk(s, ent, properties) :- { s_ent entityName credentialTypes t }\n    // TO-DO: only give principal access to the credential properties instead of all\n    definedTypeCustomError(s, ent) == t@ENTITY(entityName, s_ent) | error $[Entity [ent] does not exist, and cannot be used as principal for access control], // correct error message for tests\n    principalPropertyTypes(s_ent, properties, ent) == credentialTypes,\n    compatibleCredentialTypes(properties, credentialTypes),\n    declSecurityContext(s, t, credentialTypes).\n\n  compatibleCredentialTypes maps compatibleCredentialType(list(*), list(*))\n  compatibleCredentialType : string * TYPE\n  compatibleCredentialType(x, s) :-\n    isStringCompatibleType(s) | error $[Credential types should be compatible with String type] @x.\n\n  declSecurityContext : scope * TYPE * list(TYPE)\n  declSecurityContext(s, principalType, credentialTypes) :- { s_extend_security_context }\n    new s_extend_security_context,\n    declProperty(s_extend_security_context, \"securityContext\", \"principal\", principalType),\n    declProperty(s_extend_security_context, \"securityContext\", \"loggedIn\", bool(s)),\n    declareCredentials(s_extend_security_context, credentialTypes),\n    declareExtendScope(s, \"securityContext\", s_extend_security_context),\n    extendScopes(resolveExtendScope(s, \"securityContext\"), s_extend_security_context).\n\n  declareCredentials : scope * list(TYPE)\n  declareCredentials(s, ts) :- !var[\"_credentials\", withType(CREDENTIALS(ts))] in s.\n\nrules // access control rules\n\n  acDefOk(s, Rule(r)) :- acRuleOk(s, r).\n\n  acRuleOk : scope * AccessControlRule\n  acRuleOk(_, _) :- try { false } | warning $[This access control rule is not yet implemented].\n  acRuleOk(s, AccessControlRule(t, x, mas@MatchArgs(args, _), exp, nested)) :- { s_rule argTypes principalType bool }\n    acRuleSignatureOk(s, t, x, mas),\n    bool == bool(s),\n    new s_rule, s_rule -F-&gt; s,\n    argTypes == typesOfArgs(s, args),\n    declareParameters(s_rule, zipArgTypes(args, argTypes)),\n    principalType == principalType(s) | error $[Cannot have access control rules without a principal declaration] @x, // correct error message for tests\n    declareVar(s_rule, \"principal\", principalType),\n    declareVar(s_rule, \"loggedIn\", bool),\n    nestedAcRulesOk(s_rule, nested),\n    equalType(typeOfExp(s_rule, exp), bool) | error $[Rule should contain a Bool expression] @exp. // correct error message for tests\n\n  acRuleOk(s, SpecialAccessControlRule(exp)) :- { s_rule principalType bool }\n    bool == bool(s),\n    new s_rule, s_rule -F-&gt; s,\n    principalType == principalType(s) | error $[Cannot have access control rules without a principal declaration], // correct error message for tests\n    declareVar(s_rule, \"principal\", principalType),\n    declareVar(s_rule, \"loggedIn\", bool),\n    equalType(typeOfExp(s_rule, exp), bool) | error $[Rule should contain a Bool expression] @exp. // correct error message for tests\n\n  nestedAcRulesOk maps nestedAcRuleOk(*, list(*))\n  nestedAcRuleOk : scope * AccessControlRule\n  nestedAcRuleOk(_, _) :- false | error $[Nested rule type unknown, nested rules must be of type \"action\"]. // correct error message for tests\n  nestedAcRuleOk(_, AccessControlRule(t, _, _, _, _)) :- false | error $[Nested rule type unknown, nested rules must be of type \"action\"] @t. // correct error message for tests\n  nestedAcRuleOk(s, AccessControlRule(ACTypeAction(), x, MatchArgs(args, _), exp, nested)) :- { s_rule argTypes }\n    new s_rule, s_rule -P-&gt; s, // P label here instead of F to correctly resolve and error on variable usage\n    argTypes == typesOfArgs(s, args),\n    declareParameters(s_rule, zipArgTypes(args, argTypes)),\n    nestedAcRulesOk(s_rule, nested),\n    equalType(typeOfExp(s_rule, exp), bool(s)) | error $[Rule should contain a Bool expression] @exp. // correct error message for tests\n\n  nestedAcRuleOk(s, SpecialAccessControlRule(exp)) :- { s_rule }\n    new s_rule, s_rule -P-&gt; s,\n    equalType(typeOfExp(s_rule, exp), bool(s)) | error $[Rule should contain a Bool expression] @exp. // correct error message for tests\n\n  acRuleSignatureOk : scope * AccessControlType * MatchName * OptMatchArgs\n  acRuleSignatureOk(_, _, m, _) :- try { false } | warning $[This access control signature is not checked yet] @m.\n\n  // a wildcard in the name is always ok\n  acRuleSignatureOk(_, _, MatchNameWildCard(), _).\n  acRuleSignatureOk(_, _, MatchName(_, WildCardArg()), _).\n\n  acRuleSignatureOk(s, ACTypePage(), MatchName(p, OptWildCardArgNone()), MatchArgs(_, WildCardArg())) :-\n    pageType(s, p) == PAGE(_, _) | error $[Page rule refers to non-existing page [p]] @p. // correct error message for tests\n\n  acRuleSignatureOk(s, ACTypePage(), MatchName(p, OptWildCardArgNone()), MatchArgs(args, OptWildCardArgNone())) :- { argTypes sigTypes }\n    pageType(s, p) == PAGE(_, sigTypes) | error $[Page rule refers to non-existing page [p]] @p, // correct error message for tests\n    typesOfArgs(s, args) == argTypes,\n    argTypes == sigTypes | error $[Argument types [argTypes] are not equal to the page signature types [sigTypes]] @args.\n\n  acRuleSignatureOk(_, ACTypeAction(), _, _).\n\n  acRuleSignatureOk(s, ACTypeTemplate(), MatchName(t, OptWildCardArgNone()), MatchArgs(_, WildCardArg())) :-\n    resolveTemplateNoAjax(s, t) == [_ | _] | error $[Template rule refers to non-existing template [t]. For ajax templates, use 'rule ajaxtemplate'] @t. // correct error message for tests\n\n  acRuleSignatureOk(s, ACTypeTemplate(), MatchName(t, OptWildCardArgNone()), MatchArgs(args, OptWildCardArgNone())) :- { argTypes queryResult ts }\n    argTypes == typesOfArgs(s, args),\n    queryResult@[_ | _] == resolveTemplateNoAjax(s, t) | error $[Template rule refers to non-existing template [t]. For ajax templates, use 'rule ajaxtemplate'] @t, // correct error message for tests\n    ts == queryResultTypes(queryResult),\n    acRuleSignatureArgsMatching(argTypes, ts) | error $[Template rule refers to non-existing template [t] with argument types [argTypes]] @args. // correct error message for tests\n\n  acRuleSignatureOk(s, ACTypeAjaxTemplate(), MatchName(t, OptWildCardArgNone()), MatchArgs(_, WildCardArg())) :-\n    resolveAjaxTemplate(s, t) == [_ | _] | error $[Ajax template rule refers to non-existing template [t]. For non-ajax templates, use 'rule template'] @t. // correct error message for tests\n\n  acRuleSignatureOk(s, ACTypeAjaxTemplate(), MatchName(t, OptWildCardArgNone()), MatchArgs(args, OptWildCardArgNone())) :- { argTypes queryResult ts }\n    argTypes == typesOfArgs(s, args),\n    queryResult@[_ | _] == resolveAjaxTemplate(s, t) | error $[Template rule refers to non-existing template [t]. For non-ajax templates, use 'rule template'] @t, // correct error message for tests\n    ts == queryResultTypes(queryResult),\n    acRuleSignatureArgsMatching(argTypes, ts) | error $[Template rule refers to non-existing template [t] with argument types [argTypes]] @args. // correct error message for tests\n\n  acRuleSignatureOk(s, ACTypePointcut(), MatchName(p, OptWildCardArgNone()), MatchArgs(_, WildCardArg())) :-\n    resolvePointcut(s, p) == [_ | _] | error $[pointcut [p] does not exist] @p. // correct error message for tests\n\n  acRuleSignatureOk(s, ACTypePointcut(), MatchName(p, OptWildCardArgNone()), MatchArgs(args, OptWildCardArgNone())) :- { argTypes queryResult ts }\n    argTypes == typesOfArgs(s, args),\n    queryResult@[_ | _] == resolvePointcut(s, p) | error $[pointcut [p] does not exist] @p, // correct error message for tests\n    ts == queryResultTypes(queryResult),\n    acRuleSignatureArgsMatching(argTypes, ts) | error $[Pointcut rule refers to non-existing pointcut [p] with argumnent types [argTypes]] @args. // correct error message for tests\n\n  acRuleSignatureArgsMatching : list(TYPE) * list(TYPE)\n  acRuleSignatureArgsMatching(_, []) :- false.\n  acRuleSignatureArgsMatching(args, [TEMPLATE(_, args, _) | _]).\n  acRuleSignatureArgsMatching(args, [POINTCUT(_, args) | _]).\n  acRuleSignatureArgsMatching(args, [_ | ts]) :- acRuleSignatureArgsMatching(args, ts).\n\nrules // predicates\n\n  defOk(s, Predicate(p, args, exp)) :- predicateOk(s, p, args, exp, TRUE()).\n  acDefOk(s, PredicateAc(p, args, exp)) :- predicateOk(s, p, args, exp, TRUE()).\n  declEntityBodyDeclaration(s, _, PredicateInEntity(p, args, exp)) :- predicateOk(s, p, args, exp, FALSE()).\n\n  // last bool denotes if predicate is declared in global scope\n  predicateOk : scope * string * OptFormalArgs * Exp * BOOL\n  predicateOk(s, p, FormalArgs(args), exp, global) :- { bool s_predicate argTypes principalType }\n    bool == bool(s),\n    new s_predicate, s_predicate -F-&gt; s,\n    argTypes == typesOfArgs(s, args),\n    declareParameters(s_predicate, zipArgTypes(args, argTypes)),\n    principalType == principalType(s) | error $[Cannot have access control rules without a principal declaration] @p, // correct error message for tests\n    declareVar(s_predicate, \"principal\", principalType),\n    declareVar(s_predicate, \"loggedIn\", bool),\n    equalType(typeOfExp(s_predicate, exp), bool) | error $[Predicate should contain a Bool expression] @exp, // correct error message for tests\n    declPredicate(s, p, FUNCTION_ORIGIN(args), argTypes, bool, global).\n\n  // last bool arg denotes if the scope is global\n  declPredicate : scope * string * ORIGIN * list(TYPE) * TYPE * BOOL\n  declPredicate(s, p, origin, argTypes, return, TRUE()) :- declFunctionGlobal(s, p, origin, argTypes, return).\n  declPredicate(s, p, origin, argTypes, return, FALSE()) :- declFunctionEntity(s, p, origin, argTypes, return, FALSE()).\n\nrules // pointcuts\n\n  acDefOk(s, AccessControlPointcut(p, fargs, elems)) :- { ts s_pointcut }\n    ts == typesOfArgs(s, fargs),\n    declarePointcut(s, p, ts),\n    new s_pointcut,\n    declareParameters(s_pointcut, zipArgTypes(fargs, ts)),\n    acPointcutElemsOk(s, s_pointcut, argNames(fargs), ts, elems).\n\n  acPointcutElemsOk maps acPointcutElemOk(*, *, *, *, list(*))\n  acPointcutElemOk : scope * scope * list(string) * list(TYPE) * AccessControlPointcutElement\n  acPointcutElemOk(s, s_pointcut, pointcutArgNames, ts, elem@AccessControlPointcutElement(_, _, args, _)) :-\n    acPointcutElementDefined(s, s_pointcut, elem),\n    pointcutArgsUsed(pointcutArgNames, args, elem).\n//    sameElements(pointcutArgNames, args) | error $[Pointcut element must use all pointcut arguments: [pointcutArgNames]] @elem.\n\n  acPointcutElementDefined : scope * scope * AccessControlPointcutElement\n  acPointcutElementDefined(_, _, AccessControlPointcutElement(_, MatchName(p, WildCardArg()), _, _)).\n  acPointcutElementDefined(_, _, AccessControlPointcutElement(t, _, _, _)) :-\n    false | error $[Only pages, templates, ajaxtemplates and actions are supported in pointcuts] @t.\n\n  acPointcutElementDefined(s, s_pointcut, elem@AccessControlPointcutElement(ACTypePage(), MatchName(p, _), args, optWc)) :- { ts argTypes }\n    argTypes == typesOfPointcutIdentifiers(s_pointcut, args),\n    resolvePage(s, p) == [(_, (_, PAGE(_, ts)))] | error $[Page rule refers to non-existing page [p]] @p, // correct error message for tests\n    acPointcutElementArgsCompatible(argTypes, ts, optWc) | error $[Incompatible argument types for page [p]] @elem.\n\n  acPointcutElementDefined(s, s_pointcut, elem@AccessControlPointcutElement(ACTypeTemplate(), MatchName(t, _), args, optWc)) :- { ts argTypes }\n    argTypes == typesOfPointcutIdentifiers(s_pointcut, args),\n    resolveTemplateNoAjax(s, t) == [(_, (_, TEMPLATE(_, ts, _)))] | error $[Template rule refers to non-existing template [t]] @t, // correct error message for tests\n    acPointcutElementArgsCompatible(argTypes, ts, optWc) | error $[Template rule refers to non-existing template [t] for the given argument types] @elem. // correct error message for tests\n\n  acPointcutElementDefined(s, s_pointcut, elem@AccessControlPointcutElement(ACTypeAjaxTemplate(), MatchName(t, _), args, optWc)) :- { ts argTypes }\n    argTypes == typesOfPointcutIdentifiers(s_pointcut, args),\n    resolveAjaxTemplate(s, t) == [(_, (_, TEMPLATE(_, ts, _)))] | error $[Ajax template rule refers to non-existing template [t]] @t, // correct error message for tests\n    acPointcutElementArgsCompatible(argTypes, ts, optWc) | error $[Ajax template rule refers to non-existing template [t] for the given argument types] @elem. // correct error message for tests\n\n  acPointcutElementDefined(_, _, elem@AccessControlPointcutElement(ACTypeAction(), _, _, _)).\n\n  acPointcutElementArgsCompatible : list(TYPE) * list(TYPE) * OptWildCardArg\n  acPointcutElementArgsCompatible([], [], _).\n  acPointcutElementArgsCompatible([], [_ | _], WildCardArg()).\n  acPointcutElementArgsCompatible([], [_ | _], OptWildCardArgNone()) :- false.\n  acPointcutElementArgsCompatible([_ | _], [], _) :- false.\n  acPointcutElementArgsCompatible([t1 | t1s], [t2 | t2s], optWc) :-\n    typeCompatible(t1, t2),\n    acPointcutElementArgsCompatible(t1s, t2s, optWc).\n\nrules // utils\n\n  principalPropertyTypes maps principalPropertyType(*, list(*), *) = list(*)\n  principalPropertyType : scope * string * string -&gt; TYPE\n  principalPropertyType(s, x, ent) = t :-\n    t == propertyType(s, x) | error $[[x] is not a property of entity [ent]]. // correct error message for tests\n  principalPropertyType(s, x@\"name\", ent) = t :-\n    t == propertyType(s, x) | error $[Principal credential type [ent] does not have a [x] property, a property with [x] annotation is not sufficient for use as credential]. // correct error message for tests\n\n  principalDefined : scope\n  principalDefined(s) :- { t }\n    principalType(s) == t | error $[Principal is not defined].\n\n  principalType : scope -&gt; TYPE\n  principalType(s) = t :- { s_securityContext }\n    resolveType(s, \"securityContext\") == [(_, (_, ENTITY(_, s_securityContext)))] | error $[securityContext not defined],\n    resolveProperty(s_securityContext, \"principal\") == [(_, (_, t))]. // no fixed error message here to allow more specific error messages on higher predicates\n\n  credentialTypes : scope -&gt; list(TYPE)\n  credentialTypes(s) = ts :- { s_securityContext result }\n    resolveType(s, \"securityContext\") == [(_, (_, ENTITY(_, s_securityContext)))] | error $[securityContext not defined],\n    queryResultTypes(resolveProperty(s_securityContext, \"_credentials\")) == result,\n    result == [CREDENTIALS(ts) | _] | error $[No credentials have been defined].\n\n  typesOfPointcutIdentifiers maps typesOfPointcutIdentifier(*, list(*)) = list(*)\n  typesOfPointcutIdentifier : scope * string -&gt; TYPE\n  typesOfPointcutIdentifier(s, x) = t :-\n    resolveVar(s, x) == [(_, (_, t))] | error $[Pointcut element uses unknown identifier [x]]. // correct error message for tests\n\n  pointcutArgsUsed maps pointcutArgUsed(list(*), *, *)\n  pointcutArgUsed : string * list(string) * AccessControlPointcutElement\n  pointcutArgUsed(x, [], loc) :- false | error $[Pointcut element must use pointcut argument [x]] @loc. // correct error message for tests\n  pointcutArgUsed(x, [x | _], _).\n  pointcutArgUsed(x, [_ | ys], loc) :- pointcutArgUsed(x, ys, loc).\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/webdsl-ac.stx/#modal-h2","title":"webdsl-ac.stx","text":""},{"location":"webdslstatix/trans/static-semantics/webdsl-actions.stx/","title":"<code>webdsl-actions.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/webdsl-actions.stx</p> <pre><code>module static-semantics/webdsl-actions\n\nimports\n  static-semantics/actions/binops\n  static-semantics/actions/built-ins\n  static-semantics/actions/emails\n  static-semantics/actions/functions\n\n  static-semantics/entities/annotations\n\n  static-semantics/types/built-ins\n\n  static-semantics/webdsl-entities\n  static-semantics/webdsl-types\n  static-semantics/webdsl\n\nrules // definitions\n\n  defOk(s, GlobalInit(Block(stmts))) :- {s_init}\n    new s_init, s_init -DEF-&gt; s,\n    stmtsOk(s_init, stmts, VOID()).\n\nrules // unimplemented\n\n  stmtOk(_, _, CaseStmt(_, _), _) :- try { false } | warning $[This statement is not yet implemented].\n  stmtOk(_, _, TypeCaseStmt(_, _, _), _) :- try { false } | warning $[This statement is not yet implemented].\n  stmtOk(_, _, ThrowStatement(_), _) :- try { false } | warning $[This statement is not yet implemented].\n  stmtOk(_, _, TryStatement(_, _), _) :- try { false } | warning $[This statement is not yet implemented].\n  stmtOk(_, _, PrefetchForStmt(_, _, _, _), _) :- try { false } | warning $[This statement is not yet implemented].\n\n  typeOfExp(_, exp@FunctionExp(_, _, _)) = UNTYPED() :- try { false } | warning $[Typing of expression [exp] is not yet implemented].\n  typeOfExp(_, exp@FunctionRef(_, _, _)) = UNTYPED() :- try { false } | warning $[Typing of expression [exp] is not yet implemented].\n  typeOfExp(_, exp@FunctionRefCall(_, _, _, _)) = UNTYPED() :- try { false } | warning $[Typing of expression [exp] is not yet implemented].\n  typeOfExp(_, exp@FunctionRefCallPartial(_, _, _, _)) = UNTYPED() :- try { false } | warning $[Typing of expression [exp] is not yet implemented].\n  typeOfExp(_, exp@MapCreation(_)) = UNTYPED() :- try { false } | warning $[Typing of expression [exp] is not yet implemented].\n  typeOfExp(_, exp@RenderEmailFunctionCall(_)) = UNTYPED() :- try { false } | warning $[Typing of expression [exp] is not yet implemented].\n  typeOfExp(_, exp@EmailFunctionCall(_)) = UNTYPED() :- try { false } | warning $[Typing of expression [exp] is not yet implemented].\n\n\nrules // variable declaration and assignment\n\n  stmtOk(s, _, Stat(exp), _) :-\n    expOk(s, exp).\n\n  stmtOk(s, _, Block2Statement(Block(stmts)), rt) :- { s_new }\n    new s_new, s_new -P-&gt; s,\n    stmtsOk(s_new, stmts, rt).\n\n  stmtOk(s, s_decl, VarDecl(x, sort), _) :- { t }\n    t == typeOfSort(s, sort),\n    inequalType(t, UNTYPED()) | error $[Unknown type [sort]] @sort,\n    declareVar(s_decl, x, t),\n    @x.type := t.\n\n  stmtOk(s, s_decl, VarDeclInit(x, sort, exp), _) :- { t expType }\n    t == typeOfSort(s, sort),\n    expType == typeOfExp(s, exp),\n    typeCompatible(expType, t) | error $[Expression [exp] is not of type [sort], got type [expType]] @exp,\n    declareVar(s_decl, x, t),\n    @x.type := t.\n\n  stmtOk(s, s_decl, VarDeclInitInferred(x, exp), _) :- { t }\n    t == typeOfExp(s, exp),\n    inequalType(t, UNTYPED()) | error $[Unable to infer type of [exp]] @exp,\n    declareVar(s_decl, x, t),\n    @x.type := t.\n\n  defOk(s, GlobalVarDecl(x, sort)) :- { t }\n    t == typeOfSort(s, sort),\n    declareVar(s, x, t),\n    declareAnnotation(s, x, DERIVED()).\n\n  defOk(s, GlobalVarDeclInit(x, sort, exp)) :- { t expType }\n    t == typeOfSort(s, sort),\n    expType == typeOfExp(s, exp),\n    typeCompatible(expType, t) | error $[Expression [exp] is not of type [sort], got type [expType]] @exp,\n    declareVar(s, x, t),\n    declareAnnotation(s, x, DERIVED()).\n\n  defOk(s, GlobalVarDeclInitInferred(x, exp)) :- { t }\n    t == typeOfExp(s, exp),\n    inequalType(t, UNTYPED()) | error $[Cannot resolve type of expression [exp]],\n    declareVar(s, x, t),\n    declareAnnotation(s, x, DERIVED()).\n\n  noDuplicateVarDefs : scope * string\n  noDuplicateVarDefs(s, x) :-\n    query var filter P*\n              and { x' :- x' == (x, _) }\n              in s |-&gt; [_].\n\n  noDuplicateVarDefsInSuper : scope * string\n  noDuplicateVarDefsInSuper(_, \"this\"). // allow \"this\" var to be redefined in sub\n  noDuplicateVarDefsInSuper(_, \"super\"). // allow \"super\" var to be redefined in sub\n  noDuplicateVarDefsInSuper(s_sub, x) :- { xs nonOverridable }\n    resolveProperty(s_sub, x) == xs,\n    withoutAnnotation(xs, OVERRIDABLE()) == nonOverridable,\n    amountNonOverridableOk(nonOverridable).\n\n  amountNonOverridableOk : list((path * (string * TYPE)))\n  amountNonOverridableOk(_) :- false.\n  amountNonOverridableOk([]).\n  amountNonOverridableOk([_]).\n\n  stmtOk(s, _, Assignment(_, exp), _) :- false | error $[Can only assign to fields or vars (except global or session vars)]. // correct error message for tests\n  stmtOk(s, _, Assignment(v@Var(x), exp), _) :- { t expType }\n    variableType(s, x) == t,\n    isMutableOrRef(s, x, t),\n    expType == typeOfExp(s, exp),\n    typeCompatible(expType, t) | error $[Expression [exp] is not of type [t], got type [expType]],\n    @v.type := t.\n\n  isMutableOrRef : scope * string * TYPE\n  isMutableOrRef(s, x, t) :-\n    or(\n      isMutableB(s, x),\n      isRef(t)\n    ) | error $[Variable [x] is not mutable] @x.\n\n  isRef : TYPE -&gt; BOOL\n  isRef(REF(_)) = TRUE().\n  isRef(_) = FALSE().\n\n  stmtOk(s, _, Assignment(FieldAccess(v@FAVar(var), x), exp), _) :- { varType t expType }\n    varType == variableType(s, var),\n    @v.type := varType,\n    t == typeOfProperty(s, varType, x),\n    @x.type := t,\n    isMutableProperty(varType, x),\n    expType == typeOfExp(s, exp),\n    typeCompatible(expType, t) | error $[Expression [exp] is not of type [t], got type [expType]].\n\n  stmtOk(s, _, Assignment(FieldAccess(FAExp(lhexp), x), rhexp), _) :- { lhExpType t rhExpType }\n    lhExpType == typeOfExp(s, lhexp),\n    t == typeOfProperty(s, lhExpType, x),\n    @x.type := t,\n    isMutableProperty(lhExpType, x),\n    rhExpType == typeOfExp(s, rhexp),\n    typeCompatible(rhExpType, t) | error $[Expression [rhexp] is incompatible with type in left-hand side [t], got type [rhExpType]]. // correct error message for tests\n\n  stmtOk(s, _, Assignment(ci@CollectionIndex(_, _), exp), _) :-\n    typeCompatible(typeOfExp(s, exp), typeOfExp(s, ci)) | error $[Expression [exp] is incompatible with type in left-hand side]. // correct error message for tests\n\n  stmtOk(s, _, Assignment(c@Cast(_, _), exp), _) :-\n    typeCompatible(typeOfExp(s, exp), typeOfExp(s, c)).\n\nrules // if statements and expressions\n\n  stmtOk(s, _, If(c, Block(then), Block(else)), rt) :- {s_then s_else}\n    equalType(typeOfExp(s, c), bool(s)) | error $[Condition should be of type bool] @c,\n    new s_then, s_then -P-&gt; s,\n    stmtsOk(s_then, then, rt),\n    new s_else, s_else -P-&gt; s,\n    stmtsOk(s_else, else, rt).\n\n  typeOfExp(s, IfExp(ce, ie, ee)) = it :- {et ct}\n    ct == typeOfExp(s, ce),\n    equalType(ct, bool(s)) | error $[Condition should be of type bool, [ct] given],\n    it == typeOfExp(s, ie),\n    et == typeOfExp(s, ee),\n    typeCompatible(et, it) | error $[Type of else-expression ([et]) should be compatible with type of if-expression ([it])].\n\nrules // loops\n\n  stmtOk(s, _, ForStmt(x, srt, exp, OptFilterSome(f), Block(stmts)), rt) :- {s_for typeOfSort typeOfExp}\n    typeOfSort == typeOfSort(s, srt),\n    typeOfExp == typeOfExp(s, exp),\n    or(\n      equalTypeB(LIST(typeOfSort), typeOfExp),\n      equalTypeB(SET(typeOfSort), typeOfExp)\n    ) | error $[Must be a list or set of type [typeOfSort], [typeOfExp] given] @exp,\n    new s_for, s_for -P-&gt; s,\n    forLoopFilterOk(s_for, f),\n    forLoopStmtsOk(s_for, x, typeOfSort, stmts, rt),\n    @x.type := typeOfSort.\n\n  stmtOk(s, _, ForStmtInferred(x, exp, OptFilterSome(f), Block(stmts)), rt) :- {s_for typeOfExp t}\n    typeOfExp == typeOfExp(s, exp),\n    t == stripGenericType(typeOfExp),\n    new s_for, s_for -P-&gt; s,\n    forLoopFilterOk(s_for, f),\n    forLoopStmtsOk(s_for, x, t, stmts, rt),\n    @x.type := t.\n\n  stmtOk(s, _, ForAllStmt(x, srt, OptFilterSome(f), Block(stmts)), rt) :- {s_for typeOfSort}\n    typeOfSort == typeOfSort(s, srt),\n    new s_for, s_for -P-&gt; s,\n    forLoopFilterOk(s_for, f),\n    forLoopStmtsOk(s_for, x, typeOfSort, stmts, rt),\n    @x.type := typeOfSort.\n\n  stmtOk(s, _, ForCountStmt(x, fromExp, toExp, Block(stmts)), rt) :- {s_for intType}\n    intType == int(s),\n    equalType(typeOfExp(s, fromExp), intType) | error $[From expression should have type Int],\n    equalType(typeOfExp(s, toExp)  , intType) | error $[To expression should have type Int],\n    new s_for, s_for -P-&gt; s,\n    forLoopStmtsOk(s_for, x, intType, stmts, rt),\n    @x.type := intType.\n\n  forLoopStmtsOk : scope * string * TYPE * list(Statement) * TYPE\n  forLoopStmtsOk(s_for, x, t, stmts, rt) :-\n    declareVar(s_for, x, t),\n    declareAnnotation(s_for, x, DERIVED()), // abuse derived annotation to declare immutability of x\n    stmtsOk(s_for, stmts, rt).\n\n  forLoopFilterOk : scope * Filter\n  forLoopFilterOk(s, f). // TO-DO\n\n  stmtOk(s, _, WhileStmt(exp, Block(stmts)), rt) :- {s_while}\n    equalType(typeOfExp(s, exp), bool(s)) | error $[Condition should be of type bool] @exp,\n    new s_while, s_while -P-&gt; s,\n    stmtsOk(s_while, stmts, rt).\n\nrules // return statements\n\n  stmtOk(s, _, r@Return(exp), returnType) :- {returnExpType}\n    inequalType(returnType, UNTYPED()) | error $[Return statement not allowed here] @r,\n    inequalType(returnType, VOID()) | error $[No return type specified in this context] @exp,\n    returnExpType == typeOfExp(s, exp),\n    typeCompatible(returnExpType, returnType) | error $[Must return an expression of type [returnType], [returnExpType] given] @exp.\n\n  stmtOk(s, _, r@ReturnEmpty(), returnType) :-\n    inequalType(returnType, UNTYPED()) | error $[Return statement not allowed here] @r,\n    equalType(returnType, VOID()) | error $[Must return an expression of type [returnType]] @r.\n\nrules // variable references\n\n  typeOfExp(s, Var(x)) = t :-\n    variableType(s, x) == t,\n    @x.type := t.\n\n  typeOfSimpleExp(s, SimpleVar(x)) = t :-\n    variableType(s, x) == t,\n    @x.type := t.\n\n  typeOfExp(s, FieldAccess(FAGlobal(), _)) = UNTYPED() :- try { false } | warning $[Typing of global field access not yet implemented].\n  typeOfExp(s, FieldAccess(FASession(), _)) = UNTYPED() :- try { false } | warning $[Typing of global field access not yet implemented].\n\n  typeOfExp(s, FieldAccess(FAVar(var), x)) = propertyType :- {varType}\n    variableType(s, var) == varType,\n    @var.type := varType,\n    typeOfProperty(s, varType, x) == propertyType,\n    @x.type := propertyType.\n\n  typeOfExp(s, FieldAccess(FAExp(exp), x)) = propertyType :- {t}\n    typeOfExp(s, exp) == t,\n    typeOfProperty(s, t, x) == propertyType,\n    @x.type := propertyType.\n\n  typeOfSimpleExp(s, SimpleFieldAccess(exp, x)) = propertyType :- {t}\n    typeOfSimpleExp(s, exp) == t,\n    typeOfProperty(s, t, x) == propertyType,\n    @x.type := propertyType.\n\n  typeOfPlaceholderExp(s, PHFieldAccess(exp, x)) = propertyType :- {t}\n    typeOfExp(s, exp) == t,\n    typeOfProperty(s, t, x) == propertyType,\n    @x.type := propertyType.\n\n  typeOfProperty : scope * TYPE * string -&gt; TYPE\n  typeOfProperty(_, t, _) = UNTYPED() :- false | error $[Field access is only allowed on native classes and entities, [t] given].\n  typeOfProperty(s, REF(t), x) = typeOfProperty(s, t, x).\n  typeOfProperty(_, ENTITY(_, s), x) = t :-\n    propertyType(s, x) == t.\n  typeOfProperty(_, NATIVECLASS(_, s), x) = t :-\n    propertyType(s, x) == t.\n\nrules // lists and sets\n\n  typeOfExp(s, ListCreation([])) = UNTYPED() :- false | error $[Type cannot be determined for empty untyped list creation].\n  typeOfExp(s, lc@ListCreation([hd | tl])) = LIST(t) :-\n    t == typeOfExp(s, hd), // first element of the untyped list creation determines the type\n    typesCompatibleWith(typesOfExps(s, tl), t) | error $[Not all elements are compatible with type [t]] @tl,\n    @lc.type := LIST(t).\n\n  typeOfExp(s, tlc@TypedListCreation(sort, exps)) = LIST(t) :-\n    typeOfSort(s, sort) == t,\n    typesCompatibleWith(typesOfExps(s, exps), t) | error $[Not all elements are compatible with type [t]] @exps,\n    @tlc.type := LIST(t).\n\n  typeOfExp(s, SetCreation([])) = UNTYPED() :- false | error $[Type cannot be determined for empty untyped set creation].\n  typeOfExp(s, sc@SetCreation([hd | tl])) = SET(t) :-\n    t == typeOfExp(s, hd), // first element of the untyped set creation determines the type\n    typesCompatibleWith(typesOfExps(s, tl), t) | error $[Not all elements are compatible with type [t]] @tl,\n    @sc.type := SET(t).\n\n  typeOfExp(s, tsc@TypedSetCreation(sort, exps)) = SET(t) :-\n    typeOfSort(s, sort) == t,\n    typesCompatibleWith(typesOfExps(s, exps), t) | error $[Not all elements are compatible with type [t]] @exps,\n    @tsc.type := SET(t).\n\n  typeOfExp(s, ci@CollectionIndex(c, x)) = t :-\n    t == typeOfCollectionIndex(s, c, x),\n    @ci.type := t.\n\n  typeOfPlaceholderExp(s, ci@PHCollectionIndex(c, x)) = t :-\n    t == typeOfCollectionIndex(s, c, x),\n    @ci.type := t.\n\n  typeOfCollectionIndex : scope * Exp * Exp -&gt; TYPE\n  typeOfCollectionIndex(s, c, x) = t :- {ct xt}\n    ct == typeOfExp(s, c),\n    xt == typeOfExp(s, x),\n    indexedAccessAllowed(ct),\n    typeCompatible(xt, int(s)) | error $[Index must be of type Int, [xt] given], // correct error message for tests\n    t == stripGenericType(ct).\n\n  indexedAccessAllowed : TYPE\n  indexedAccessAllowed(_).\n  indexedAccessAllowed(SET(_)) :- false | error $[Indexed access \\[\\] is only allowed for List&lt;type&gt; and Set&lt;type&gt;].\n\n  typeOfExp(s, ForExp2Exp(forExp)) = typeOfForExp(s, forExp).\n\n  typeOfExp(s, OrForExp(forExp)) = bool :-\n    bool == bool(s),\n    typeOfForExp(s, forExp) == LIST(bool).\n\n  typeOfExp(s, AndForExp(forExp)) = bool :-\n    bool == bool(s),\n    typeOfForExp(s, forExp) == LIST(bool).\n\nrules // list comprehension\n\n  typeOfForExp : scope * ForExp -&gt; TYPE\n  typeOfForExp(s, ForExpInferred(e1, x, e2, _, _)) = LIST(t) :- { s_e1 collectionType varType }\n    new s_e1, s_e1 -P-&gt; s,\n    collectionType == typeOfExp(s, e2),\n    varType == stripGenericType(collectionType),\n    declareVar(s_e1, x, varType),\n    t == typeOfExp(s_e1, e1),\n    @x.type := varType.\n    // TO-DO: implement filter and group by typechecking\n\n  typeOfForExp(s, ForExp(e1, x, sort, e2, _, _)) = LIST(t) :- { s_e1 collectionType varType }\n    new s_e1, s_e1 -P-&gt; s,\n    collectionType == typeOfExp(s, e2),\n    varType == stripGenericType(collectionType),\n    stripGenericType(collectionType) == typeOfSort(s, sort) | error $[\"type of [e2] is not a collection of type [sort]\"],\n    declareVar(s_e1, x, varType),\n    t == typeOfExp(s_e1, e1).\n    // TO-DO: implement filter and group by typechecking\n\nrules // test\n\n  defOk(s, Test(_, Block(stmts))) :- {s_test}\n    new s_test, s_test -F-&gt; s,\n    stmtsOk(s_test, stmts, UNTYPED()).\n\nrules // misc\n\n  stmtOk(s, _, ValidateStatement(validateExp, messageExp), _) :- validateOk(s, validateExp, messageExp).\n  stmtOk(s, _, NamedValidateStatement(_, validateExp, messageExp), _) :- validateOk(s, validateExp, messageExp).\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/webdsl-actions.stx/#modal-h2","title":"webdsl-actions.stx","text":""},{"location":"webdslstatix/trans/static-semantics/webdsl-built-ins.stx/","title":"<code>webdsl-built-ins.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/webdsl-built-ins.stx</p> <pre><code>module static-semantics/webdsl-built-ins\n\nimports\n  static-semantics/actions/functions\n\n  static-semantics/webdsl\n\nrules\n\n  declareBuiltInFunction : scope * string * list(TYPE) * TYPE\n  declareBuiltInFunction(s, f, args, return) :- declareFunction(s, f, BUILTIN_ORIGIN(args), args, return).\n\n  declBuiltInFunctionEntity : scope * string * list(TYPE) * TYPE * BOOL\n  declBuiltInFunctionEntity(s, f, args, return, static) :-\n    declFunctionEntity(s, f, BUILTIN_ORIGIN(args), args, return, static).\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/webdsl-built-ins.stx/#modal-h2","title":"webdsl-built-ins.stx","text":""},{"location":"webdslstatix/trans/static-semantics/webdsl-entities.stx/","title":"<code>webdsl-entities.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/webdsl-entities.stx</p> <pre><code>module static-semantics/webdsl-entities\n\nimports\n  static-semantics/actions/functions\n\n  static-semantics/entities/annotations\n  static-semantics/entities/built-ins\n  static-semantics/entities/generated-functions\n\n  static-semantics/types/built-ins\n\n  static-semantics/webdsl-actions\n  static-semantics/webdsl-types\n  static-semantics/webdsl\n\nrules // unimplemented\n\n  stmtOk(_, _, ForeachStatementEntityDerive(_, _), _) :- try { false } | warning $[This statement is not yet implemented].\n\nrules // entity declaration\n\n  // entity x : super { ... }\n  defOk(s, e@Entity(x, super, bodydecs)) :- {s_entity super' s_super superType }\n    resolveType(s, super) == [(_, (super', superType@ENTITY(_, s_super)))] | error $[Entity [super] is not defined] @super,\n    new s_entity, s_entity -INHERIT-&gt; s_super, s_entity -DEF-&gt; s,\n    noCircularInheritance(s_entity) | error $[Circular inhertitance detected] @e,\n    declEntity(s, s_entity, x, bodydecs),\n    declareVar(s, x, STATICENTITY(x, s_entity)), // declare entity_name as global variable that refers to the static scope\n    declSuperVar(s_entity, superType),\n    declareEntityAnnotation(s_entity, SUBENTITY()),\n    @super.ref := super'.\n\n  // entity x { ... }\n  defOk(s, EntityNoSuper(x, bodydecs)) :- {s_entity s_super}\n    entity(s) == ENTITY(_, s_super),\n    new s_entity, s_entity -INHERIT-&gt; s_super, s_entity -DEF-&gt; s,\n    declEntity(s, s_entity, x, bodydecs),\n    declareVar(s, x, STATICENTITY(x, s_entity)). // declare entity_name as global variable that refers to the static scope\n\n  // session x { ... }\n  defOk(s, SessionEntity(x, bodydecs)) :- {s_entity}\n    new s_entity, s_entity -DEF-&gt; s,\n    declEntity(s, s_entity, x, bodydecs),\n    declareVar(s, x, ENTITY(x, s_entity)), // session entities only have one instance and don't have a static scope\n    declareEntityAnnotation(s_entity, SESSIONENTITY()).\n\n  declEntity : scope * scope * string * list(EntityBodyDeclaration)\n  declEntity(s, s_entity, entity_name, bodydecs) :- { entityType }\n    declareExtendScope(s, entity_name, s_entity), // declare entity_scope to be linked to entity_name\n    extendScopes(resolveExtendScope(s, entity_name), s_entity),\n    entityType == ENTITY(entity_name, s_entity),\n    declareType(s, entity_name, entityType),\n    declThisVar(s_entity, entityType),\n    declEntityBody(s_entity, entity_name, bodydecs).\n\n  extendScopes maps extendScope(list(*), *)\n  extendScope : (path * (string * scope)) * scope\n  extendScope((_, (_, s)), s). // Do not inherit own scope\n  extendScope((_, (_, s')), s) :-\n    s -EXTEND-&gt; s'.\n\n  // extend entity x { ... }\n  defOk(s_global, ExtendEntity(x, bodydecs)) :- declExtendEntity(s_global, x, bodydecs).\n\n  // extend session { ... }\n  defOk(s_global, ExtendSessionEntity(x, bodydecs)) :- declExtendEntity(s_global, x, bodydecs).\n\n  declExtendEntity : scope * string * list(EntityBodyDeclaration)\n  declExtendEntity(s, entity_name, bodydecs) :- {s_extend_entity entity_scopes}\n    resolveType(s, entity_name) == [(_, (_, ENTITY(_, _)))] | error $[Entity [entity_name] is not defined],\n    new s_extend_entity, s_extend_entity -DEF-&gt; s,\n    declareExtendScope(s, entity_name, s_extend_entity), // declare entity_scope to be linked to entity_name\n    extendScopes(resolveExtendScope(s, entity_name), s_extend_entity),\n    declEntityBody(s_extend_entity, entity_name, bodydecs).\n\n  noCircularInheritance : scope\n  noCircularInheritance(s_ent) :- {res}\n    query () filter INHERIT+ and { s :- s == s_ent }\n             min $ &lt; INHERIT\n             in s_ent |-&gt; res,\n    res == [].\n\n  declThisVar : scope * TYPE\n  declThisVar(s_ent, t) :-\n    declareVar(s_ent, \"this\", t),\n    declareAnnotation(s_ent, \"this\", DERIVED()). // prevent mutability of this var\n\n  declSuperVar : scope * TYPE\n  declSuperVar(s_ent, t) :-\n    declareVar(s_ent, \"super\", t),\n    declareAnnotation(s_ent, \"super\", DERIVED()). // prevent mutability of super var\n\n  defOk(s, Enum(e, values)) :- { s_entity s_super t }\n    entity(s) == ENTITY(_, s_super),\n    new s_entity, s_entity -INHERIT-&gt; s_super, s_entity -DEF-&gt; s,\n    declareVar(s_entity, \"name\", string(s)),\n    t == ENTITY(e, s_entity),\n    declareType(s, e, t),\n    declareEnumValues(s, values, t).\n\n  declareEnumValues maps declareEnumValue(*, list(*), *)\n  declareEnumValue : scope * EnumValue * TYPE\n  declareEnumValue(s, EnumValue(v, _), t) :- declareVar(s, v, t).\n\nrules // entity body declaration\n\n  declEntityBodyDeclaration : scope * string * EntityBodyDeclaration\n  declEntityBodyDeclaration(_, _, _) :- try { false } | warning $[This entity body declaration is not yet implemented].\n  declEntityBody maps declEntityBodyDeclaration(*, *, list(*))\n\n  // entity function\n  declEntityBodyDeclaration(s, _, EntityFunction(f)) :- entityFunctionOk(s, f, FALSE()).\n  declEntityBodyDeclaration(s, _, StaticEntityFunction(f)) :- entityFunctionOk(s, f, TRUE()).\n  declEntityBodyDeclaration(s, _, CachedFunction(f)) :-\n    canBeCached(s, f),\n    entityFunctionOk(s, f, FALSE()).\n\n  // entity property\n  declEntityBodyDeclaration(s, ent, Property(x, propkind, sort, PropAnnos(annos))) :- {sortType}\n    sortType == typeOfSort(s, sort),\n    inequalType(sortType, UNTYPED()) | error $[Cannot resolve type [sort]] @sort,\n    inequalType(sortType, VOID()) | error $[Property type 'Void' not allowed] @sort,\n    inequalType(sortType, REF(_)) | error $[Reference type is not allowed in property] @sort,\n    isValidTypeForPropKind(propkind, sort, sortType),\n    declProperty(s, ent, x, sortType),\n    annotationsOk(s, x, sortType, annos).\n\n  // derived entity property\n  declEntityBodyDeclaration(s, ent, DerivedProperty(x, propkind, sort, PropAnnos(annos), exp)) :- { sortType sortTypeString expType }\n    sortType == typeOfSort(s, sort),\n    sortTypeString == ppType(sortType),\n    expType == typeOfExp(s, exp),\n    typeCompatible(expType, sortType) | error $[The expression of the derived property [x] should have type [sortTypeString]] @exp,\n    declProperty(s, ent, x, sortType),\n    declareAnnotation(s, x, DERIVED()),\n    annotationsOk(s, x, sortType, annos).\n\n  declProperties maps declProperty(*, *, list(*), list(*))\n  declProperty : scope * string * string * TYPE\n  declProperty(s, ent, x, sortType) :-\n    validPropertyName(x),\n    declareVar(s, x, sortType),\n    resolveLocalProperty(s, x) == [_] | error $[Property [x] of entity [ent] is defined multiple times] @x,\n    noDuplicateVarDefsInSuper(s, x) | error $[Cannot override existing entity property [x]] @x.\n\n  validPropertyName : string\n  validPropertyName(x) :-\n    x != \"class\" | error $[Cannot use the reserved property name [x]] @x.\n\n  isValidTypeForPropKind : PropKind * Sort * TYPE\n  isValidTypeForPropKind(Simple(), sort, sortType) :-\n    isBuiltInType(sortType) | error $[Expected simple type] @sort.\n\n  isValidTypeForPropKind(Ref(), _, ENTITY(_, _)).\n  isValidTypeForPropKind(Ref(), _, LIST(ENTITY(_, _))).\n  isValidTypeForPropKind(Ref(), _, SET(ENTITY(_, _))).\n  isValidTypeForPropKind(Ref(), sort, _) :-\n    false | error $[Expected: Reference type or Composite type] @sort. // correct error message for tests\n\n  isValidTypeForPropKind(Comp(), _, ENTITY(_, _)).\n  isValidTypeForPropKind(Comp(), _, LIST(ENTITY(_, _))).\n  isValidTypeForPropKind(Comp(), _, SET(ENTITY(_, _))).\n  isValidTypeForPropKind(Comp(), sort, _) :-\n    false | error $[Expected: Reference type or Composite type] @sort. // correct error message for tests\n\n  isValidTypeForPropKind(AnyProp(), _, ENTITY(_, _)).\n  isValidTypeForPropKind(AnyProp(), _, LIST(ENTITY(_, _))).\n  isValidTypeForPropKind(AnyProp(), _, SET(ENTITY(_, _))).\n  isValidTypeForPropKind(AnyProp(), sort, sortType) :-\n    isBuiltInType(sortType) | error $[Expected simple type or entity type or a collection of an entity type] @sort.\n\n  // validation\n  declEntityBodyDeclaration(s, _, ValidateEntity(validateExp, messageExp)) :- validateOk(s, validateExp, messageExp).\n\nrules // entity resolving\n\n  typeOfExp(s, exp@ObjectCreation(x, prop_assignments)) = e :-\n    definedType(s, x) == e,\n    e == ENTITY(_, _),\n    propAssignmentsOk(s, e, prop_assignments),\n    @exp.type := e.\n\n  typeOfThis : scope -&gt; TYPE\n  typeOfThis(s_ent) = t :-\n    resolveVar(s_ent, \"this\") == [(_, (_, t))] | error $[Variable \"this\" not defined].\n\n  typeOfExp(s, This(_)) = typeOfThis(s).\n\n  typeOfProperty(_, _, \"this\") = UNTYPED() :-\n    false | error $[This is only accessible from within the entity].\n\n  // object creation properties\n  propAssignmentsOk maps propAssignmentOk(*, *, list(*))\n  propAssignmentOk : scope * TYPE * PropAssignment\n  propAssignmentOk(_, _, _) :- try { false } | warning $[This property assignment is not yet implemented].\n  propAssignmentOk(s, ent@ENTITY(e, s_ent), PropAssignment(ObjectPropertyAssignment(x, exp))) :- { propType expType }\n    typeOfProperty(s, ent, x) == propType | error $[Entity [e] does not contain a property [x]],\n    isMutable(s_ent, x) | error $[Assignment to derived property is not allowed.], // correct error message for tests\n    typeOfExp(s, exp) == expType,\n    typeCompatible(expType, propType) | error $[Type of expression [expType] is incompatible with type of entity property [propType]].\n\nrules // subtyping\n\n  typeCompatibleB(ENTITY(_, s_sub), ENTITY(_, s_super)) = inherits(s_sub, s_super).\n\n  inherits : scope * scope -&gt; BOOL\n  inherits(s_sub, s_super) = nonEmptyPathScopeList(ps) :-\n    query () filter INHERIT*\n             and { s :- s == s_super }\n             min $ &lt; INHERIT\n             in s_sub |-&gt; ps.\n\n  nonEmptyPathScopeList : list((path * scope)) -&gt; BOOL\n  nonEmptyPathScopeList(_)       = FALSE().\n  nonEmptyPathScopeList([(_,_)]) = TRUE().\n\n  inheritEdgesAmount : scope * scope -&gt; int\n  inheritEdgesAmount(s_sub, s_super) = pathLength(p) :-\n    query () filter INHERIT* and { s :- s == s_super }\n             min $ &lt; INHERIT\n             in s_sub |-&gt; [(p, _)].\n\nrules // extension\n\n  extends : scope * scope -&gt; BOOL\n  extends(s_extending, s) = nonEmptyPathScopeList(ps) :-\n    query () filter EXTEND? (INHERIT EXTEND?)*\n             and { s' :- s' == s }\n             min $ &lt; EXTEND, $ &lt; INHERIT, EXTEND &lt; INHERIT\n             in s_extending |-&gt; ps.\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/webdsl-entities.stx/#modal-h2","title":"webdsl-entities.stx","text":""},{"location":"webdslstatix/trans/static-semantics/webdsl-expand.stx/","title":"<code>webdsl-expand.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/webdsl-expand.stx</p> <pre><code>module static-semantics/webdsl-expand\n\nimports\n  static-semantics/entities/annotations\n\n  static-semantics/types/built-ins\n\n  static-semantics/webdsl\n  static-semantics/webdsl-actions\n  static-semantics/webdsl-types\n  static-semantics/webdsl-ui\n\nrules  // unimplemented\n\n  defOk(_, ExpandTemplateCall(_, _)) :- try { false } | warning $[This definition is not yet implemented].\n  defOk(_, ExpandTemplateDefinition(_, _, _)) :- try { false } | warning $[This definition is not yet implemented].\n\n  stmtOk(_, _, StatementExpandLocal(_, _, _), _) :- try { false } | warning $[This statement is not yet implemented].\n\n  typeOfExp(_, exp@ExpExpandLocal(_, _, _)) = UNTYPED() :- try { false } | warning $[Typing of expression [exp] is not yet implemented].\n\nrules\n\n  templateElementOk(s, _, s_pha, DeriveNoFromNoFor(p, body)) :-\n    deriveStringOk(p),\n    deriveBodyOk(s, s_pha, body),\n    false | error $[Cannot derive for non-entity types, use syntax \"derive &lt;pagetype&gt; from &lt;var&gt; { ... }\"].\n\n  templateElementOk(s, _, s_pha, Derive(p, exp, props, body)) :- { t }\n    deriveStringOk(p),\n    t == typeOfExp(s, exp),\n    typeCompatible(t, entity(s)) | error $[Cannot derive for non-entity types] @exp,\n    derivePropertiesOk(s, t, p, props),\n    deriveBodyOk(s, s_pha, body).\n\n  deriveStringOk : string\n  deriveStringOk(_) :- false | error $[Can only derive \"viewPage\", \"createPage\" or \"editPage\"].\n  deriveStringOk(\"viewPage\").\n  deriveStringOk(\"viewRows\").\n  deriveStringOk(\"createPage\").\n  deriveStringOk(\"editPage\").\n  deriveStringOk(\"editRows\").\n  deriveStringOk(\"editRowsInline\").\n\n  derivePropertiesOk maps derivePropertyOk(*, *, *, list(*))\n  derivePropertyOk : scope * TYPE * string * DeriveProperty\n  derivePropertyOk(_, _, _, _) :- try { false } | warning $[This element is not yet supported].\n  derivePropertyOk(s, t_ent, _, DeriveDefault(prop)) :- { entityName t }\n    t_ent == ENTITY(entityName, _),\n    t == typeOfProperty(s, t_ent, prop) | error $[Entity [entityName] has no property [prop]], // correct error message for tests\n    isMutableProperty(t_ent, prop) | error $[Property [prop] is not mutable].\n\n  derivePropertyOk(s, t_ent, \"viewPage\", DeriveDefault(prop)) :- { entityName t }\n    t_ent == ENTITY(entityName, _),\n    t == typeOfProperty(s, t_ent, prop) | error $[Entity [entityName] has no property [prop]]. // correct error message for tests\n\n  derivePropertyOk(s, t_ent, \"viewRows\", DeriveDefault(prop)) :- { entityName t }\n    t_ent == ENTITY(entityName, _),\n    t == typeOfProperty(s, t_ent, prop) | error $[Entity [entityName] has no property [prop]]. // correct error message for tests\n\n  deriveBodyOk : scope * scope * DeriveBody\n  deriveBodyOk(s, s_pha, DeriveBody(elements)) :- deriveBodyElementsOk(s, s_pha, elements).\n\n  deriveBodyElementsOk maps deriveBodyElementOk(*, *, list(*))\n  deriveBodyElementOk : scope * scope * DeriveBodyElement\n  deriveBodyElementOk(_, _, _) :- try { false } | warning $[This element is not yet supported].\n\nrules\n\n  defOk(s, DeriveCrud(ent)) :- { t }\n    t == typeOfSort(s, SimpleSort(ent)) | error $[The entity [ent] does not exist],\n    typeCompatible(t, entity(s)) | error $[The entity [ent] does not exist].\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/webdsl-expand.stx/#modal-h2","title":"webdsl-expand.stx","text":""},{"location":"webdslstatix/trans/static-semantics/webdsl-hql.stx/","title":"<code>webdsl-hql.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/webdsl-hql.stx</p> <pre><code>module static-semantics/webdsl-hql\n\nimports\n  static-semantics/types/built-ins\n\n  static-semantics/webdsl\n  static-semantics/webdsl-actions\n  static-semantics/webdsl-types\n\nrules // unimplemented\n\n  stmtOk(_, _, HqlStatement(_), _) :- try { false } | warning $[This statement is not yet implemented].\n\nrules\n\n  typeOfExp(s, HqlExp(hqlExp)) = typeOfHqlExp(s, hqlExp).\n\n  typeOfHqlExp : scope * HqlExp -&gt; TYPE\n  typeOfHqlExp(s, HqlQuery(queryRule)) = typeOfHqlQueryRule(s, queryRule).\n  typeOfHqlExp(s, HqlQueryLimit(queryRule, limitExp)) = typeOfHqlQueryRule(s, queryRule) :-\n    limitValueExpOk(s, limitExp).\n\n  typeOfHqlExp(s, HqlQueryLimitOffset(queryRule, limitExp, offsetExp)) = typeOfHqlQueryRule(s, queryRule) :-\n    limitValueExpOk(s, limitExp),\n    limitValueExpOk(s, offsetExp).\n\n  typeOfHqlQueryRule : scope * HQLQueryRule -&gt; TYPE\n  typeOfHqlQueryRule(s, QueryRule(SelectFrom(select, from), where, groupBy, orderBy)) = t :- { s_query }\n    new s_query,\n    t == typeOfHqlSelectFrom(s, s_query, select, from),\n    hqlWhereClauseOk(s, s_query, where),\n    hqlGroupByClauseOk(s, s_query, groupBy),\n    hqlOrderByClauseOk(s, s_query, orderBy).\n\n  typeOfHqlSelectFrom : scope * scope * HQLSelectClauseOpt * HQLFromClause -&gt; TYPE\n  typeOfHqlSelectFrom(s, _      , SelectNone()        , from) = typeOfHqlFrom(s, from).\n  typeOfHqlSelectFrom(s, s_query, Select(_, selection), from) = t :-\n    hqlFromClauseOk(s, s_query, from),\n    t == typeOfHqlSelect(s, s_query, selection).\n\n  typeOfHqlSelect : scope * scope * HQLSelection -&gt; TYPE\n  typeOfHqlSelect(s, s_query, SelectedProperties([aliasedExp])) = typeOfHqlAliasedExpression(s, s_query, aliasedExp).\n  typeOfHqlSelect(_, _, ps@SelectedProperties([_ | [_]])) = t :- false | error $[Selecting multiple properties is not allowed] @ps.\n\n  typeOfHqlFrom : scope * HQLFromClause -&gt; TYPE\n  typeOfHqlFrom(s, FromClause([FromRangeJoin(fromRange, _) | _])) = typeOfHqlFromRange(s, fromRange).\n\n  typeOfHqlFromRange : scope * HQLFromRange -&gt; TYPE\n  typeOfHqlFromRange(s, FromClassOrOuterQueryPath(Path([ent]), _, _)) = LIST(t) :-\n    t == definedType(s, ent),\n    t == ENTITY(_, _) | error $[[ent] is not an entity] @ent.\n\n  typeOfHqlAliasedExpression : scope * scope * HQLAliasedExpression -&gt; TYPE\n  typeOfHqlAliasedExpression(s, s_query, AliasedExpression(hqlExp, AsAliasNone())) = typeOfHqlExpression(s, s_query, hqlExp).\n  typeOfHqlAliasedExpression(_, _, AliasedExpression(_, a@AsAlias(_))) = t :- try { false } | warning $[Aliased expressions not yet implemented] @a.\n\n  typeOfHqlExpression : scope * scope * HQLExpression -&gt; TYPE\n  typeOfHqlExpression(_, _, e) = UNTYPED() :- try { false } | warning $[HQL Expression [e] not yet implemented] @e.\n  typeOfHqlExpression(s, s_query, HQLAvg(e)) = float(s) :- { t } t == typeOfHqlExpression(s, s_query, e).\n  typeOfHqlExpression(s, s_query, HQLSum(e)) = int(s) :- { t } t == typeOfHqlExpression(s, s_query, e). // TO-DO: possibly return float instead of int, based on selection\n  typeOfHqlExpression(s, s_query, HQLMin(e)) = int(s) :- { t } t == typeOfHqlExpression(s, s_query, e). // TO-DO: possibly return float instead of int, based on selection\n  typeOfHqlExpression(s, s_query, HQLMax(e)) = int(s) :- { t } t == typeOfHqlExpression(s, s_query, e). // TO-DO: possibly return float instead of int, based on selection\n  typeOfHqlExpression(s, s_query, HQLCountStar()) = int(s).\n  typeOfHqlExpression(s, s_query, HQLCount(e)) = int(s) :- { t } t == typeOfHqlExpression(s, s_query, e).\n  typeOfHqlExpression(_, s_query, HQLPath(Path([p]))) = LIST(t) :- { p' }\n    resolveVar(s_query, p) == [(_, (p', t))] | error $[Cannot resolve [p]],\n    @p.type := t,\n    @p.ref := p'.\n\n  typeOfHqlExpression(s, s_query, HQLPath(Path([ent, prop]))) = LIST(t) :- { ent' entityType }\n    resolveVar(s_query, ent) == [(_, (ent', entityType))] | error $[Cannot resolve [ent]] @ent,\n    t == typeOfProperty(s, entityType, prop),\n    @ent.type := entityType,\n    @ent.ref := ent'.\n\nrules // fill scope graph using HQL From clause\n\n  hqlFromClauseOk : scope * scope * HQLFromClause\n  hqlFromClauseOk(s, s_query, FromClause(fromRangeJoins)) :- hqlFromRangeJoinsOk(s, s_query, fromRangeJoins).\n\n  hqlFromRangeJoinsOk maps hqlFromRangeJoinOk(*, *, list(*))\n  hqlFromRangeJoinOk : scope * scope * HQLFromRangeJoin\n  hqlFromRangeJoinOk(s, s_query, FromRangeJoin(fromRange, joins)) :-\n    hqlFromRangeOk(s, s_query, fromRange),\n    hqlFromJoinsOk(s, s_query, joins).\n\n  hqlFromRangeOk : scope * scope * HQLFromRange\n  hqlFromRangeOk(s, s_query, FromClassOrOuterQueryPath(path, alias, _)) :- { t }\n    t == typeOfHqlFromPath(s, s_query, path),\n    declAlias(s_query, t, alias).\n\n  hqlFromJoinsOk maps hqlFromJoinOk(*, *, list(*))\n  hqlFromJoinOk : scope * scope * HQLFromJoin\n  hqlFromJoinOk(s, s_query, FromJoin(_, _, path, alias, _, _)) :- { t }\n    t == typeOfHqlFromPath(s, s_query, path),\n    declAlias(s_query, t, alias).\n\nrules // where, group by and order by analysis\n\n  hqlWhereClauseOk : scope * scope * HQLWhereClauseOpt\n  hqlWhereClauseOk(_, _, WhereClauseNone()).\n  hqlWhereClauseOk(_, _, w@WhereClause(_)) :- try { false } | warning $[HQL Where clause is not yet implemented] @w.\n\n  hqlGroupByClauseOk : scope * scope * HQLGroupByClauseOpt\n  hqlGroupByClauseOk(_, _, HQLGroupByNone()).\n  hqlGroupByClauseOk(_, _, gb@HQLGroupBy(_, _)) :- try { false } | warning $[HQL Group By clause is not yet implemented] @gb.\n\n  hqlOrderByClauseOk : scope * scope * HQLOrderByClauseOpt\n  hqlOrderByClauseOk(_, _, OrderByClauseNone()).\n  hqlOrderByClauseOk(_, _, ob@OrderByClause(_)) :- try { false } | warning $[HQL Order By clause is not yet implemented] @ob.\n\nrules // misc\n\n  limitValueExpOk : scope * LimitValueExp\n  limitValueExpOk(s, LimitValueExp(exp)) :-\n    typeCompatible(typeOfExp(s, exp), int(s)) | error $[Expression [exp] should be compatible with type Int].\n\n  limitValueExpOk(s, LimitValueDslExp(DslExp(exp))) :-\n    typeCompatible(typeOfExp(s, exp), int(s)) | error $[Expression [exp] should be compatible with type Int].\n\nrules // utils\n\n  declAlias : scope * TYPE * HQLAsAliasOpt\n  declAlias(_, _, AsAliasNone()).\n  declAlias(s_query, t, AsAlias(Alias(a))) :- declareVar(s_query, a, t).\n\n  typeOfHqlFromPath : scope * scope * HQLPath -&gt; TYPE\n  typeOfHqlFromPath(s, _, Path([x])) = t :-\n    t == definedType(s, x)| error $[Cannot resolve [x]] @x,\n    t == ENTITY(_, _) | error $[[x] is not an entity] @x.\n\n  typeOfHqlFromPath(s, s_query, Path([x | tail])) = t :- { x' xType }\n    resolveVar(s_query, x) == [(_, (x', xType))] | error $[Cannot resolve [x]] @x,\n    t == typeOfHqlFromPathTail(s, xType, tail),\n    @x.type := xType,\n    @x.ref := x'.\n\n  typeOfHqlFromPathTail : scope * TYPE * list(string) -&gt; TYPE\n  typeOfHqlFromPathTail(s, entityType, [x]) = t :-\n    t == stripOptionalSetOrListType(typeOfProperty(s, entityType, x)),\n    t == ENTITY(_, _) | error $[Property [x] is not an entity] @x.\n\n  typeOfHqlFromPathTail(s, entityType, [x | tail]) = t :- { xType }\n    xType == stripOptionalSetOrListType(typeOfProperty(s, entityType, x)),\n    xType == ENTITY(_, _) | error $[Property [x] is not an entity] @x,\n    t == typeOfHqlFromPathTail(s, xType, tail).\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/webdsl-hql.stx/#modal-h2","title":"webdsl-hql.stx","text":""},{"location":"webdslstatix/trans/static-semantics/webdsl-modules.stx/","title":"<code>webdsl-modules.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/webdsl-modules.stx</p> <pre><code>module static-semantics/webdsl-modules\n\nimports\n  static-semantics/webdsl-ac\n  static-semantics/webdsl-ui\n  static-semantics/webdsl\n\nsignature\n\n  relations\n\n    library : list(string) * scope\n\nrules // unit rules\n\n  unitOk(s_global, Application(app, sections)) :- { s_mod }\n    new s_mod, s_mod -IMPORT-&gt; s_global, s_global -GLOBAL-&gt; s_mod,\n    declareACBuiltIns(s_global, s_mod),\n    declareMod(s_global, [app], s_mod),\n    importModules(s_global, s_mod, sections),\n    importLibrary(s_global, s_mod, [\"_BUILTIN\"]),\n    sectionsOk(s_mod, sections),\n    rootPageDefined(s_mod, app).\n\n  unitOk(s_global, Module(ModuleName(mps), sections)) :- { s_mod }\n    new s_mod, s_mod -IMPORT-&gt; s_global, s_global -GLOBAL-&gt; s_mod,\n    declareMod(s_global, modulePartsToStrings(mps), s_mod),\n    importModules(s_global, s_mod, sections),\n    importLibrary(s_global, s_mod, [\"_BUILTIN\"]),\n    sectionsOk(s_mod, sections).\n\n  unitOk(s_global, BuiltIn(sections)) :-\n    // only analyze built-in if no library is present\n    builtInOk(s_global, sections, notB(usesBuiltInLibraryB(s_global))).\n\n  unitOk(s_global, BuiltInLibrary(sections)) :-\n    !library[[\"_BUILTIN_LIBRARY\"], new] in s_global,\n    builtInOk(s_global, sections, TRUE()).\n\n  builtInOk : scope * list(Section) * BOOL\n  builtInOk(s_global, sections, FALSE()).\n  builtInOk(s_global, sections, TRUE()) :- { s_mod }\n    new s_mod, s_mod -IMPORT-&gt; s_global, s_global -GLOBAL-&gt; s_mod,\n    declareBuiltIns(s_mod),\n    declareMod(s_global, [\"_BUILTIN\"], s_mod),\n    importModules(s_global, s_mod, sections),\n    sectionsOk(s_mod, sections).\n\nrules // import definition rules\n\n  defOk(_, Imports(_)). // imports are handled in another rule, discard them here\n  defOk(_, ImportsBuiltIn()).\n\n  importModules : scope * scope * list(Section)\n  importModules(_, _, []).\n  importModules(s, s_mod, [_ | ss]) :-\n    importModules(s, s_mod, ss).\n\n  importModules(s, s_mod, [Section(_, defs) | ss]) :-\n    importModulesInSection(s, s_mod, defs),\n    importModules(s, s_mod, ss).\n\n  importModulesInSection : scope * scope * list(Definition)\n  importModulesInSection(_, _, []).\n  importModulesInSection(s, s_mod, [_ | defs]) :- importModulesInSection(s, s_mod, defs).\n  importModulesInSection(s, s_mod, [Imports(ImportName(ModuleName(mps), NoWildcardImport())) | defs]) :-\n    importModule(s, s_mod, modulePartsToStrings(mps)),\n    importModulesInSection(s, s_mod, defs).\n\n  importModule : scope * scope * list(string)\n  importModule(s, s_mod, mps) :- {s_y}\n    resolveMod(s, mps) == [(_, (_, s_y))] | error $[Cannot resolve module [mps]],\n    importModuleScopeIfDeclared(s_mod, s_y, modDeclaredB(resolveMod(s, mps))).\n\n  modDeclaredB : list((path * (list(string) * scope))) -&gt; BOOL\n  modDeclaredB([]) = FALSE().\n  modDeclaredB(_) = TRUE().\n\n  importModuleScopeIfDeclared : scope * scope * BOOL\n  importModuleScopeIfDeclared(s_mod, s_y, TRUE()) :- s_mod -IMPORT-&gt; s_y.\n  importModuleScopeIfDeclared(s_mod, s_mod, TRUE()). // restrict self import\n  importModuleScopeIfDeclared(_, _, FALSE()).\n\n  importModulesInSection(s, s_mod, [i@Imports(ImportName(ModuleName(mps), WildcardImport())) | defs]) :-\n    importModulesWildcard(s_mod, resolveModWildcard(s, modulePartsToStrings(mps)), i),\n    importModulesInSection(s, s_mod, defs).\n\n  importModulesWildcard : scope * list((path * (list(string) * scope))) * Definition\n  importModulesWildcard(_, [], i) :- false | error $[Cannot resolve modules] @i.\n  importModulesWildcard(s_mod, mods, _) :- importModulesWildcard_internal(s_mod, mods).\n\n  importModulesWildcard_internal maps importModuleWildcard_internal(*, list(*))\n  importModuleWildcard_internal : scope * (path * (list(string) * scope))\n  importModuleWildcard_internal(s_mod, (_, (_, s_y))) :- s_mod -IMPORT-&gt; s_y.\n  importModuleWildcard_internal(s_mod, (_, (_, s_mod))). // restrict self import\n\n  importLibrary : scope * scope * list(string)\n  importLibrary(s_global, s_mod, lib) :- { s_lib }\n    resolveMod(s_global, lib) == [(_, (_, s_lib))] | error $[Cannot resolve module [lib]],\n    importLibraryScopeIfDeclared(s_mod, s_lib, modDeclaredB(resolveMod(s_global, lib))).\n\n  importLibraryScopeIfDeclared : scope * scope * BOOL\n  importLibraryScopeIfDeclared(s_mod, s_lib, TRUE()) :- s_mod -IMPORTLIB-&gt; s_lib.\n  importLibraryScopeIfDeclared(s_mod, s_mod, TRUE()). // restrict self import\n  importLibraryScopeIfDeclared(_, _, FALSE()).\n\nrules // utils\n\n  usesBuiltInLibraryB : scope -&gt; BOOL\n  usesBuiltInLibraryB(s_global) = usesLibraryB_internal(ps) :-\n        query library filter e\n          and { m' :- m' == ([\"_BUILTIN_LIBRARY\"], _) }\n          in s_global |-&gt; ps.\n\n  usesLibraryB_internal : list((path * (list(string) * scope))) -&gt; BOOL\n  usesLibraryB_internal([]) = FALSE().\n  usesLibraryB_internal([_ | _]) = TRUE().\n\n  modulePartsToStrings maps modulePartToString(list(*)) = list(*)\n  modulePartToString : ModulePart -&gt; string\n  modulePartToString(ModulePart(s)) = s.\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/webdsl-modules.stx/#modal-h2","title":"webdsl-modules.stx","text":""},{"location":"webdslstatix/trans/static-semantics/webdsl-native.stx/","title":"<code>webdsl-native.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/webdsl-native.stx</p> <pre><code>module static-semantics/webdsl-native\n\nimports\n  static-semantics/actions/functions\n\n  static-semantics/types/built-ins\n\n  static-semantics/webdsl-actions\n  static-semantics/webdsl-entities\n  static-semantics/webdsl-types\n  static-semantics/webdsl\n\nrules // subtype compatiblity\n\n  typeCompatibleB(NATIVECLASS(_, s_sub), NATIVECLASS(_, s_super)) = inherits(s_sub, s_super).\n\n  // two native classes with identical names are compatible due to redefinitions of built-in native classes\n  typeCompatibleB(NATIVECLASS(nc, _), NATIVECLASS(nc, _)) = TRUE().\n\nrules // declarations\n\n  defOk(s, NativeClass(c, NCAlias(alias), NCSuperNone(), elems)) :- { s_super }\n    object(s) == BUILTINTYPE(_, s_super),\n    nativeClassOk(s, c, alias, s_super, elems).\n\n  defOk(s, NativeClass(c, NCAlias(alias), NCSuper(super), elems)) :- { super' superType s_super }\n    resolveType(s, super) == [(_, (super', superType))] | error $[Native class [super] is not defined] @c,\n    s_super == scopeOfNativeClassSuper(superType),\n    nativeClassOk(s, c, alias, s_super, elems),\n    @super.ref := super'.\n\n  scopeOfNativeClassSuper : TYPE -&gt; scope\n  scopeOfNativeClassSuper(t) = new :- false | error $[Native classes cannot extend something of type [t]].\n  scopeOfNativeClassSuper(NATIVECLASS(_, s)) = s.\n  scopeOfNativeClassSuper(BUILTINTYPE(_, s)) = s.\n\n  nativeClassOk : scope * string * string * scope * list(NCElement)\n  nativeClassOk(s, c, alias, s_super, elems) :- { s_class }\n    new s_class, s_class -INHERIT-&gt; s_super, s_class -DEF-&gt; s,\n    declareExtendScope(s, alias, s_class),\n    extendScopes(resolveExtendScope(s, alias), s_class),\n    declareType(s, alias, NATIVECLASS(alias, s_class)),\n    declareVar(s, alias, STATICNATIVECLASS(alias, s_class)), // declare class name as global variable that refers to the static scope\n    noCircularInheritance(s_class) | error $[Circular inhertitance detected] @c,\n    declareNativeClassConstructors(s, s_class, alias, elems),\n    nativeClassElementsOk(s, s_class, elems).\n\nrules // native class extending\n\n  defOk(s, ExtendNativeClass(c, NCAlias(alias), elems)) :- { s_extend_class class_scopes }\n    resolveType(s, alias) == [(_, (_, NATIVECLASS(_, _)))] | error $[Native class [alias] is not defined],\n    new s_extend_class, s_extend_class -DEF-&gt; s,\n    declareExtendScope(s, alias, s_extend_class), // declare entity_scope to be linked to entity_name\n    extendScopes(resolveExtendScope(s, alias), s_extend_class),\n    nativeClassElementsOk(s, s_extend_class, elems).\n\n  nativeClassDeclaredB : list((path * (string * TYPE))) -&gt; BOOL\n  nativeClassDeclaredB(_) = FALSE().\n  nativeClassDeclaredB([(_, (_, NATIVECLASS(_, _)))]) = TRUE().\n\nrules // native class elements\n\n  nativeClassElementsOk maps nativeClassElementOk(*, *, list(*))\n  nativeClassElementOk : scope * scope * NCElement\n\n  // constructors are declared in their own rule declareNativeClassConstructors\n  nativeClassElementOk(_, _, NCConstructor(_)).\n  nativeClassElementOk(_, _, NCConstructorFromStatic(_, _)).\n\n  nativeClassElementOk(s, s_class, NCProperty(x, nt)) :- {t}\n    t == typeOfNativeType(s, nt),\n    declareVar(s_class, x, t),\n    noDuplicateVarDefsInSuper(s_class, x) | error $[Cannot override existing property [x]] @x.\n\n  nativeClassElementOk(s, s_class, NCFunctionElement(function)) :-\n    nativeClassFunctionOk(s, s_class, function).\n\n  nativeClassElementOk(s, s_class, NCFunctionFromStaticElement(NCFunctionFromStatic(_, function))) :-\n    nativeClassFunctionOk(s, s_class, function).\n\nrules // native class functions\n\n  nativeClassFunctionOk : scope * scope * NCFunction\n  nativeClassFunctionOk(s, s_class, NCFunction(NCFunctionStatic(), f, args, NCFunctionReturn(return))) :- {argTypes returnType}\n    argTypes   == typesOfNativeTypes(s, args),\n    returnType == typeOfNativeType(s, return),\n    declareStaticFunction(s_class, f, NATIVE_FUNCTION_ORIGIN(args), argTypes, returnType).\n\n  nativeClassFunctionOk(s, s_class, NCFunction(NCFunctionStaticNone(), f, args, NCFunctionReturn(return))) :- {argTypes returnType}\n    argTypes   == typesOfNativeTypes(s, args),\n    returnType == typeOfNativeType(s, return),\n    declareFunction(s_class, f, NATIVE_FUNCTION_ORIGIN(args), argTypes, returnType).\n\nrules // constructors\n\n  declareNativeClassConstructors maps declareNativeClassConstructor(*, *, *, list(*))\n  declareNativeClassConstructor : scope * scope * string * NCElement\n  declareNativeClassConstructor(_, _, _, _).\n  declareNativeClassConstructor(s, s_class, name, NCConstructor(args)) :- {argTypes}\n    argTypes == typesOfNativeTypes(s, args),\n    declFunctionGlobal(s, name, NATIVE_FUNCTION_ORIGIN(args), argTypes, NATIVECLASS(name, s_class)).\n\n  declareNativeClassConstructor(s, s_class, name, NCConstructorFromStatic(_, args)) :- {argTypes}\n    argTypes == typesOfNativeTypes(s, args),\n    declFunctionGlobal(s, name, NATIVE_FUNCTION_ORIGIN(args), argTypes, NATIVECLASS(name, s_class)).\n\nrules // typing of expressions\n\n  typeOfCall(s, NATIVECLASS(_, s_class), f, args) = typeOfFunctionCallInternal(s, f, args, funSigs) :-\n    funSigs == resolveEntityFunction(s_class, f).\n\n  typeOfCall(s, STATICNATIVECLASS(_, s_class), f, args) = typeOfFunctionCallInternal(s, f, args, funSigs) :-\n    funSigs == resolveStaticEntityFunction(s_class, f).\n\nrules // typing of native types\n\n  typesOfNativeTypes maps typeOfNativeType(*, list(*)) = list(*)\n  typeOfNativeType : scope * NativeType -&gt; TYPE\n  typeOfNativeType(s, NativeSimpleType(t)) = typeOfSort(s, SimpleSort(t)).\n  typeOfNativeType(s, NativeGenericType(\"List\", [t])) =  LIST(typeOfNativeType(s, t)).\n  typeOfNativeType(s, NativeGenericType(\"Set\", [t])) = SET(typeOfNativeType(s, t)).\n  typeOfNativeType(s, t@NativeGenericType(_, _)) = UNTYPED() :- false | error $[Only lists and sets with one type parameter are supported] @t.\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/webdsl-native.stx/#modal-h2","title":"webdsl-native.stx","text":""},{"location":"webdslstatix/trans/static-semantics/webdsl-regex.stx/","title":"<code>webdsl-regex.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/webdsl-regex.stx</p> <pre><code>module static-semantics/webdsl-regex\n\nimports\n  static-semantics/types/built-ins\n\n  static-semantics/webdsl\n\nrules\n\n  typeOfExp(s, RegexCall(_, f, args)) = UNTYPED() :- { argTypes }\n    false | error $[Cannot resolve Regex Call [f]],\n    argTypes == typesOfExps(s, args).\n\n  typeOfExp(s, RegexCall(_, \"find\", args)) = bool(s) :- {argTypes ts}\n    ts == [string(s)],\n    argTypes == typesOfExps(s, args),\n    typesCompatible(argTypes, ts) == TRUE() | error $[Given argument types not compatible with page definition. Got [argTypes] but expected [ts]].\n\n  typeOfExp(s, RegexCall(_, \"match\", args)) = bool(s) :- {argTypes ts}\n    ts == [string(s)],\n    argTypes == typesOfExps(s, args),\n    typesCompatible(argTypes, ts) == TRUE() | error $[Given argument types not compatible with page definition. Got [argTypes] but expected [ts]].\n\n  typeOfExp(s, RegexCall(_, \"split\", args)) = LIST(string(s)) :- {argTypes ts}\n    ts == [string(s)],\n    argTypes == typesOfExps(s, args),\n    typesCompatible(argTypes, ts) == TRUE() | error $[Given argument types not compatible with page definition. Got [argTypes] but expected [ts]].\n\n  typeOfExp(s, RegexCall(_, \"replaceAll\", args)) = string(s) :- {argTypes ts}\n    ts == [string(s), string(s)],\n    argTypes == typesOfExps(s, args),\n    typesCompatible(argTypes, ts) == TRUE() | error $[Given argument types not compatible with page definition. Got [argTypes] but expected [ts]].\n\n  typeOfExp(s, RegexCall(_, \"replaceFirst\", args)) = string(s) :- {argTypes ts}\n    ts == [string(s), string(s)],\n    argTypes == typesOfExps(s, args),\n    typesCompatible(argTypes, ts) == TRUE() | error $[Given argument types not compatible with page definition. Got [argTypes] but expected [ts]].\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/webdsl-regex.stx/#modal-h2","title":"webdsl-regex.stx","text":""},{"location":"webdslstatix/trans/static-semantics/webdsl-search.stx/","title":"<code>webdsl-search.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/webdsl-search.stx</p> <pre><code>module static-semantics/webdsl-search\n\nimports\n  static-semantics/types/built-ins\n\n  static-semantics/webdsl\n  static-semantics/webdsl-types\n\nsignature\n\n  relations\n    searcher : string * string\n\nrules // definition\n\n  defOk(_, FullTextAnalyzer(_, _, _)) :- try { false } | warning $[This definition is not yet implemented].\n  defOk(_, SearchMapping(_, _)) :- try { false } | warning $[This definition is not yet implemented].\n\nrules // search retrieval expressions\n\n  typeOfExp(s, RetrievalExp(exp)) = typeOfRetrievalExp(s, exp).\n\n  typeOfRetrievalExp : scope * RetrievalExp -&gt; TYPE\n  typeOfRetrievalExp(s, Highlight(_, _, _, searcherExp)) = string(s) :-\n    isEntitySearcher(s, typeOfExp(s, searcherExp)).\n\n  typeOfRetrievalExp(s, HighlightTags(_, _, _, searcherExp, _, _)) = string(s) :-\n    isEntitySearcher(s, typeOfExp(s, searcherExp)).\n\n  typeOfRetrievalExp(s, SearchResults(exp)) = LIST(t) :- { searcherType }\n    searcherType == typeOfExp(s, exp),\n    isEntitySearcher(s, searcherType) | error $[Expression must be an entity searcher, got [searcherType]],\n    t == entityOfSearcher(s, searcherType) | error $[Cannot resolve entity of searcher with type [searcherType]].\n\n  typeOfRetrievalExp(s, FacetResults(_, searcherExp)) = LIST(definedTypeIfExists(s, \"Facet\")) :-\n    isEntitySearcher(s, typeOfExp(s, searcherExp)).\n\n  typeOfRetrievalExp(s, SearchResultsSize(exp)) = int(s) :-\n    isEntitySearcher(s, typeOfExp(s, exp)).\n\n  typeOfRetrievalExp(s, SearchTimeString(exp)) = string(s) :- \n    isEntitySearcher(s, typeOfExp(s, exp)).\n\n  typeOfRetrievalExp(s, Suggest(_, _, _)) = LIST(string(s)).\n\nrules // search initialization expressions\n\n  typeOfExp(s, SearcherDef(def)) = typeOfSearcherDef(s, def).\n\n  typeOfSearcherDef : scope * SearcherDef -&gt; TYPE\n  typeOfSearcherDef(s, SearcherInit(e, parts)) = t :- { ent }\n    ent == definedType(s, e) | error $[Cannot resolve entity [e]] @e,\n    t == searcherOfEntity(s, ent) | error $[Cannot resolve entity searcher for type [e]] @e,\n    searcherPartsOk(s, parts).\n\n  typeOfSearcherDef(s, SearcherRefMod(exp, parts)) = t :-\n    t == typeOfExp(s, exp),\n    isEntitySearcher(s, t) | error $[Expression must be an entity searcher, got type [t]] @exp,\n    searcherPartsOk(s, parts).\n\nrules // searcher parts\n\n  searcherPartsOk maps searcherPartOk(*, list(*))\n  searcherPartOk : scope * SearcherPart\n  searcherPartOk(_, part) :- try { false } | warning $[Searcher part [part] is not yet implemented].\n\nrules // entity name to searcher name mapping\n\n  isEntitySearcher : scope * TYPE\n  isEntitySearcher(s, t) :- false.\n  isEntitySearcher(s, NATIVECLASS(name, _)) :-\n    resolveSearcherMappingInverse(s, name) == [_].\n\n  resolveSearcherMapping : scope * string -&gt; list((path * (string * string)))\n  resolveSearcherMapping(s, entity) = ps :-\n    query searcher filter P* F* ((EXTEND? INHERIT*) | (DEF? (IMPORT | IMPORTLIB)?))\n           and { e' :- e' == (entity, _) }\n           in s |-&gt; ps.\n\n  resolveSearcherMappingInverse : scope * string -&gt; list((path * (string * string)))\n  resolveSearcherMappingInverse(s, searcher) = ps :-\n    query searcher filter P* F* ((EXTEND? INHERIT*) | (DEF? (IMPORT | IMPORTLIB)?))\n           and { e' :- e' == (_, searcher) }\n           in s |-&gt; ps.\n\n  defOk(s, GeneratedDefinition(Generated([\"entitySearcherMapping\", entity, searcher]))) :-\n    !searcher[entity, searcher] in s.\n\n  searcherOfEntity : scope * TYPE -&gt; TYPE\n  searcherOfEntity(_, _) = UNTYPED() :- false.\n  searcherOfEntity(s, ENTITY(e, _)) = t :- { searcher }\n    resolveSearcherMapping(s, e) == [(_, (_, searcher))],\n    t == definedTypeNoRef(s, searcher).\n\n  entityOfSearcher : scope * TYPE -&gt; TYPE\n  entityOfSearcher(_, _) = UNTYPED() :- false.\n  entityOfSearcher(s, NATIVECLASS(searcher, _)) = t :- { entity }\n    resolveSearcherMappingInverse(s, searcher) == [(_, (entity, _))],\n    t == definedTypeNoRef(s, entity).\n\nrules // built in\n\n  declareSearchBuiltIns : scope\n  declareSearchBuiltIns(s) :-\n    !searcher[\"Entity\", \"Searcher\"] in s. // abstract searcher results in entity type\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/webdsl-search.stx/#modal-h2","title":"webdsl-search.stx","text":""},{"location":"webdslstatix/trans/static-semantics/webdsl-services.stx/","title":"<code>webdsl-services.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/webdsl-services.stx</p> <pre><code>module static-semantics/webdsl-services\n\nimports\n  static-semantics/actions/functions\n\n  static-semantics/types/built-ins\n\n  static-semantics/webdsl\n\nrules\n\n  defOk(_, DeriveWebServices(_, _)) :- try { false } | warning $[This definition is not yet implemented].\n\n  defOk(s, ServiceFunction(mods, p, args, Block(stmts))) :- { s_webservice s_body ts}\n    new s_webservice, s_webservice -F-&gt; s,\n    ts == typesOfArgs(s, args),\n    declareParameters(s_webservice, zipArgTypes(args, ts)),\n    new s_body, s_body -P-&gt; s_webservice,\n    stmtsOk(s_body, stmts, object(s)),\n    declarePage(s, p, ts).\n\n  serviceModsOk maps serviceModOk(*, list(*))\n  serviceModOk : scope * Modifier\n  serviceModOk(_, m) :- false | error $[Modifier [m] not allowed in a service definition].\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/webdsl-services.stx/#modal-h2","title":"webdsl-services.stx","text":""},{"location":"webdslstatix/trans/static-semantics/webdsl-types.stx/","title":"<code>webdsl-types.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/webdsl-types.stx</p> <pre><code>module static-semantics/webdsl-types\n\nimports\n  static-semantics/entities/annotations\n\n  static-semantics/types/built-ins\n  static-semantics/types/type-extensions\n\n  static-semantics/webdsl\n\nsignature\n\n  constructors // semantic types\n\n    // list of argument types, return type\n    // and BOOL that indicates if function is static or not\n    FUNCTION : string * list(TYPE) * TYPE * BOOL -&gt; TYPE\n    ACTION   : string * list(TYPE) -&gt; TYPE\n\n    ENTITY       : string * scope -&gt; TYPE\n    STATICENTITY : string * scope -&gt; TYPE\n\n    NATIVECLASS       : string * scope -&gt; TYPE\n    STATICNATIVECLASS : string * scope -&gt; TYPE\n\n    PAGE     : string * list(TYPE) -&gt; TYPE\n\n    // BOOL indicates if template is ajax-enabled or not\n    TEMPLATE : string * list(TYPE) * BOOL -&gt; TYPE\n\n    // access control\n    POINTCUT    : string * list(TYPE) -&gt; TYPE\n    CREDENTIALS : list(TYPE)          -&gt; TYPE\n\n    LIST : TYPE -&gt; TYPE\n    SET  : TYPE -&gt; TYPE\n    REF  : TYPE -&gt; TYPE\n\n    // built-in types without scopes\n    BUILTINTYPE : string * scope -&gt; TYPE\n    STATICBUILTINTYPE : string * scope -&gt; TYPE\n\n    TEMPLATEVARARG : list(TYPE) * scope -&gt; TYPE\n\n    REGEX            : TYPE\n    VOID             : TYPE\n    TEMPLATEELEMENTS : TYPE\n    NULL             : TYPE\n    UNTYPED          : TYPE\n\nrules // types of constant expressions\n\n  typeOfExp(s, exp@True()) = t :-\n    t == bool(s),\n    @exp.type := t.\n\n  typeOfExp(s, exp@False()) = t :-\n    t == bool(s),\n    @exp.type := t.\n\n  typeOfExp(_, exp@Null()) = NULL() :-\n    @exp.type := NULL().\n\n  typeOfExp(s, Const(c)) = typeOfConst(s, c).\n  typeOfPlaceholderExp(s, PHConst(c)) = typeOfConst(s, c).\n\n  typeOfConst : scope * ConstValue -&gt; TYPE\n  typeOfConst(s, exp@Int(_)) = t :-\n    t == int(s),\n    @exp.type := t.\n\n  typeOfConst(s, exp@Long(_)) = t :-\n    t == long(s),\n    @exp.type := t.\n\n  typeOfConst(s, exp@Float(_)) = t :-\n    t == float(s),\n    @exp.type := t.\n\n  typeOfConst(s, exp@StringConst(str)) = t :-\n    t == string(s),\n    stringOk(s, str),\n    @exp.type := t.\n\n  stringOk : scope * String\n  stringOk(s, String(parts)) :- stringPartsOk(s, parts).\n\n  stringPartsOk maps stringPartOk(*, list(*))\n  stringPartOk : scope * StringPart\n  stringPartOk(s, StringValue(_)).\n  stringPartOk(s, InterpExp(exp)) :- typed(s, exp).\n  stringPartOk(s, InterpValue(InterpSimpleExp(simple_exp))) :-\n    inequalType(typeOfSimpleExp(s, simple_exp), UNTYPED()).\n\nrules // type compatibility of constants\n\n  // numeric types\n  typeCompatibleB(BUILTINTYPE(\"Long\", _), BUILTINTYPE(\"Int\", _)) = TRUE().\n  typeCompatibleB(BUILTINTYPE(\"Int\", _), BUILTINTYPE(\"Long\", _)) = TRUE().\n\n  // string types\n  typeCompatibleB(T1, BUILTINTYPE(\"String\", _))      = isStringCompatibleTypeB(T1).\n  typeCompatibleB(T1, BUILTINTYPE(\"Secret\", _))      = isStringCompatibleTypeB(T1).\n  typeCompatibleB(T1, BUILTINTYPE(\"Email\", _))       = isStringCompatibleTypeB(T1).\n  typeCompatibleB(T1, BUILTINTYPE(\"URL\", _))         = isStringCompatibleTypeB(T1).\n  typeCompatibleB(T1, BUILTINTYPE(\"WikiText\", _))    = isStringCompatibleTypeB(T1).\n  typeCompatibleB(T1, BUILTINTYPE(\"Text\", _))        = isStringCompatibleTypeB(T1).\n  typeCompatibleB(T1, BUILTINTYPE(\"Patch\", _))       = isStringCompatibleTypeB(T1).\n  typeCompatibleB(T1, BUILTINTYPE(\"Placeholder\", _)) = isStringCompatibleTypeB(T1).\n\n  // date types\n  typeCompatibleB(T1, BUILTINTYPE(\"Date\", _))     = isDateCompatibleTypeB(T1).\n  typeCompatibleB(T1, BUILTINTYPE(\"DateTime\", _)) = isDateCompatibleTypeB(T1).\n  typeCompatibleB(T1, BUILTINTYPE(\"Time\", _))     = isDateCompatibleTypeB(T1).\n\n  // misc\n  typeCompatibleB(LIST(T1), LIST(T2)) = typeCompatibleB(T1, T2).\n  typeCompatibleB(SET(T1), SET(T2))   = typeCompatibleB(T1, T2).\n  typeCompatibleB(REF(_), REF(_))     = TRUE().\n  typeCompatibleB(T1, REF(T2))        = typeCompatibleB(T1, T2). // ref is compatible both ways\n  typeCompatibleB(REF(T1), T2)        = typeCompatibleB(T1, T2). // ref is compatible both ways\n  typeCompatibleB(NULL(), _) = TRUE().\n  typeCompatibleB(_, BUILTINTYPE(\"Object\", _)) = TRUE().\n\nrules // utils\n\n  isDateCompatibleType : TYPE\n  isDateCompatibleType(t) :- isDateCompatibleTypeB(t) == TRUE().\n\n  isDateCompatibleTypeB : TYPE -&gt; BOOL\n  isDateCompatibleTypeB(_)                          = FALSE().\n  isDateCompatibleTypeB(BUILTINTYPE(\"Date\", _))     = TRUE().\n  isDateCompatibleTypeB(BUILTINTYPE(\"DateTime\", _)) = TRUE().\n  isDateCompatibleTypeB(BUILTINTYPE(\"Time\", _))     = TRUE().\n  isDateCompatibleTypeB(BUILTINTYPE(\"Object\", _))   = TRUE().\n\n  isStringCompatibleType : TYPE\n  isStringCompatibleType(t) :- isStringCompatibleTypeB(t) == TRUE().\n\n  isStringCompatibleTypeB : TYPE -&gt; BOOL\n  isStringCompatibleTypeB(_)             = FALSE().\n  isStringCompatibleTypeB(BUILTINTYPE(\"String\", _))       = TRUE().\n  isStringCompatibleTypeB(BUILTINTYPE(\"Secret\", _))       = TRUE().\n  isStringCompatibleTypeB(BUILTINTYPE(\"Email\", _))        = TRUE().\n  isStringCompatibleTypeB(BUILTINTYPE(\"URL\", _))          = TRUE().\n  isStringCompatibleTypeB(BUILTINTYPE(\"WikiText\", _))     = TRUE().\n  isStringCompatibleTypeB(BUILTINTYPE(\"Text\", _))         = TRUE().\n  isStringCompatibleTypeB(BUILTINTYPE(\"Patch\", _))        = TRUE().\n  isStringCompatibleTypeB(BUILTINTYPE(\"Object\", _))       = TRUE().\n  isStringCompatibleTypeB(BUILTINTYPE(\"Placeholder\", _)) = TRUE().\n\nrules // map sorts to semantic types\n\n  typeOfSortTyped : scope * Sort -&gt; TYPE\n  typeOfSortTyped(s, sort) = t :-\n    t == typeOfSort(s, sort),\n    t != UNTYPED() | error $[Cannot resolve type [t]].\n\n  typesOfSorts maps typeOfSort(*, list(*)) = list(*)\n  typeOfSort : scope * Sort -&gt; TYPE\n  typeOfSort(_, _) = UNTYPED(). // untyped by default\n  typeOfSort(s, SimpleSort(\"Int\")) = int(s).\n  typeOfSort(s, SimpleSort(\"Float\")) = float(s).\n  typeOfSort(s, SimpleSort(\"Long\")) = long(s).\n\n  typeOfSort(s, SimpleSort(\"String\")) = string(s).\n  typeOfSort(s, SimpleSort(\"Secret\")) = secret(s).\n  typeOfSort(s, SimpleSort(\"Email\")) = email(s).\n  typeOfSort(s, SimpleSort(\"URL\")) = url(s).\n  typeOfSort(s, SimpleSort(\"WikiText\")) = wikitext(s).\n  typeOfSort(s, SimpleSort(\"Text\")) = text(s).\n  typeOfSort(s, SimpleSort(\"Patch\")) = patch(s).\n  typeOfSort(s, SimpleSort(\"Placeholder\")) = placeholder(s).\n\n  typeOfSort(s, SimpleSort(\"Date\")) = date(s).\n  typeOfSort(s, SimpleSort(\"DateTime\")) = datetime(s).\n  typeOfSort(s, SimpleSort(\"Time\")) = time(s).\n\n  typeOfSort(_, SimpleSort(\"Regex\")) = REGEX().\n  typeOfSort(s, SimpleSort(\"Bool\")) = bool(s).\n  typeOfSort(_, SimpleSort(\"Void\")) = VOID().\n  typeOfSort(s, SimpleSort(\"UUID\")) = uuid(s).\n  typeOfSort(_, SimpleSort(\"TemplateElements\")) = TEMPLATEELEMENTS().\n  typeOfSort(s, SimpleSort(\"File\")) = file(s).\n  typeOfSort(s, SimpleSort(\"Image\")) = image(s).\n\n  // in case it's not a built in simple sort, it must be an entity\n  typeOfSort(s, SimpleSort(x)) = definedType(s, x).\n\n  typeOfSort(s, GenericSort(\"List\", [innerSort])) = LIST(typeOfSort(s, innerSort)).\n  typeOfSort(s, GenericSort(_, _)) = UNTYPED() :- false | error $[Only lists and sets with one type parameter are supported].\n  typeOfSort(s, GenericSort(\"Set\", [innerSort])) = SET(typeOfSort(s, innerSort)).\n\n  typeOfSort(s, RefSort(innerSort)) = REF(typeOfSort(s, innerSort)).\n\nrules // WebDSL definition of being a simple type: built-in simple sort (no generics, no ref, no entity etc)\n\n  isBuiltInType : TYPE\n  isBuiltInType(t) :- isBuiltInTypeB(t) == TRUE().\n\n  isBuiltInTypeB: TYPE -&gt; BOOL\n  isBuiltInTypeB(_) = FALSE(). // not a simple type by default\n  isBuiltInTypeB(BUILTINTYPE(_, _)) = TRUE().\n\nrules // type related expressions\n\n  typeOfExp(s, Cast(exp, sort)) = t' :- {t}\n    t  == typeOfExpTyped(s, exp),\n    t' == typeOfSortTyped(s, sort),\n    or(typeCompatibleB(t, t'), typeCompatibleB(t', t)) | error $[Type [t] cannot be cast to [t']].\n\n  typeOfExp(s, IsA(exp, sort)) = bool(s) :- {t t'}\n    t  == typeOfExpTyped(s, exp),\n    t' == typeOfSortTyped(s, sort).\n\nrules // resolve reference types\n\n  definedType : scope * string -&gt; TYPE\n  definedType(s, name) = t :- {name'}\n    resolveType(s, name) == [(_, (name', t))|_] | error $[Type [name] does not exist], // correct error message for tests\n    @name.ref := name'.\n\n  definedTypeCustomError : scope * string -&gt; TYPE\n  definedTypeCustomError(s, name) = t :- {name'}\n    resolveType(s, name) == [(_, (name', t))|_],\n    @name.ref := name'.\n\n  definedTypeNoRef : scope * string -&gt; TYPE\n  definedTypeNoRef(s, name) = t :-\n    resolveType(s, name) == [(_, (_, t))|_] | error $[Type [name] does not exist]. // correct error message for tests\n\n  definedTypeIfExists : scope * string -&gt; TYPE\n  definedTypeIfExists(s, name) = definedTypeIfExists_internal(s, resolveType(s, name)).\n\n  definedTypeIfExists_internal : scope * list((path * (string * TYPE))) -&gt; TYPE\n  definedTypeIfExists_internal(_, [(_, (_, t))|_]) = t.\n  definedTypeIfExists_internal(s, []) = entity(s).\n\n  variableType : scope * string -&gt; TYPE\n  variableType(s, x) = t :- {x'}\n    resolveVar(s, x) == [(_, (x', t))|_] | error $[Variable [x] not defined], // correct error message for tests\n    @x.ref := x'.\n\n  propertyType : scope * string -&gt; TYPE\n  propertyType(s, x) = t :- { ps x' }\n    ps == withoutAnnotation(resolveProperty(s, x), OVERRIDABLE()),\n    ps == [(_, (x', t))],\n    @x.ref := x'.\n\n  propertyTypeNoRef : scope * string -&gt; TYPE\n  propertyTypeNoRef(s, x) = t :- { ps x' }\n    ps == withoutAnnotation(resolveProperty(s, x), OVERRIDABLE()),\n    ps == [(_, (x', t))].\n\n  singleResult : list((path * (string * TYPE))) * string * string\n  singleResult([], type, x) :- false | error $[[type] [x] is not defined] @x.\n  singleResult([_ | [_ | _]], type, x) :- false | error $[[type] [x] is defined multiple times] @x.\n  singleResult(_, _, _).\n\n  pageType : scope * string -&gt; TYPE\n  pageType(s, p) = t :- {p'}\n    resolvePage(s, p) == [(_, (p', t@PAGE(_, _)))|_], // no fixed error message here to allow more specific error messages on higher predicates\n    @p.ref := p'.\n\nrules // utils\n\n  stripGenericType : TYPE -&gt; TYPE\n  stripGenericType(t) = UNTYPED() :- false | error $[Must be a list or set, [t] given].\n  stripGenericType(REF(t)) = stripGenericType(t).\n  stripGenericType(LIST(t)) = t.\n  stripGenericType(SET(t)) = t.\n\n  stripOptionalSetOrListType : TYPE -&gt; TYPE\n  stripOptionalSetOrListType(t) = t.\n  stripOptionalSetOrListType(LIST(t)) = t.\n  stripOptionalSetOrListType(SET(t)) = t.\n\n  stripRefTypes maps stripRefType(list(*)) = list(*)\n  stripRefType : TYPE -&gt; TYPE\n  stripRefType(t) = t.\n  stripRefType(REF(t)) = stripRefType(t).\n\n  typed : scope * Exp\n  typed(s, exp) :- inequalType(typeOfExp(s, exp), UNTYPED()).\n\n  inequalType : TYPE * TYPE\n  inequalType(T1, T2) :- equalTypeB(T1, T2) == FALSE().\n\n  equalType : TYPE * TYPE\n  equalType(T1, T2) :- equalTypeB(T1, T2) == TRUE().\n\n  equalTypeB : TYPE * TYPE -&gt; BOOL\n  equalTypeB(T, T) = TRUE().\n  equalTypeB(_, _) = FALSE().\n\nrules\n\n  ppType : TYPE -&gt; string\n  ppType(t) = \"&lt;unknown pretty print type&gt;\" :- try { false } | warning $[Couldn't pretty-print type [t]].\n  ppType(ENTITY(e, _)) = e.\n  ppType(STATICENTITY(e, _)) = e.\n  ppType(NATIVECLASS(nc, _)) = nc.\n  ppType(STATICNATIVECLASS(nc, _)) = nc.\n  ppType(BUILTINTYPE(t, _)) = t.\n  ppType(STATICBUILTINTYPE(t, _)) = t.\n\n  ppType(REGEX()) = \"Regex\".\n  ppType(VOID()) = \"Void\".\n  ppType(TEMPLATEELEMENTS()) = \"TemplateElements\".\n  ppType(NULL()) = \"Null\".\n  ppType(UNTYPED()) = \"UNTYPED\".\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/webdsl-types.stx/#modal-h2","title":"webdsl-types.stx","text":""},{"location":"webdslstatix/trans/static-semantics/webdsl-ui.stx/","title":"<code>webdsl-ui.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/webdsl-ui.stx</p> <pre><code>module static-semantics/webdsl-ui\n\nimports\n  static-semantics/actions/functions\n\n  static-semantics/entities/annotations\n\n  static-semantics/types/built-ins\n\n  static-semantics/ui/actions\n  static-semantics/ui/ajax\n  static-semantics/ui/attributes\n  static-semantics/ui/built-ins\n  static-semantics/ui/template-calls\n\n  static-semantics/webdsl-actions\n  static-semantics/webdsl-types\n  static-semantics/webdsl\n\nrules // unimplemented definitions\n\n  defOk(_, TemplateDefinition(Define(_, t, _, _, _))) :- false | error $[Could not desugar define to an email, template or page definition] @t.\n  defOk(_, TemplateDefinition(LocalRedefine(_, t, _, _, _))) :- try { false } | warning $[This definition is not yet implemented] @t.\n  defOk(_, TemplateDefinition(DefineEmail(_, e, _, _, _))) :- try { false } | warning $[Email definitions are not yet implemented] @e.\n\n  defOk(_, TemplateDefinition(HTMLWrapper2TemplateDefinition(_))) :- false | error $[Could not desugar to template definitions].\n  defOk(_, TemplateDefinition(HTMLWrapperMultiple(_))) :- false | error $[Could not desugar to template definitions].\n\nrules // page definitions\n\n  defOk(s, TemplateDefinition(DefinePage(mods, x, FormalArgs(fargs), TemplateArgs(targs), elements))) :- {fargTypes s_page s_pha s_body}\n    pageModsOk(s, mods),\n    targs == [] | error $[Template arguments are not allowed on page definitions] @targs,\n    new s_page, s_page -F-&gt; s,\n    fargTypes == typesOfArgs(s, fargs),\n    declareParameters(s_page, zipArgTypes(fargs, fargTypes)),\n    new s_pha, s_pha -P-&gt; s_page,\n    new s_body, s_body -P-&gt; s_pha,\n    optionallyDeclarePage(s, x, fargTypes, notB(isOverrideB(mods))),\n    overriddenElementExists(s, Page(), x, FALSE(), isOverrideB(mods)),\n    templateElementOrderOk(elements, FALSE(), FALSE()),\n    templateElementsOk(s_body, s_pha, elements).\n\n  optionallyDeclarePage : scope * string * list(TYPE) * BOOL\n  optionallyDeclarePage(_, _, _, FALSE()).\n  optionallyDeclarePage(s, x, fargTypes, TRUE()) :- declarePage(s, x, fargTypes).\n\n  pageModsOk maps pageModOk(*, list(*))\n  pageModOk : scope * Modifier\n  pageModOk(_, _) :- try { false } | warning $[This modifier is not yet implemented].\n  pageModOk(_, AjaxTemplate()) :- false | error $[A page cannot be an ajax template].\n  pageModOk(_, WebService()) :- false | error $[To define a webservice, use \"webservice myWebservice(...) { ... }\"].\n  pageModOk(_, TemplateModOverride()).\n  pageModOk(_, IgnoreAccessControl()).\n\nrules // template definitions\n\n  defOk(s, TemplateDefinition(td@DefineTemplate(_, _, _, _, _))) :- defineTemplateOk(s, td).\n\n  // last BOOL defines if the template is top-level (TRUE) or nested (FALSE)\n  defineTemplateOk : scope * TemplateDefinition\n  defineTemplateOk(s, DefineTemplate(mods, t, FormalArgs(fargs), TemplateArgs(targs), elements)) :- {fargTypes targTypes s_template s_pha s_body}\n    templateModsOk(s, mods),\n    new s_template, s_template -F-&gt; s,\n    fargTypes == typesOfArgs(s, fargs),\n    targTypes == typesOfTemplateArgs(s, targs),\n    declareParameters(s_template, zipArgTypes(fargs, fargTypes)),\n    declTArgs(s_template, targTypes),\n    new s_pha, s_pha -P-&gt; s_template,\n    new s_body, s_body -P-&gt; s_pha,\n    optionallyDeclareTemplate(s, t, fargTypes, targTypes, isAjaxTemplate(mods), notB(isOverrideB(mods))),\n    overriddenElementExists(s, Template(), t, isAjaxTemplate(mods), isOverrideB(mods)),\n    templateElementOrderOk(elements, FALSE(), FALSE()),\n    templateElementsOk(s_body, s_pha, elements).\n\n  templateModsOk maps templateModOk(*, list(*))\n  templateModOk : scope * Modifier\n  templateModOk(_, _) :- try { false } | warning $[This modifier is not yet implemented].\n  templateModOk(_, WebService()) :- false | error $[To define a webservice, use \"webservice myWebservice(...) { ... }\"].\n  templateModOk(_, AjaxTemplate()).\n  templateModOk(_, TemplateModOverride()).\n  templateModOk(_, IgnoreAccessControl()).\n\n  nestedTemplateOk : scope * TemplateDefinition\n  nestedTemplateOk(s, DefineTemplate(_, t, FormalArgs(fargs), TemplateArgs(targs), elements)) :- {fargTypes targTypes sigs s_template s_pha s_body}\n    new s_template, s_template -P-&gt; s, // use P edge label instead of F to get correct duplicate variable errors and resolve queries correctly\n    fargTypes == typesOfArgs(s, fargs),\n    targTypes == typesOfTemplateArgs(s, targs),\n    declareParameters(s_template, zipArgTypes(fargs, fargTypes)),\n    declTArgs(s_template, targTypes),\n    sigs == resolveTemplate(s, t),\n    matchingSigs(fargTypes, dropPaths(sigs)) == [_] | error $[No template [t] with argument types [fargTypes] exists] @t,\n    new s_pha, s_pha -P-&gt; s_template,\n    new s_body, s_body -P-&gt; s_pha,\n    templateElementOrderOk(elements, FALSE(), FALSE()),\n    templateElementsOk(s_body, s_pha, elements).\n\n  isAjaxTemplate : list(Modifier) -&gt; BOOL\n  isAjaxTemplate([]) = FALSE().\n  isAjaxTemplate([_ | mods]) = isAjaxTemplate(mods).\n  isAjaxTemplate([AjaxTemplate() | _]) = TRUE().\n\n  isOverrideB : list(Modifier) -&gt; BOOL\n  isOverrideB([]) = FALSE().\n  isOverrideB([_ | mods]) = isOverrideB(mods).\n  isOverrideB([TemplateModOverride() | _]) = TRUE().\n\n  overriddenElementExists : scope * Modifier * string * BOOL * BOOL\n  overriddenElementExists(_, _, _, _, FALSE()).\n  overriddenElementExists(s, Page(), p, _, TRUE()) :- resolvePage(s, p) == [(_, (_, _))] | error $[Page [p] does not exist] @p.\n  overriddenElementExists(s, Template(), t, FALSE(), TRUE()) :- resolveTemplateNoAjax(s, t) == [(_, (_, _))] | error $[Template [t] does not exist] @t.\n  overriddenElementExists(s, Template(), t, TRUE(), TRUE()) :- resolveAjaxTemplate(s, t) == [(_, (_, _))] | error $[Ajax template [t] does not exist] @t.\n\n  optionallyDeclareTemplate : scope * string * list(TYPE) * list((string * list(TYPE))) * BOOL * BOOL\n  optionallyDeclareTemplate(_, _, _, _, _, FALSE()).\n  optionallyDeclareTemplate(s, t, fargTypes, targTypes, ajax, TRUE()) :- declTemplate(s, t, fargTypes, targTypes, ajax).\n\n  declTemplate : scope * string * list(TYPE) * list((string * list(TYPE))) * BOOL\n  declTemplate(s, t, fargTypes, targTypes, ajax) :- {result}\n    declareTemplate_internal(s, t, fargTypes, ajax),\n    resolveTemplate(s, t) == result,\n    amountOfTemplateDeclsWithArgs(result, fargTypes, 0) == 1\n      | error $[Multiple page/template definitions with name [t] and argument types [fargTypes]] @t. // correct error message for tests\n\n  declTArgs maps declTArg(*, list(*))\n  declTArg : scope * (string * list(TYPE))\n  declTArg(s, (t, argTypes)) :-\n    declTemplate(s, t, argTypes, [], FALSE()).\n\n  // helper function that results in the amount of template definitions with the given argument types\n  amountOfTemplateDeclsWithArgs : list((path *(string * TYPE))) * list(TYPE) * int -&gt; int\n  amountOfTemplateDeclsWithArgs([], _, n) = n.\n  amountOfTemplateDeclsWithArgs([ (_, (_, TEMPLATE(_, args, _))) | tail], args, n) = amountOfTemplateDeclsWithArgs(tail, args, i) :- i #= n + 1.\n  amountOfTemplateDeclsWithArgs([ _ | tail], args, n) = amountOfTemplateDeclsWithArgs(tail, args, n).\n\nrules // template elements\n\n  templateElementOk : scope * scope * scope * TemplateElement // TYPE argument is the return type in a function\n  templateElementOk(_, _, _, e) :- try { false } | warning $[This template element is not yet implemented] @e.\n\n  // the second scope (s_pha) is for declaring+resolving of placeholders and actions, which do not have to be declared before use\n  templateElementsOk : scope * scope * list(TemplateElement)\n  templateElementsOk(_, _, []).\n  templateElementsOk(s, s_pha, [element | tail]) :- {s_next}\n    new s_next, s_next -P-&gt; s,\n    templateElementOk(s, s_next, s_pha, element),\n    templateElementsOk(s_next, s_pha, tail).\n\n  templateElementOk(s, _, _, Text(parts)) :-\n    stringPartsOk(s, parts).\n\n  templateElementOk(s, _, _,  XMLComment(_)).\n\n  templateElementOk(s, _, _, XMLEmptyElement(_, attributes)) :-\n    attributesOk(s, attributes).\n\n  templateElementOk(s, _, _, XMLEmptyElementUnclosed(_, attributes)) :-\n    attributesOk(s, attributes).\n\n  templateElementOk(s, _, s_pha, XMLElement(openTagName, attributes, elements, closeTagName)) :-\n    openTagName == closeTagName | error $[Opening and closing tag do not match],\n    attributesOk(s, attributes),\n    templateElementsOk(s, s_pha, elements).\n\n  templateElementOk(s, _, _, JSElement(attributes, parts)) :-\n    attributesOk(s, attributes),\n    jsStringPartsOk(s, parts).\n\n  templateElementOk(s, _, _, StyleElement(attributes, parts)) :-\n    attributesOk(s, attributes),\n    jsStringPartsOk(s, parts).\n\n  jsStringPartsOk maps jsStringPartOk(*, list(*))\n  jsStringPartOk : scope * JSPart\n  jsStringPartOk(s, JSString(_)).\n  jsStringPartOk(s, JSExp(exp)) :- typed(s, exp).\n\n  templateElementOk(s, _, s_pha, IfTempl(c, then, else)) :-\n    equalType(typeOfExp(s, c), bool(s)) | error $[Condition should be of type bool] @c,\n    templateElementsOk(s, s_pha, then),\n    templateElementsOk(s, s_pha, else).\n\n  templateElementOk(s, _,  _, TemplateDefinition2TemplateElement(td)) :- nestedTemplateOk(s, td).\n\n  templateElementOk(s, _, s_pha, SubmitElem(a, props, elems)) :-\n    actionCallOrInlineOk(s, a),\n    templatePropAssignmentsOk(s, props),\n    templateElementsOk(s, s_pha, elems).\n\n  templateElementOk(s, _, s_pha, SubmitLinkElem(a, props, elems)) :-\n    actionCallOrInlineOk(s, a),\n    templatePropAssignmentsOk(s, props),\n    templateElementsOk(s, s_pha, elems).\n\n  templateElementOk(s, _, s_pha, DownloadLink(a, props, elems)) :-\n    actionCallOrInlineOk(s, a),\n    templatePropAssignmentsOk(s, props),\n    templateElementsOk(s, s_pha, elems).\n\n  templateElementOk(s, _, s_pha, OutputImage(a, props, elems)) :-\n    actionCallOrInlineOk(s, a),\n    templatePropAssignmentsOk(s, props),\n    templateElementsOk(s, s_pha, elems).\n\nrules // expressions\n\n  typeOfExp(s, TemplateName2Exp(TemplateName())) = string(s). // TO-DO: only allow this if inside a template\n\nrules // loops\n\n  templateElementOk(s, _, s_pha, For(x, srt, exp, OptFilterSome(f), elems, ForSeparator(separatorElems))) :- {s_for typeOfSort typeOfExp}\n    typeOfSort == typeOfSort(s, srt),\n    typeOfExp == typeOfExp(s, exp),\n    or(\n      equalTypeB(LIST(typeOfSort), typeOfExp),\n      equalTypeB(SET(typeOfSort), typeOfExp)\n    ) | error $[Must be a list or set of type [typeOfSort], [typeOfExp] given] @exp,\n    new s_for, s_for -P-&gt; s,\n    forLoopFilterOk(s_for, f),\n    forLoopOk(s_for, s_pha, x, typeOfSort, elems),\n    separatorOk(s, s_pha, separatorElems),\n    @x.type := typeOfSort.\n\n  templateElementOk(s, _, s_pha, ForInferred(x, exp, OptFilterSome(f), elems, ForSeparator(separatorElems))) :- {s_for typeOfExp t}\n    typeOfExp == typeOfExp(s, exp),\n    t == stripGenericType(typeOfExp),\n    new s_for, s_for -P-&gt; s,\n    forLoopFilterOk(s_for, f),\n    forLoopOk(s_for, s_pha, x, t, elems),\n    separatorOk(s, s_pha, separatorElems),\n    @x.type := t.\n\n  templateElementOk(s, _, s_pha, ForAll(x, srt, OptFilterSome(f), elems, ForSeparator(separatorElems))) :- {s_for typeOfSort}\n    typeOfSort == typeOfSort(s, srt),\n    new s_for, s_for -P-&gt; s,\n    forLoopFilterOk(s_for, f),\n    forLoopOk(s_for, s_pha, x, typeOfSort, elems),\n    separatorOk(s, s_pha, separatorElems),\n    @x.type := typeOfSort.\n\n  templateElementOk(s, _, s_pha, ForCount(x, fromExp, toExp, elems, ForSeparator(separatorElems))) :- {s_for intType}\n    intType == int(s),\n    equalType(typeOfExp(s, fromExp), intType) | error $[From expression should have type Int],\n    equalType(typeOfExp(s, toExp)  , intType) | error $[To expression should have type Int],\n    new s_for, s_for -P-&gt; s,\n    forLoopOk(s_for, s_pha, x, intType, elems),\n    separatorOk(s, s_pha, separatorElems),\n    @x.type := intType.\n\n  forLoopOk : scope * scope * string * TYPE * list(TemplateElement)\n  forLoopOk(s_for, s_pha, x, t, stmts) :-\n    declareVar(s_for, x, t),\n    declareAnnotation(s_for, x, DERIVED()), // abuse derived annotation to declare immutability of x\n    templateElementsOk(s_for, s_pha, stmts).\n\n  separatorOk : scope * scope * list(TemplateElement)\n  separatorOk(s, s_pha, elems) :- {s_separator}\n    new s_separator, s_separator -P-&gt; s,\n    templateElementsOk(s_separator, s_pha, elems).\n\nrules // enforce correct order of template elements\n\n  // correct order:\n  // 1. var decls\n  // 2. init block\n  // 3. other template elements\n  templateElementOrderOk : list(TemplateElement) * BOOL * BOOL\n  templateElementOrderOk([], _, _).\n  templateElementOrderOk([x | xs], _, _). // TO-DO: verify if we want this check :- templateElementOrderOk(xs, TRUE(), TRUE()).\n\n  templateElementOrderOk([TEVarDecl(v) | xs], varDeclsDone, initDone) :-\n    varDeclsDone == FALSE() | error $[Variable declarations must be at the start of a page or template] @v,\n    templateElementOrderOk(xs, varDeclsDone, initDone).\n\n  templateElementOrderOk([i@Init(_) | xs], _, initDone) :-\n    initDone == FALSE() | error $[Init block must be between variable declarations and the rest of the page or template] @i,\n    templateElementOrderOk(xs, TRUE(), initDone).\n\nrules // template var args\n\n  typeOfArg(s, Arg(_, TemplateVarArgSort(props))) = LIST(TEMPLATEVARARG(ts, s_arg)) :-\n    new s_arg,\n    ts == typesOfTemplateVarArgProps(s, s_arg, props).\n\n  typesOfTemplateVarArgProps maps typeOfTemplateVarArgProp(*, *, list(*)) = list(*)\n  typeOfTemplateVarArgProp : scope * scope * FormalVarArg -&gt; TYPE\n  typeOfTemplateVarArgProp(s, s_arg, FormalVarArg(x, srt)) = t :-\n    t == typeOfSort(s, srt),\n    declareVar(s_arg, x, t),\n    optionallyDeclareTemplateElements(s_arg, x, t).\n\n  optionallyDeclareTemplateElements : scope * string * TYPE\n  optionallyDeclareTemplateElements(_, _, _).\n  optionallyDeclareTemplateElements(s_arg, x, TEMPLATEELEMENTS()) :-\n    declareTemplate(s_arg, x, []).\n\n  typeOfProperty(s, TEMPLATEVARARG(_, s_arg), x) = t :-\n    propertyType(s_arg, x) == t.\n\n  templateCallOk_internal(s, s_pha, MemberTemplateCall(x, tc), ajax) :- { s_arg s_resolve }\n    variableType(s, x) == TEMPLATEVARARG(_, s_arg) | error $[Variable [x] is not a template variable argument],\n    new s_resolve, s_resolve -P-&gt; s_arg,\n    templateCallOk_internal(s_resolve, s_pha, tc, ajax).\n\n  typeCompatibleB(TEMPLATEVARARG(ts1, _), TEMPLATEVARARG(ts2, _)) = b :-\n    b == typesCompatible(ts1, ts2).\n\nrules // utils\n\n  rootPageDefined : scope * string\n  rootPageDefined(s, errorLoc) :- { p ts }\n    resolvePage(s, \"root\") == [(_, (_, PAGE(p, ts)))|_] | error $[No root page defined] @errorLoc,\n    noRootPageArguments(p, ts).\n\n  noRootPageArguments : string * list(TYPE)\n  noRootPageArguments(_, []).\n  noRootPageArguments(p, [_ | _]) :- false | error $[Root page is not allowed to have parameters] @p.\n\n  typesOfTemplateArgs maps typeOfTemplateArg(*, list(*)) = list(*)\n  typeOfTemplateArg : scope * TemplateArg -&gt; (string * list(TYPE))\n  typeOfTemplateArg(s, TemplateArg(x, argSorts)) = (x, typesOfSorts(s, argSorts)).\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/webdsl-ui.stx/#modal-h2","title":"webdsl-ui.stx","text":""},{"location":"webdslstatix/trans/static-semantics/webdsl.stx/","title":"<code>webdsl.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/webdsl.stx</p> <pre><code>module static-semantics/webdsl\n\nimports\n  signatures/webdsl-statix-sig\n\n  static-semantics/actions/built-ins\n  static-semantics/entities/built-ins\n  static-semantics/types/built-ins\n  static-semantics/ui/built-ins\n\n  static-semantics/entities/annotations\n\n  static-semantics/webdsl-ac\n  static-semantics/webdsl-actions\n  static-semantics/webdsl-entities\n  static-semantics/webdsl-expand\n  static-semantics/webdsl-hql\n  static-semantics/webdsl-modules\n  static-semantics/webdsl-native\n  static-semantics/webdsl-regex\n  static-semantics/webdsl-search\n  static-semantics/webdsl-services\n  static-semantics/webdsl-types\n  static-semantics/webdsl-ui\n\nsignature\n\n  sorts\n    TYPE   // semantic type\n    BOOL   // used as return values of functional rules\n    ORIGIN // dummy data: used to guide scope graph differ\n\n  constructors\n    TRUE : BOOL\n    FALSE : BOOL\n\n    FUNCTION_ORIGIN: list(FormalArg) -&gt; ORIGIN\n    NATIVE_FUNCTION_ORIGIN: list(NativeType) -&gt; ORIGIN\n    BUILTIN_ORIGIN: list(TYPE) -&gt; ORIGIN\n    PROP_ORIGIN: ORIGIN // prop names should be unique. TODO: how about non-unique properties in incorrect programs?\n    GENERATED_ORIGIN: int -&gt; ORIGIN  // unary identity-derived function\n\n  name-resolution\n    labels\n      P         // parent edge label for consecutive statements\n      F         // function edge label for embedding functions, templates and pages in a scope\n      EXTEND    // extend edge label for extending entities\n      INHERIT   // inherit edge label for subclasses\n      DEF       // definition edge label for embedding top-level definitions in the module scope\n      IMPORT    // import edge label for importing another module\n      IMPORTLIB // import edge label for importing statix libraries such as the built-in.app library\n      GLOBAL    // global edge label for edges from global scope to other modules\n\n  relations\n    mod : list(string) * scope\n\n    type : string * scope\n\n    extendscope : string * scope\n\n    page     : string * scope\n    template : string * scope\n    ac       : string * scope\n\n    function : string * ORIGIN * scope\n\n    var      : string * scope\n\n    typeOf : TYPE\n\nrules // module declaration and resolving\n\n  declareMod : scope * list(string) * scope\n  declareMod(s, m, s_mod) :-\n    !mod[m, s_mod] in s,\n    resolveMod(s, m) == [_] | error $[Module [m] is already declared].\n\n  resolveMod : scope * list(string) -&gt; list((path * (list(string) * scope)))\n  resolveMod(s, m) = ss :-\n    query mod filter e\n              and { m' :- m' == (m, _) }\n              in s |-&gt; ss.\n\n  resolveModWildcard : scope * list(string) -&gt; list((path * (list(string) * scope)))\n  resolveModWildcard(s, names) = /*modsOf(*/ ss /*)*/ :-\n    query mod filter e\n              and { m' :- isPrefix(names, m') }\n              in s |-&gt; ss.\n\n  isPrefix : list(string) * (list(string) * scope)\n  isPrefix(names, (names', _)) :- isPrefix_internal(names, names').\n\n  isPrefix_internal : list(string) * list(string)\n  isPrefix_internal([], _).\n  isPrefix_internal([x | xs], [x | ys]) :- isPrefix_internal(xs, ys).\n  isPrefix_internal(_, _) :- false.\n\nrules // type declaration and resolving\n\n  declareType : scope * string * TYPE\n  declareType(s, name, t) :-\n    !type[name, withType(t)] in s,\n    resolveType(s, name) == [(_, (_, t))] | error $[Type [name] is defined multiple times] @name.\n\n  resolveType : scope * string -&gt; list((path * (string * TYPE)))\n  resolveType(s, name) = typesOf(ts) :-\n    query type filter P* F* ((EXTEND? INHERIT*) | (DEF? (IMPORT | IMPORTLIB)?))\n               and { e' :- e' == (name, _) }\n               min $ &lt; IMPORTLIB, P &lt; IMPORTLIB, F &lt; IMPORTLIB, EXTEND &lt; IMPORTLIB, INHERIT &lt; IMPORTLIB, DEF &lt; IMPORTLIB, IMPORT &lt; IMPORTLIB\n               and true\n               in s |-&gt; ts.\n\n  withType : TYPE -&gt; scope\n  withType(t) = s :-\n    new s, !typeOf[t] in s.\n\n  typesOf maps typeOf(list(*)) = list(*)\n  typeOf : (path * (string * scope)) -&gt; (path * (string * TYPE))\n  typeOf((p, (x, s))) = (p, (x, t)) :-\n    query typeOf filter e in s |-&gt; [(_, t)].\n\n  typesOfStripOrigin maps typeOfStripOrigin(list(*)) = list(*)\n  typeOfStripOrigin : (path * (string * ORIGIN * scope)) -&gt; (path * (string * TYPE))\n  typeOfStripOrigin((p, (x, _, s))) = (p, (x, t)) :-\n    query typeOf filter e in s |-&gt; [(_, t)].\n\n  simpleTypeOf : scope -&gt; TYPE\n  simpleTypeOf(s) = t :-\n    query typeOf filter e in s |-&gt; [(_, t)].\n\nrules // extend entity declaration\n\n  declareExtendScope : scope * string * scope\n  declareExtendScope(s, e, s_extend) :-\n    !extendscope[e, s_extend] in s.\n\n  resolveExtendScope : scope * string -&gt; list((path * (string * scope)))\n  resolveExtendScope(s, x) = ps :-\n    query extendscope filter P* F* DEF? (IMPORT | IMPORTLIB)? GLOBAL?\n                      and { e' :- e' == (x, _) }\n                      min $ &lt; P, $ &lt; F, $ &lt; DEF, $ &lt; IMPORT, $ &lt; IMPORTLIB, $ &lt; GLOBAL,\n                          P &lt; F, P &lt; DEF, P &lt; IMPORT, P &lt; IMPORTLIB, P &lt; GLOBAL,\n                          F &lt; DEF, F &lt; IMPORT, F &lt; IMPORTLIB, F &lt; GLOBAL,\n                          DEF &lt; IMPORT, DEF &lt; IMPORTLIB, DEF &lt; GLOBAL,\n                          IMPORT &lt; GLOBAL, IMPORTLIB &lt; GLOBAL\n                      and { (entity, entity_scope), (entity, entity_scope) }\n                      in s |-&gt; ps.\n\nrules // ui declaration and resolving\n\n  declareTemplate : scope * string * list(TYPE)\n  declareTemplate(s, t, ts) :- declareTemplate_internal(s, t, ts, FALSE()).\n\n  declareAjaxTemplate : scope * string * list(TYPE)\n  declareAjaxTemplate(s, t, ts) :- declareTemplate_internal(s, t, ts, TRUE()).\n\n  declareTemplate_internal : scope * string * list(TYPE) * BOOL\n  declareTemplate_internal(s, t, ts, ajax) :-\n    !template[t, withType(TEMPLATE(t, ts, ajax))] in s,\n    resolvePage(s, t) == [] | error $[Multiple page/template definitions with name [t]] @t,\n    filterTemplateResultsArgs(resolveTemplate(s, t), ts) == [_] | error $[Multiple page/template definitions with name [t] and argument types [ts]] @t. // correct error message for tests\n\n  declarePage : scope * string * list(TYPE)\n  declarePage(s, p, ts) :-\n    !page[p, withType(PAGE(p, ts))] in s,\n    resolveTemplate(s, p) == [] | error $[Multiple page/template definitions with name [p]] @p, // correct error message for tests\n    resolvePage(s, p) == [_] | error $[Multiple page/template definitions with name [p]] @p. // correct error message for tests\n\n  resolveTemplate : scope * string -&gt; list((path * (string * TYPE)))\n  resolveTemplate(s, t) = resolveTemplate_internal(s, t, FALSE()).\n\n  resolveAjaxTemplate : scope * string -&gt; list((path * (string * TYPE)))\n  resolveAjaxTemplate(s, t) = resolveTemplate_internal(s, t, TRUE()).\n\n  resolveTemplate_internal : scope * string * BOOL -&gt; list((path * (string * TYPE)))\n  resolveTemplate_internal(s, t, FALSE()) = typesOf(ps) :-\n    query template filter P* F* ((EXTEND? (INHERIT EXTEND?)*) | (DEF? (IMPORT | IMPORTLIB)?))\n                   and { t' :- t' == (t, _) }\n                   in s |-&gt; ps.\n\n  resolveTemplate_internal(s, t, TRUE()) = filterTemplateResultsAjax(resolveTemplate_internal(s, t, FALSE()), TRUE()).\n\n  resolveTemplateNoAjax : scope * string -&gt; list((path * (string * TYPE)))\n  resolveTemplateNoAjax(s, t) = filterTemplateResultsAjax(resolveTemplate_internal(s, t, FALSE()), FALSE()).\n\n  filterTemplateResultsAjax : list((path * (string * TYPE))) * BOOL -&gt; list((path * (string * TYPE)))\n  filterTemplateResultsAjax([], _) = [].\n  filterTemplateResultsAjax([t@(_, (_, TEMPLATE(_, _, b))) | ts], b) = [t | filterTemplateResultsAjax(ts, b)].\n  filterTemplateResultsAjax([_ | ts], b) = filterTemplateResultsAjax(ts, b).\n\n  filterTemplateResultsArgs : list((path * (string * TYPE))) * list(TYPE) -&gt; list((path * (string * TYPE)))\n  filterTemplateResultsArgs([], _) = [].\n  filterTemplateResultsArgs([t@(_, (_, TEMPLATE(_, args, _))) | ts], args) = [t | filterTemplateResultsArgs(ts, args)].\n  filterTemplateResultsArgs([_ | ts], args) = filterTemplateResultsArgs(ts, args).\n\n  resolvePage : scope * string -&gt; list((path * (string * TYPE)))\n  resolvePage(s, p) = typesOf(ps) :-\n    query page filter P* F* ((EXTEND? (INHERIT EXTEND?)*) | (DEF? (IMPORT | IMPORTLIB)?))\n               and { p' :- p' == (p, _) }\n               in s |-&gt; ps.\n\nrules // ac rules\n\n  declarePointcut : scope * string * list(TYPE)\n  declarePointcut(s, p, ts) :-\n    !ac[p, withType(POINTCUT(p, ts))] in s,\n    resolvePointcut(s, p) == [_] | error $[Pointcut [p] is defined multiple times] @p.\n\n  resolvePointcut : scope * string -&gt; list((path * (string * TYPE)))\n  resolvePointcut(s, p) = typesOf(ps) :-\n    query ac filter P* F* ((EXTEND? (INHERIT EXTEND?)*) | (DEF? (IMPORT | IMPORTLIB)?))\n             and { p' :- p' == (p, _) }\n             in s |-&gt; ps.\n\nrules // function declaration and resolving\n\n  declareFunction : scope * string * ORIGIN * list(TYPE) * TYPE\n  declareFunction(s, f, origin, args, return) :- declareFunction_internal(s, f, origin, args, return, FALSE()).\n\n  declareStaticFunction : scope * string * ORIGIN * list(TYPE) * TYPE\n  declareStaticFunction(s, f, origin, args, return) :- declareFunction_internal(s, f, origin, args, return, TRUE()).\n\n  declareFunction_internal : scope * string * ORIGIN * list(TYPE) * TYPE * BOOL\n  declareFunction_internal(s, f, origin, args, return, static) :- { s_type }\n    s_type == withType(FUNCTION(f, args, return, static)),\n    !function[f, origin, s_type] in s.\n\n  resolveFunction : scope * string -&gt; list((path * (string * TYPE)))\n  resolveFunction(s, f) = filterFunctionResults(typesOfStripOrigin(ps), FALSE()) :-\n    query function filter P* F* ((EXTEND? (INHERIT EXTEND?)*) | (DEF? (IMPORT | IMPORTLIB)?))\n                   and { f' :- f' == (f, _, _) }\n                   in s |-&gt; ps.\n\n  resolveEntityFunction : scope * string -&gt; list((path * (string * TYPE)))\n  resolveEntityFunction(s, x) = filterFunctionResults(typesOfStripOrigin(ps), FALSE()) :-\n    query function filter EXTEND? (INHERIT EXTEND?)*\n                   and { x' :- x' == (x, _, _) }\n                   min $ &lt; INHERIT, EXTEND &lt; INHERIT // do not shadow EXTEND with $\n                   and { (f, _, T1), (f, _, T2) :- {args}\n                     simpleTypeOf(T1) == FUNCTION(f, args, _, _),\n                     simpleTypeOf(T2) == FUNCTION(f, args, _, _)\n                   } // only shadow when function has the same name and argument types\n                   in s |-&gt; ps.\n\n  resolveStaticEntityFunction : scope * string -&gt; list((path * (string * TYPE)))\n  resolveStaticEntityFunction(s, x) = filterFunctionResults(typesOfStripOrigin(ps), TRUE()) :-\n    query function filter EXTEND? (INHERIT EXTEND?)*\n                   and { x' :- x' == (x, _, _) }\n                   min $ &lt; INHERIT, EXTEND &lt; INHERIT // do not shadow EXTEND with $\n                   and { (f, _, T1), (f, _, T2) :- {args}\n                     simpleTypeOf(T1) == FUNCTION(f, args, _, _),\n                     simpleTypeOf(T2) == FUNCTION(f, args, _, _)\n                   } // only shadow when function has the same name and argument types\n                   in s |-&gt; ps.\n\n  // last BOOL arg indiciates if only static function should be returned (TRUE()) or all functions (FALSE())\n  filterFunctionResults : list((path * (string * TYPE))) * BOOL -&gt; list((path * (string * TYPE)))\n  filterFunctionResults([], _) = [].\n  filterFunctionResults([f@(_, (_, FUNCTION(_, _, _, TRUE()))) | fs], b@TRUE()) = [f | filterFunctionResults(fs, b)].\n  filterFunctionResults([f@(_, (_, FUNCTION(_, _, _, _))) | fs], b@FALSE()) = [f | filterFunctionResults(fs, b)].\n  filterFunctionResults([_ | fs], b) = filterFunctionResults(fs, b).\n\nrules // action and placeholder declaration and resolving\n\n  declareAction : scope * string * ORIGIN * list(TYPE)\n  declareAction(s, a, origin, ts) :-\n    !function[a, origin, withType(ACTION(a, ts))] in s,\n    resolveAction(s, a) == [(_, (_, ACTION(a, ts)))] | error $[Action [a] is defined multiple times] @a.\n\n  resolveAction : scope * string -&gt; list((path * (string * TYPE)))\n  resolveAction(s, a) = filterActionResults(typesOfStripOrigin(as)) :-\n    query function filter P*\n                   and { a' :- a' == (a, _, _) }\n                   in s |-&gt; as.\n\n  declarePlaceholder : scope * string\n  declarePlaceholder(s, ph) :-\n    !var[ph, withType(placeholder(s))] in s,\n    noDuplicateVarDefs(s, ph) | error $[Variable [ph] is defined multiple times] @ph.\n\n  resolvePlaceholder : scope * string -&gt; list((path * (string * TYPE)))\n  resolvePlaceholder(s, ph) = result :- { ph_scopes phs }\n    query var filter P*\n              and { ph' :- ph' == (ph, _) }\n              in s |-&gt; ph_scopes,\n    phs == typesOf(ph_scopes),\n    result == filterPlaceholderResults(phs).\n\n  filterActionResults : list((path * (string * TYPE))) -&gt; list((path * (string * TYPE)))\n  filterActionResults([]) = [].\n  filterActionResults([a@(_, (_, ACTION(_, _))) | as]) = [a | filterActionResults(as)].\n  filterActionResults([_ | as]) = filterActionResults(as).\n\n  filterPlaceholderResults : list((path * (string * TYPE))) -&gt; list((path * (string * TYPE)))\n  filterPlaceholderResults([]) = [].\n  filterPlaceholderResults([ph@(_, (_, BUILTINTYPE(\"Placeholder\", _))) | phs]) = [ph | filterPlaceholderResults(phs)].\n  filterPlaceholderResults([_ | phs]) = filterPlaceholderResults(phs).\n\nrules // variable declaration and resolving\n\n  declareVar : scope * string * TYPE\n  declareVar(s, x, t) :-\n    !var[x, withType(t)] in s,\n    noDuplicateVarDefs(s, x) | error $[A variable named [x] already exists in this scope].\n\n  resolveVar : scope * string -&gt; list((path * (string * TYPE)))\n  resolveVar(s, x) = typesOf(ps) :-\n    query var filter P* F* ((EXTEND? (INHERIT EXTEND?)*) | (DEF? (IMPORT | IMPORTLIB)?))\n              and { x' :- x' == (x, _) }\n              min $ &lt; P, P &lt; F, F &lt; EXTEND, EXTEND &lt; INHERIT, INHERIT &lt; DEF, DEF &lt; IMPORT, IMPORT &lt; IMPORTLIB\n              and true\n              in s |-&gt; ps.\n\n  resolveProperty : scope * string -&gt; list((path * (string * TYPE)))\n  resolveProperty(s_entity, x) = typesOf(ps) :-\n    query var filter EXTEND? (INHERIT EXTEND?)*\n              and { x' :- x' == (x, _) }\n              in s_entity |-&gt; ps.\n\n  resolveLocalProperty : scope * string -&gt; list((path * (string * TYPE)))\n  resolveLocalProperty(s_entity, x) = typesOf(ps) :-\n    query var filter EXTEND?\n              and { x' :- x' == (x, _) }\n              in s_entity |-&gt; ps.\n\n  resolveMutableProperty : scope * string -&gt; list((path * (string * TYPE)))\n  resolveMutableProperty(s_entity, x) = typesOf(ps) :-\n    query var filter EXTEND? (INHERIT EXTEND?)*\n              and { x' :- x' == (x, _) }\n              in s_entity |-&gt; ps.\n\n  declareParameters : scope * list((string * TYPE))\n  declareParameters(s, []).\n  declareParameters(s, [(x, t)|tail]) :-\n    declareVar(s, x, t),\n    declareAnnotation(s, x, DERIVED()), // abuse derived annotation to declare immutability of parameters\n    declareParameters(s, tail).\n\n  declareParameters(s, [(x, t@TEMPLATEELEMENTS()) | tail]) :-\n    declareVar(s, x, t),\n    declareAnnotation(s, x, DERIVED()), // abuse derived annotation to declare immutability of parameters\n    declareTemplate(s, x, []),\n    declareParameters(s, tail).\n\nrules // declare common rules and mappings\n\n  unitOk : scope * Unit\n  unitOk(_, EmptyUnit()).\n\n  sectionsOk maps sectionOk(*, list(*))\n  sectionOk : scope * Section\n  sectionOk(_, ACPolicy(_)) :- try { false } | warning $[This section is not yet implemented].\n  sectionOk(s, Section(_, defs)) :- defsOk(s, defs).\n\n  defsOk maps defOk(*, list(*))\n  defOk : scope * Definition\n  defOk(_, Description(_)) :- try { false } | warning $[This definition is not yet implemented].\n  defOk(_, Note(_)) :- try { false } | warning $[This definition is not yet implemented].\n  defOk(_, Routing(_)) :- try { false } | warning $[This definition is not yet implemented].\n\n  stmtOk : scope * scope * Statement * TYPE // TYPE argument is the return type in a function\n\n  stmtsOk : scope * list(Statement) * TYPE\n  stmtsOk(_, [], _).\n  stmtsOk(s, [stmt | tail], rt) :- {s_decl s_next}\n    new s_decl, s_decl -P-&gt; s,\n    new s_next, s_next -P-&gt; s_decl,\n    stmtOk(s, s_decl, stmt, rt),\n    stmtsOk(s_next, tail, rt).\n\n  expOk : scope * Exp\n  expOk(s, exp) :- { T }\n    typeOfExp(s, exp) == T.\n\n  declareBuiltIns : scope\n  declareBuiltIns(s) :-\n//    declareACBuiltIns(s), do this separately in Application instead of built-in\n    declareFunctionIns(s),\n    declareEntityBuiltIns(s),\n    declareSearchBuiltIns(s),\n    declareTypeBuiltIns(s),\n    declareTypeBuiltInFunctions(s),\n    declareUIBuiltIns(s).\n\nrules // typing\n\n  typesOfExps maps typeOfExp(*, list(*)) = list(*)\n  typeOfExp : scope * Exp -&gt; TYPE\n\n  typeOfExpTyped : scope * Exp -&gt; TYPE\n  typeOfExpTyped(s, exp) = t :-\n    t == typeOfExp(s, exp),\n    t != UNTYPED() | error $[Cannot resolve type [t]] @exp.\n\n  typeOfSimpleExp : scope * SimpleExp -&gt; TYPE\n  typeOfSimpleExp(s, exp) = UNTYPED() :- try { false } | warning $[typing of expression [exp] is not yet implemented].\n\n  typeOfPlaceholderExp : scope * PHExp -&gt; TYPE\n  typeOfPlaceholderExp(s, exp) = UNTYPED() :- try { false } | warning $[typing of expression [exp] is not yet implemented].\n\n  typesCompatible : list(TYPE) * list(TYPE) -&gt; BOOL\n  typesCompatible([], []) = TRUE().\n  typesCompatible([], [_|_]) = FALSE().\n  typesCompatible([_|_], []) = FALSE().\n  typesCompatible([t1|t1s], [t2|t2s]) = andB(typeCompatibleB(t1, t2), typesCompatible(t1s, t2s)).\n\n  typesCompatibleWith maps typeCompatible(list(*), *)\n  typeCompatible : TYPE * TYPE\n  typeCompatible(T1, T2) :- typeCompatibleB(T1, T2) == TRUE().\n\n  typeCompatibleB : TYPE * TYPE -&gt; BOOL\n  typeCompatibleB(T1, T2) = FALSE(). //default\n  typeCompatibleB(T, T) = TRUE(). // same type is always type compatible\n\nrules // utils\n\n  or : BOOL * BOOL\n  or(b1, b2) :- orB(b1, b2) == TRUE().\n  orB : BOOL * BOOL -&gt; BOOL\n  orB(_, _) = FALSE().\n  orB(TRUE(), _) = TRUE().\n  orB(FALSE(), TRUE()) = TRUE().\n\n  andB : BOOL * BOOL -&gt; BOOL\n  andB(_, _) = FALSE().\n  andB(TRUE(), TRUE()) = TRUE().\n\n  equalB : BOOL * BOOL\n  equalB(b, b).\n  equalB(_, _) :- false.\n\n  notB : BOOL -&gt; BOOL\n  notB(TRUE()) = FALSE().\n  notB(FALSE()) = TRUE().\n\n  emtpyQueryResultB : list((path * (string * TYPE))) -&gt; BOOL\n  emtpyQueryResultB([]) = TRUE().\n  emtpyQueryResultB([_ | _]) = FALSE().\n\n  minOfList : list(int) -&gt; int\n  minOfList([]) = 100000.\n  minOfList([x|xs]) = z :- {y}\n    y == minOfList(xs),\n    z #= min(x,y).\n\n  scopeFromPath : path -&gt; scope\n  scopeFromPath(_PathEmpty(s)) = s.\n  scopeFromPath(_PathStep(_, _, s)) = s.\n\n  pathLength : path -&gt; int\n  pathLength(_PathEmpty(_)) = 0.\n  pathLength(_PathStep(p, _, _)) = x :- {x'}\n    x' == pathLength(p),\n    x #= x' + 1.\n\n  noDuplicatesString : string * list(string)\n  noDuplicatesString(_, []).\n  noDuplicatesString(\"_IGNORE\", _).\n  noDuplicatesString(x, [\"_IGNORE\" | ys]) :- noDuplicatesString(x, ys).\n  noDuplicatesString(x, [y | ys]) :- noDuplicatesString(x, ys).\n  noDuplicatesString(x, [x | _]) :- false.\n\n  addQueryResults : list((path * (string * TYPE))) * list((path * (string * TYPE))) -&gt; list((path * (string * TYPE)))\n  addQueryResults([], ls) = ls.\n  addQueryResults([hd | tl], ls) = [hd | addQueryResults(tl, ls)].\n\n  // functional rule to drop all results with longer paths than the minimal\n  filterShortestPath : list((path * (string * TYPE))) -&gt; list((path * (string * TYPE)))\n  filterShortestPath(ps) = filterShortestPath_internal(zipQueryResultsWithPathLength(ps), shortestPathLength(ps)).\n\n  filterShortestPath_internal : list((int * (path * (string * TYPE)))) * int -&gt; list((path * (string * TYPE)))\n  filterShortestPath_internal([], _) = [].\n  filterShortestPath_internal([(x, r) | ps], x) = [r | filterShortestPath_internal(ps, x)].\n  filterShortestPath_internal([_      | ps], x) = filterShortestPath_internal(ps, x).\n\n  shortestPathLength : list((path * (string * TYPE))) -&gt; int\n  shortestPathLength([]) = 10000.\n  shortestPathLength([(p, _) | ps]) = z :- {x y}\n    x == pathLength(p),\n    y == shortestPathLength(ps),\n    z #= min(x, y).\n\n  zipQueryResultsWithPathLength maps zipQueryResultWithPathLength(list(*)) = list(*)\n  zipQueryResultWithPathLength : (path * (string * TYPE)) -&gt; (int * (path * (string * TYPE)))\n  zipQueryResultWithPathLength(r@(p, _)) = (pathLength(p), r).\n\n  queryResultTypes maps queryResultType(list(*)) = list(*)\n  queryResultType : (path * (string * TYPE)) -&gt; TYPE\n  queryResultType((_, (_, t))) = t.\n\n  argNames maps argName(list(*)) = list(*)\n  argName : FormalArg -&gt; string\n  argName(Arg(x, _)) = x.\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/webdsl.stx/#modal-h2","title":"webdsl.stx","text":""},{"location":"webdslstatix/trans/static-semantics/actions/binops.stx/","title":"<code>binops.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/actions/binops.stx</p> <pre><code>module static-semantics/actions/binops\n\nimports\n  static-semantics/types/built-ins\n\n  static-semantics/webdsl-types\n  static-semantics/webdsl\n\nrules // binary operators\n  // (e1 + e2)\n  typeOfExp(s, exp@Add(e1, e2)) = T :-\n    typeOfAdd(s, e1, e2) == T,\n    @exp.type := T.\n\n  typeOfPlaceholderExp(s, exp@PHAdd(e1, e2)) = T :-\n    typeOfAdd(s, e1, e2) == T,\n    @exp.type := T.\n\n  typeOfAdd : scope * Exp * Exp -&gt; TYPE\n  typeOfAdd(s, e1, e2) = T :- { T1 T2 }\n    typeOfExp(s, e1) == T1,\n    typeOfExp(s, e2) == T2,\n    lubForAdd(T1, T2) == T,\n    inequalType(T, UNTYPED()) | error $[Wrong operand types for operator Add: [e1] has type [T1], [e2] has type [T2]]. // correct error message for tests\n\n  // (e1 - e2)\n  typeOfExp(s, exp@Sub(e1, e2)) = T :- { T1 T2 }\n    typeOfExp(s, e1) == T1,\n    typeOfExp(s, e2) == T2,\n    lubForAddNumeric(T1, T2) == T,\n    inequalType(T, UNTYPED()) | error $[Wrong operand types for operator Sub: [e1] has type [T1], [e2] has type [T2]], // correct error message for tests\n    @exp.type := T.\n\n  // (e1 * e2)\n  typeOfExp(s, exp@Mul(e1, e2)) = T :- { T1 T2 }\n    typeOfExp(s, e1) == T1,\n    typeOfExp(s, e2) == T2,\n    lubForAddNumeric(T1, T2) == T,\n    inequalType(T, UNTYPED()) | error $[Wrong operand types for operator Mul: [e1] has type [T1], [e2] has type [T2]], // correct error message for tests\n    @exp.type := T.\n\n  // (e1 / e2)\n  typeOfExp(s, exp@Div(e1, e2)) = T :- { T1 T2 }\n    typeOfExp(s, e1) == T1,\n    typeOfExp(s, e2) == T2,\n    lubForAddNumeric(T1, T2) == T,\n    inequalType(T, UNTYPED()) | error $[Wrong operand types for operator Div: [e1] has type [T1], [e2] has type [T2]], // correct error message for tests\n    @exp.type := T.\n\n  // (e1 % e2)\n  typeOfExp(s, exp@Mod(e1, e2)) = T :- { T1 T2 }\n    typeOfExp(s, e1) == T1,\n    typeOfExp(s, e2) == T2,\n    lubForAddNumeric(T1, T2) == T,\n    inequalType(T, UNTYPED()) | error $[Wrong operand types for operator Mod: [e1] has type [T1], [e2] has type [T2]], // correct error message for tests\n    @exp.type := T.\n\n  // (e1 &gt; e2)\n  typeOfExp(s, exp@LargerThan(e1, e2)) = t :- { T1 T2 }\n    t == bool(s),\n    typeOfExp(s, e1) == T1,\n    typeOfExp(s, e2) == T2,\n    lubForAddNumeric(T1, T2) != UNTYPED() | error $[Wrong operand types for operator LargerThan: [e1] has type [T1], [e2] has type [T2]], // correct error message for tests\n    @exp.type := t.\n\n  // (e1 &gt;= e2)\n  typeOfExp(s, exp@LargerThanOrEqual(e1, e2)) = t :- { T1 T2 }\n    t == bool(s),\n    typeOfExp(s, e1) == T1,\n    typeOfExp(s, e2) == T2,\n    lubForAddNumeric(T1, T2) != UNTYPED() | error $[Wrong operand types for operator LargerThanOrEqual: [e1] has type [T1], [e2] has type [T2]], // correct error message for tests\n    @exp.type := t.\n\n  // (e1 &lt; e2)\n  typeOfExp(s, exp@SmallerThan(e1, e2)) = t :- { T1 T2 }\n    t == bool(s),\n    typeOfExp(s, e1) == T1,\n    typeOfExp(s, e2) == T2,\n    lubForAddNumeric(T1, T2) != UNTYPED() | error $[Wrong operand types for operator SmallerThan: [e1] has type [T1], [e2] has type [T2]], // correct error message for tests\n    @exp.type := t.\n\n  // (e1 &lt;= e2)\n  typeOfExp(s, exp@SmallerThanOrEqual(e1, e2)) = t :- { T1 T2 }\n    t == bool(s),\n    typeOfExp(s, e1) == T1,\n    typeOfExp(s, e2) == T2,\n    lubForAddNumeric(T1, T2) != UNTYPED() | error $[Wrong operand types for operator SmallerThanOrEqual: [e1] has type [T1], [e2] has type [T2]], // correct error message for tests\n    @exp.type := t.\n\n  // (e1 &amp;&amp; e2)\n  typeOfExp(s, exp@And(e1, e2)) = b :- { T1 T2 }\n    b == bool(s),\n    typeOfExp(s, e1) == T1, typeCompatible(T1, b) | error $[Wrong operand types for operator And: [e1] has type [T1], expected Bool], // correct error message for tests\n    typeOfExp(s, e2) == T2, typeCompatible(T2, b) | error $[Wrong operand types for operator And: [e2] has type [T2], expected Bool], // correct error message for tests\n    @exp.type := b.\n\n  // (e1 || e2)\n  typeOfExp(s, exp@Or(e1, e2)) = b :- { T1 T2 }\n    b == bool(s),\n    typeOfExp(s, e1) == T1, typeCompatible(T1, b) | error $[Wrong operand types for operator Or: [e1] has type [T1], expected Bool], // correct error message for tests\n    typeOfExp(s, e2) == T2, typeCompatible(T2, b) | error $[Wrong operand types for operator Or: [e2] has type [T2], expected Bool], // correct error message for tests\n    @exp.type := b.\n\n  // (e1 == e2)\n  typeOfExp(s, exp@Eq(e1, e2)) = t :- { T1 T2 }\n    t == bool(s),\n    typeOfExp(s, e1) == T1,\n    typeOfExp(s, e2) == T2,\n    or(\n      typeCompatibleB(T1, T2),\n      typeCompatibleB(T2, T1)\n    ) | error $[Wrong operand types for operator Eq: [e1] has type [T1], [e2] has type [T2]], // correct error message for tests\n    @exp.type := t.\n\n  // (e1 != e2)\n  typeOfExp(s, exp@NotEq(e1, e2)) = t :- { T1 T2 }\n    t == bool(s),\n    typeOfExp(s, e1) == T1,\n    typeOfExp(s, e2) == T2,\n    or(\n      typeCompatibleB(T1, T2),\n      typeCompatibleB(T2, T1)\n    ) | error $[Wrong operand types for operator !=: [e1] has type [T1], [e2] has type [T2]], // correct error message for tests\n    @exp.type :=t.\n\n  // e1 in e2\n  typeOfExp(s, exp@InColl(e1, e2)) = bool(s) :- { T1 T2 }\n    typeOfExp(s, e1) == T1,\n    stripGenericType(typeOfExp(s, e2)) == T2,\n    typeCompatible(T1, T2) | error $[Wrong operand types for operator in: [e1] has type [T1], [e2] has type [T2]]. // correct error message for tests\n\nrules // unary operators\n\n  // (!e)\n  typeOfExp(s, exp@Not(e)) = t :- { T }\n    t == bool(s),\n    typeOfExp(s, e) == T,\n    T == t | error $[Wrong operand types for operator !: [e] has type [T], expected Bool], // correct error message for tests\n    @exp.type := t.\n\nrules // utils\n\n  lubForAdd : TYPE * TYPE -&gt; TYPE\n  lubForAdd(T1, T2) = lubForAddNumeric(T1, T2).\n  lubForAdd(t@BUILTINTYPE(\"String\", _), _) = t.\n  lubForAdd(_, t@BUILTINTYPE(\"String\", _)) = t.\n\n  lubForAddNumeric : TYPE * TYPE -&gt; TYPE\n  lubForAddNumeric(_, _) = UNTYPED().\n  lubForAddNumeric(t@BUILTINTYPE(\"Int\", _)    , t) = t.\n  lubForAddNumeric(t@BUILTINTYPE(\"Long\", _)   , t) = t.\n  lubForAddNumeric(t@BUILTINTYPE(\"Float\", _)  , t) = t.\n  lubForAddNumeric(t@NATIVECLASS(\"Double\", _) , t) = t.\n\n  // implicit widening from int to long\n  lubForAddNumeric(BUILTINTYPE(\"Int\", _)      , t@BUILTINTYPE(\"Long\", _))   = t.\n  lubForAddNumeric(t@BUILTINTYPE(\"Long\", _)   , BUILTINTYPE(\"Int\", _))      = t.\n\n  // implicit widening from float to double\n  lubForAddNumeric(t@NATIVECLASS(\"Double\", _) , BUILTINTYPE(\"Float\", _))    = t.\n  lubForAddNumeric(BUILTINTYPE(\"Float\", _)    , t@NATIVECLASS(\"Double\", _)) = t.\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/actions/binops.stx/#modal-h2","title":"binops.stx","text":""},{"location":"webdslstatix/trans/static-semantics/actions/built-ins.stx/","title":"<code>built-ins.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/actions/built-ins.stx</p> <pre><code>module static-semantics/actions/built-ins\n\nimports\n  static-semantics/types/built-ins\n  static-semantics/webdsl-built-ins\n  static-semantics/webdsl-types\n  static-semantics/webdsl\n\nrules\n\n  declareFunctionIns : scope\n  declareFunctionIns(s) :- { datetime date string time int float uuid void bool object url entity }\n    datetime  == datetime(s),\n    date      == date(s),\n    string    == string(s),\n    time      == time(s),\n    int       == int(s),\n    float     == float(s),\n    uuid      == uuid(s),\n    void      == VOID(),\n    bool      == bool(s),\n    object    == object(s),\n    url       == url(s),\n    entity    == entity(s),\n\n    declareBuiltInFunction(s, \"now\"     , []               , datetime),\n    declareBuiltInFunction(s, \"today\"   , []               , date),\n    declareBuiltInFunction(s, \"Date\"    , [string, string] , date),\n    declareBuiltInFunction(s, \"Date\"    , [string]         , date),\n    declareBuiltInFunction(s, \"Time\"    , [string, string] , time),\n    declareBuiltInFunction(s, \"Time\"    , [string]         , time),\n    declareBuiltInFunction(s, \"DateTime\", [string, string] , datetime),\n    declareBuiltInFunction(s, \"DateTime\", [string]         , datetime),\n    declareBuiltInFunction(s, \"random\"  , [int, int]       , int),\n    declareBuiltInFunction(s, \"random\"  , [int]            , int),\n    declareBuiltInFunction(s, \"random\"  , []               , float),\n    declareBuiltInFunction(s, \"url\"     , [string]         , url),\n\n    declareBuiltInFunction(s, \"randomUUID\"     , []      , uuid),\n    declareBuiltInFunction(s, \"UUIDFromString\" , [string], uuid),\n\n    declareBuiltInFunction(s, \"getSessionManager\", [], definedTypeNoRef(s, \"SessionManager\")),\n\n    declareBuiltInFunction(s, \"cancel\"  , [], void),\n    declareBuiltInFunction(s, \"rollback\", [], void),\n    declareBuiltInFunction(s, \"flush\"   , [], void),\n\n    declareBuiltInFunction(s, \"getValidationErrorsByName\", [string], LIST(string)),\n\n    declareBuiltInFunction(s, \"getHttpMethod\"          , []      , string),\n    declareBuiltInFunction(s, \"getRequestParameter\"    , [string], string),\n    declareBuiltInFunction(s, \"getRequestParameterList\", [string], LIST(string)),\n    declareBuiltInFunction(s, \"readRequestBody\"        , []      , string),\n\n    declareBuiltInFunction(s, \"attribute\"          , [string]        , string),\n    declareBuiltInFunction(s, \"attribute\"          , [string, string], string),\n    declareBuiltInFunction(s, \"hasNotNullAttribute\", []              , bool),\n\n    declareBuiltInFunction(s, \"message\", [string], void),\n    declareBuiltInFunction(s, \"log\"    , [object], void),\n\n    declareBuiltInFunction(s, \"assert\", [bool], void),\n    declareBuiltInFunction(s, \"assert\", [bool, string], void),\n    declareBuiltInFunction(s, \"assertEquals\", [object, object], void),\n    declareBuiltInFunction(s, \"assertEquals\", [object, object, string], void),\n    declareBuiltInFunction(s, \"assertNotSame\", [object, object], void),\n    declareBuiltInFunction(s, \"assertNotSame\", [object, object, string], void),\n\n    declareBuiltInFunction(s, \"loadEntity\", [string, uuid], entity).\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/actions/built-ins.stx/#modal-h2","title":"built-ins.stx","text":""},{"location":"webdslstatix/trans/static-semantics/actions/emails.stx/","title":"<code>emails.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/actions/emails.stx</p> <pre><code>module static-semantics/actions/emails\n\nimports\n  static-semantics/types/built-ins\n\n  static-semantics/webdsl\n\nrules\n\n  typeOfExp(s, SendEmailFunctionCall(e)) = bool(s) :- /* TO-DO: implement validation of email call */\n    try { false } | warning $[Static analysis of email call not yet implemented] .\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/actions/emails.stx/#modal-h2","title":"emails.stx","text":""},{"location":"webdslstatix/trans/static-semantics/actions/functions.stx/","title":"<code>functions.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/actions/functions.stx</p> <pre><code>module static-semantics/actions/functions\n\nimports\n  static-semantics/types/built-ins\n\n  static-semantics/webdsl-actions\n  static-semantics/webdsl-entities\n  static-semantics/webdsl-types\n  static-semantics/webdsl\n\nrules // functions calls\n\n  typeOfExp(s, ThisCall2Exp(ThisCall(f, argExps))) = t :-\n    t == typeOfFunctionCall(s, f, argExps).\n\n  typeOfSimpleExp(s, SimpleThisCall(ThisCall(f, argExps))) = t :-\n    t == typeOfFunctionCall(s, f, argExps).\n\n  typeOfPlaceholderExp(s, PHThisCall(ThisCall(f, argExps))) = t :-\n    t == typeOfFunctionCall(s, f, argExps).\n\n  typeOfExp(s, Call(exp, f, argExps)) = t :- { expType s_eval }\n    expType == typeOfExp(s, exp),\n    new s_eval, s_eval -P-&gt; s,\n    t == typeOfCall(s_eval, expType, f, argExps).\n\n  typeOfSimpleExp(s, SimpleCall(exp, f, argExps)) = t :- { expType s_eval }\n    expType == typeOfSimpleExp(s, exp),\n    new s_eval, s_eval -P-&gt; s,\n    t == typeOfCall(s_eval, expType, f, argExps).\n\n  typeOfPlaceholderExp(s, PHCall(exp, f, argExps)) = t :- { expType s_eval }\n    expType == typeOfExp(s, exp),\n    new s_eval, s_eval -P-&gt; s,\n    t == typeOfCall(s_eval, expType, f, argExps).\n\n  typeOfFunctionCall : scope * string * list(Exp)-&gt; TYPE\n  typeOfFunctionCall(s, f, args) = typeOfFunctionCallInternal(s, f, args, funSigs) :-\n    funSigs == resolveFunction(s, f).\n\n  typeOfCall : scope * TYPE * string * list(Exp)-&gt; TYPE\n  typeOfCall(s, ENTITY(_, s_ent), f, args) = typeOfFunctionCallInternal(s, f, args, funSigs) :-\n    funSigs == resolveEntityFunction(s_ent, f).\n\n  typeOfCall(s, STATICENTITY(_, s_ent), f, args) = typeOfFunctionCallInternal(s, f, args, funSigs) :-\n    funSigs == resolveStaticEntityFunction(s_ent, f).\n\n  typeOfCall(s, REF(t), f, args) = typeOfCall(s, t, f, args).\n  typeOfCall(s, t, f, args) = UNTYPED() :- false | error $[First subexpression of a function call must be of type entity, [t] found].\n\n  typeOfFunctionCallInternal : scope * string * list(Exp) * list((path * (string * TYPE))) -&gt; TYPE\n  typeOfFunctionCallInternal(s, f, args, funSigs) = t :- { argTypes f' result }\n    argTypes == typesOfExps(s, args),\n    result == mostSpecificSigs(argTypes, typeCompatibleSigs(funSigs, argTypes)),\n    [(f', FUNCTION(_, _, t, _))] == result | error $[Cannot resolve function [f] with compatible argument types] @f,\n    @f.ref := f',\n    @f.type := t.\n\n  singleSignature : list((string * TYPE)) * string * string\n  singleSignature([], type, f) :- false | error $[Cannot resolve [type] [f] with compatible argument types] @f.\n  singleSignature([_ | [_ | _]], type, f) :- false | error $[Found multiple definitions of [type] [f] with equally specific argument types] @f.\n  singleSignature(_, _, _).\n\nrules // invoke time interval\n\n  defOk(s, InvokeEvery(exp, TimeInterval(parts))) :-\n    typed(s, exp),\n    timeIntervalPartsOk(s, parts).\n\n  timeIntervalPartsOk maps timeIntervalPartOk(*, list(*))\n  timeIntervalPartOk : scope * TimeIntervalPart\n  timeIntervalPartOk(s, Weeks(exp))        :- typeOfExp(s, exp) == int(s).\n  timeIntervalPartOk(s, Days(exp))         :- typeOfExp(s, exp) == int(s).\n  timeIntervalPartOk(s, Hours(exp))        :- typeOfExp(s, exp) == int(s).\n  timeIntervalPartOk(s, Minutes(exp))      :- typeOfExp(s, exp) == int(s).\n  timeIntervalPartOk(s, Seconds(exp))      :- typeOfExp(s, exp) == int(s).\n  timeIntervalPartOk(s, Milliseconds(exp)) :- typeOfExp(s, exp) == int(s).\n\nrules // function definitions\n\n  // global functions\n  defOk(s, GlobalFunction(f)) :- globalFunctionOk(s, f).\n  defOk(s, CachedGlobalFunction(f)) :-\n    canBeCached(s, f),\n    globalFunctionOk(s, f).\n\n  defOk(s, ExtendGlobalFunction(_)) :- try { false } | warning $[This definition is not yet implemented].\n\n  // analyze a function:\n  // - argument types and return type must be defined\n  // - declare arguments as variables in function scope\n  // - analyze function body\n  // - declare function in given scope\n  globalFunctionOk : scope * Function\n  globalFunctionOk(s_outer, Function(name, FormalArgs(args), OptSortSome(returnSort), Block(stmts))) :- { argTypes returnType s_function s_body }\n    returnType == typeOfSort(s_outer, returnSort),\n    new s_function, s_function -F-&gt; s_outer,\n    argTypes == typesOfArgs(s_outer, args),\n    declareParameters(s_function, zipArgTypes(args, argTypes)),\n    new s_body, s_body -P-&gt; s_function,\n    stmtsOk(s_body, stmts, returnType),\n    declFunctionGlobal(s_outer, name, FUNCTION_ORIGIN(args), argTypes, returnType).\n\n  entityFunctionOk : scope * Function * BOOL\n  entityFunctionOk(s_ent, Function(name, FormalArgs(args), OptSortSome(returnSort), Block(stmts)), static) :- { argTypes returnType s_function s_body }\n    returnType == typeOfSort(s_ent, returnSort),\n    new s_function, s_function -F-&gt; s_ent,\n    argTypes == typesOfArgs(s_ent, args),\n    declareParameters(s_function, zipArgTypes(args, argTypes)),\n    new s_body, s_body -P-&gt; s_function,\n    stmtsOk(s_body, stmts, returnType),\n    declFunctionEntity(s_ent, name, FUNCTION_ORIGIN(args), argTypes, returnType, static),\n    noDuplicateFunDefsEntity(s_ent, name, argTypes).\n\n  entityFunctionOk(s_ent, Function(name@\"save\", FormalArgs([]), _, _), _) :-\n    false | error $[Entity function with name [name] collides with a built-in function that you are not allowed to overwrite] @name.\n\n  entityFunctionOk(s_ent, Function(name@\"delete\", FormalArgs([]), _, _), _) :-\n    false | error $[Entity function with name [name] collides with a built-in function that you are not allowed to overwrite] @name.\n\n  // predicate that defines when a function can be cached\n  canBeCached : scope * Function\n  canBeCached(s, Function(function_name, FormalArgs([]), OptSortSome(returnSort), _)) :- inequalType(typeOfSort(s, returnSort), VOID()) | error $[Only functions that have a return type can be cached] @function_name.\n  canBeCached(s, Function(function_name, FormalArgs([_|_]), _, _)) :- false | error $[Only functions without arguments can be cached] @function_name.\n\n  // declare a function in a given scope\n  // and define the relation typeOfFunDecl with signature (argument types  * return type)\n  declFunctionGlobal : scope * string * ORIGIN * list(TYPE) * TYPE\n  declFunctionGlobal(s, f, origin, args, return) :-\n    declareFunction(s, f, origin, args, return),\n    noDuplicateFunDefsGlobal(s, f, args).\n\n  declFunctionEntity : scope * string * ORIGIN * list(TYPE) * TYPE * BOOL\n  declFunctionEntity(s, f, origin, args, return, TRUE()) :- declareStaticFunction(s, f, origin, args, return).\n  declFunctionEntity(s, f, origin, args, return, FALSE()) :- declareFunction(s, f, origin, args, return).\n\n  // map syntactic types to semantic types\n  typesOfArgs maps typeOfArg(*, list(*)) = list(*)\n  typeOfArg : scope * FormalArg -&gt; TYPE\n  typeOfArg(s, Arg(_, sort)) = t :-\n    t == typeOfSort(s, sort),\n    inequalType(t, UNTYPED()) | error $[Unknown type [sort]] @sort.\n\n  // create tuples of (arg_name * arg_type)\n  zipArgTypes maps zipArgType(list(*), list(*)) = list(*)\n  zipArgType : FormalArg * TYPE -&gt; (string * TYPE)\n  zipArgType(Arg(x, _), t) = (x, t).\n\n  // predicate that defines when there are overlapping function signatures\n  noDuplicateFunDefsGlobal : scope * string * list(TYPE)\n  noDuplicateFunDefsGlobal(s, f, ts) :- { ps }\n    resolveFunction(s, f) == ps,\n    amountOfFunDeclsWithArgs(ps, ts, 0) == 1\n        | error $[Function with name [f] and argument types [ts] is already defined] @f. // correct error message for tests\n\n  noDuplicateFunDefsEntity : scope * string * list(TYPE)\n  noDuplicateFunDefsEntity(s, f, types) :- { ps }\n    query function filter EXTEND?\n                   and { f' :- f' == (f, _, _) }\n                   in s |-&gt; ps,\n    amountOfFunDeclsWithArgs(filterFunctionResults(typesOfStripOrigin(ps), FALSE()), types, 0) == 1\n        | error $[Function with name [f] and argument types [types] is already defined] @f. // correct error message for tests\n\n  // helper function for noDuplicateFunDefs that counts the amount of function with a given name and argument types\n  amountOfFunDeclsWithArgs : list((path * (string * TYPE))) * list(TYPE) * int -&gt; int\n  amountOfFunDeclsWithArgs([], _, n) = n.\n  amountOfFunDeclsWithArgs([(_, (_, FUNCTION(_, types, _, _))) | tail], types, n) = amountOfFunDeclsWithArgs(tail, types, i) :- i #= n + 1.\n  amountOfFunDeclsWithArgs([_ | tail], types, n) = amountOfFunDeclsWithArgs(tail, types, n).\n\nrules  // rules and functions for function overloading\n\n  // function that gets all functions/templates with matching name and compatible argument types\n  typeCompatibleSigs : list((path * (string * TYPE))) * list(TYPE) -&gt; list((string * TYPE))\n  typeCompatibleSigs(nameCompatibleSigs, args) = result :- {sigsZippedWithTypeCompatibility}\n    sigsZippedWithTypeCompatibility == zipSigsWithTypesCompatible(args, dropPaths(nameCompatibleSigs)),\n    result == filterCompatibleArgTypes(sigsZippedWithTypeCompatibility).\n\n  // helper function for typeCompatibleSigs that prunes the list\n  // of functions/templates based on the zipped BOOL with the signature\n  filterCompatibleArgTypes : list((BOOL * (string * TYPE))) -&gt; list((string * TYPE))\n  filterCompatibleArgTypes([]) = [].\n  filterCompatibleArgTypes([(TRUE() , f) | fs]) = [f | filterCompatibleArgTypes(fs)].\n  filterCompatibleArgTypes([(FALSE(), _) | fs]) = filterCompatibleArgTypes(fs).\n\n  // helper function for typeCompatibleSigs that zips the\n  // signatures with whether the types are compatible with given argument types\n  zipSigsWithTypesCompatible maps zipSigWithTypesCompatible(*, list(*)) = list(*)\n  zipSigWithTypesCompatible : list(TYPE) * (string * TYPE) -&gt; (BOOL * (string * TYPE))\n  zipSigWithTypesCompatible(args, f@(_, FUNCTION(_, funArgs, _, _))) = (typesCompatible(args, funArgs), f).\n  zipSigWithTypesCompatible(args, f@(_, TEMPLATE(_, templArgs, _))) = (typesCompatible(args, templArgs), f).\n\n  // function that prunes the list of compatible signatures\n  // to a list of most specific signatures\n  mostSpecificSigs : list(TYPE) * list((string * TYPE)) -&gt; list((string * TYPE))\n  mostSpecificSigs(args, []) = [].     // In case no functions are compatible, return empty list\n  mostSpecificSigs(args, fs@[_]) = fs. // In case of only one compatible signature, return that\n  mostSpecificSigs(args, sigs) = mostSpecificSigs_helper(args, sigs, matchingSigs(stripRefTypes(args), sigs)).\n\n  // helper function for mostSpecificFunSigs that returns\n  // the exactly matching signatures if they exists,\n  // else return the most specific (least inheritance) signatures\n  mostSpecificSigs_helper : list(TYPE) * list((string * TYPE)) * list((string * TYPE)) -&gt; list((string * TYPE))\n  mostSpecificSigs_helper(args, sigs, matching) = matching.\n  mostSpecificSigs_helper(args, sigs, [])       = filterLeastInheritanceAmount(minOfList(inheritanceAmounts), zipInheritanceAmountWithSig(inheritanceAmounts, sigs)) :-\n    inheritanceAmounts == inheritanceAmounts(args, sigs).\n\n  // helper function for mostSpecificFunSigs that returns the exactly matching signatures\n  matchingSigs : list(TYPE) * list((string * TYPE)) -&gt; list((string * TYPE))\n  matchingSigs(_, []) = [].\n  matchingSigs(args, [(x, FUNCTION(f, params, rt, static)) | fs]) = matchingSigs_helper(args, (x, FUNCTION(f, stripRefTypes(params), rt, static)), fs).\n  matchingSigs(args, [(x, TEMPLATE(t, params, ajax))       | fs]) = matchingSigs_helper(args, (x, TEMPLATE(t, stripRefTypes(params), ajax)), fs).\n\n  // helper function for matchingSigs that compares the argument types after stripping the Ref&lt;&gt; sorts\n  matchingSigs_helper : list(TYPE) * (string * TYPE) * list((string * TYPE)) -&gt; list((string * TYPE))\n  matchingSigs_helper(args, f@(_, FUNCTION(_, args, _, _)), fs) = [f | matchingSigs(args, fs)].\n  matchingSigs_helper(args, f@(_, TEMPLATE(_, args, _))   , fs) = [f | matchingSigs(args, fs)].\n  matchingSigs_helper(args, _, fs) = matchingSigs(args, fs).\n\n  // function that computes the total amount of inheritance edges from caller arguments to defined arguments\n  inheritanceAmounts maps inheritanceAmount(*, list(*)) = list(*)\n  inheritanceAmount : list(TYPE) * (string * TYPE) -&gt; int\n  inheritanceAmount(args, (_, FUNCTION(_, sigTypes, _, _))) = inheritanceAmount_helper(args, sigTypes).\n  inheritanceAmount(args, (_, TEMPLATE(_, sigTypes, _)))    = inheritanceAmount_helper(args, sigTypes).\n\n  // helper function for getInheritanceAmount that computers the total amount of inheritance edges\n  inheritanceAmount_helper : list(TYPE) * list(TYPE) -&gt; int\n  inheritanceAmount_helper([], []) = 0.\n  inheritanceAmount_helper([argT | argtl], [sigT | sigtl]) = x :- { s_arg s_sig y z }\n    s_arg == scopeFromType(argT),\n    s_sig == scopeFromType(sigT),\n    y == inheritEdgesAmount(s_arg, s_sig),\n    z == inheritanceAmount_helper(argtl, sigtl),\n    x #= y + z.\n\n  // in case of two built-in types, the same built-in type is +0, two compatible (but not equal) types is +1\n  inheritanceAmount_helper([arg@BUILTINTYPE(t, _) | argtl], [sig@BUILTINTYPE(t, _) | sigtl]) = x :-\n    x == inheritanceAmount_helper(argtl, sigtl).\n\n  inheritanceAmount_helper([arg@BUILTINTYPE(_, _) | argtl], [sig@BUILTINTYPE(_, _) | sigtl]) = x :- { y }\n    typeCompatible(arg, sig) | error $[Argument type [arg] is not compatible with signature type [sig]],\n    y == inheritanceAmount_helper(argtl, sigtl),\n    x #= y + 1.\n\n  // in case of two template variable arguments, +0 for exactly the same types, +1 for different types\n  inheritanceAmount_helper([arg@TEMPLATEVARARG(ts, _) | argtl], [sig@TEMPLATEVARARG(ts, _) | sigtl]) = x :-\n    x == inheritanceAmount_helper(argtl, sigtl).\n\n  inheritanceAmount_helper([arg@TEMPLATEVARARG(_, _) | argtl], [sig@TEMPLATEVARARG(_, _) | sigtl]) = x :- { y }\n    typeCompatible(arg, sig) | error $[Argument type [arg] is not compatible with signature type [sig]],\n    y == inheritanceAmount_helper(argtl, sigtl),\n    x #= y + 1.\n\n  scopeFromType : TYPE -&gt; scope\n  scopeFromType(REF(t)) = scopeFromType(t).\n  scopeFromType(LIST(t)) = scopeFromType(t).\n  scopeFromType(SET(t)) = scopeFromType(t).\n  scopeFromType(ENTITY(_, s)) = s.\n  scopeFromType(NATIVECLASS(_, s)) = s.\n  scopeFromType(BUILTINTYPE(_, s)) = s.\n\n  // function that zips the inheritance amount with the signature\n  zipInheritanceAmountWithSig : list(int) * list((string * TYPE)) -&gt; list((int * (string * TYPE)))\n  zipInheritanceAmountWithSig([], []) = [].\n  zipInheritanceAmountWithSig([x|xs], [y|ys]) = [(x, y) | zipInheritanceAmountWithSig(xs, ys)].\n\n  // function that prunes the signatures to only keep the lowest inheritance amount\n  filterLeastInheritanceAmount : int * list((int * (string * TYPE))) -&gt; list((string * TYPE))\n  filterLeastInheritanceAmount(_, []) = [].\n  filterLeastInheritanceAmount(x, [(x, sig) | sigtl]) = [sig | filterLeastInheritanceAmount(x, sigtl)].\n  filterLeastInheritanceAmount(x, [_        | sigtl]) = filterLeastInheritanceAmount(x, sigtl).\n\n  dropPaths maps dropPath(list(*)) = list(*)\n  dropPath : (path * (string * TYPE)) -&gt; (string * TYPE)\n  dropPath((_, x)) = x.\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/actions/functions.stx/#modal-h2","title":"functions.stx","text":""},{"location":"webdslstatix/trans/static-semantics/entities/annotations.stx/","title":"<code>annotations.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/entities/annotations.stx</p> <pre><code>module static-semantics/entities/annotations\n\nimports\n  static-semantics/types/built-ins\n\n  static-semantics/webdsl-actions\n  static-semantics/webdsl-entities\n  static-semantics/webdsl-types\n  static-semantics/webdsl\n\nsignature\n\n  sorts\n    ANNOTATION\n\n  constructors\n    // annotations on a property level\n    ID          : ANNOTATION\n    OVERRIDABLE : ANNOTATION\n    NAME        : ANNOTATION\n    TRANSIENT   : ANNOTATION\n    DERIVED     : ANNOTATION\n    INVERSE     : ANNOTATION\n\n    // annotations on entity level\n    SESSIONENTITY : ANNOTATION\n    SUBENTITY     : ANNOTATION\n\n  relations\n    annotation : string * ANNOTATION\n\nrules // annotation declaration and resolving\n\n  // property level\n  declareAnnotations maps declareAnnotation(*, *, list(*))\n  declareAnnotation : scope * string * ANNOTATION\n  declareAnnotation(s, p, a) :-\n    !annotation[p, a] in s.\n\n  resolveAnnotation : scope * string -&gt; list((path * (string * ANNOTATION)))\n  resolveAnnotation(s, x) = ps :-\n    query annotation filter P* F* EXTEND?\n                     and { x' :- x' == (x, _) }\n                     min $ &lt; P, $ &lt; F, $ &lt; EXTEND, P &lt; F, P &lt; EXTEND, F &lt; EXTEND\n                     in s |-&gt; ps.\n\n  resolveAnnotationByAnno : scope * ANNOTATION -&gt; list((path * (string * ANNOTATION)))\n  resolveAnnotationByAnno(s, a) = ps :-\n    query annotation filter P* F* EXTEND?\n                     and { x' :- x' == (_, a) }\n                     min $ &lt; P, $ &lt; F, $ &lt; EXTEND, P &lt; F, P &lt; EXTEND, F &lt; EXTEND\n                     in s |-&gt; ps.\n\n  resolveClosestAnnotationByAnno : scope * ANNOTATION -&gt; list((path * (string * ANNOTATION)))\n  resolveClosestAnnotationByAnno(s, a) = ps :-\n    query annotation filter P* F* EXTEND? INHERIT* EXTEND?\n                     and { x' :- x' == (_, a) }\n                     min $ &lt; P, $ &lt; F, $ &lt; EXTEND, $ &lt; INHERIT,\n                         P &lt; F, P &lt; EXTEND, P &lt; INHERIT,\n                         F &lt; EXTEND, F &lt; INHERIT,\n                         EXTEND &lt; INHERIT\n                     and true\n                     in s |-&gt; ps.\n\n  // entity level\n  declareEntityAnnotation : scope * ANNOTATION\n  declareEntityAnnotation(s, a) :-\n    declareAnnotation(s, \"_ENTITY\", a).\n\n  resolveEntityAnnotation : scope -&gt; list((path * (string * ANNOTATION)))\n  resolveEntityAnnotation(s) = resolveAnnotation(s, \"_ENTITY\").\n\nrules // annotations\n\n  annotationsOk maps annotationOk(*, *, *, list(*))\n  annotationOk : scope * string * TYPE * Annotation\n  annotationOk(_, _, _, a@SimpleAnno(_)) :- try { false } | warning $[Static analysis not implemented for this annotation] @a.\n  annotationOk(_, _, _, a@InverseSlaveAnno(_, _)) :- try { false } | warning $[Static analysis not implemented for this annotation] @a.\n  annotationOk(_, _, _, a@InlineAnno(_)) :- try { false } | warning $[Static analysis not implemented for this annotation] @a.\n  annotationOk(_, _, _, a@SelectAnno(_)) :- try { false } | warning $[Static analysis not implemented for this annotation] @a.\n  annotationOk(_, _, _, a@IndexEmptyAnno()) :- try { false } | warning $[Static analysis not implemented for this annotation] @a.\n  annotationOk(_, _, _, a@IndexAnno(_)) :- try { false } | warning $[Static analysis not implemented for this annotation] @a.\n  annotationOk(_, _, _, a@CollationAnno(_)) :- try { false } | warning $[Static analysis not implemented for this annotation] @a.\n  annotationOk(_, _, _, a@IdErrorAnno(_)) :- try { false } | warning $[Static analysis not implemented for this annotation] @a.\n  annotationOk(_, _, _, a@IdEmptyErrorAnno(_)) :- try { false } | warning $[Static analysis not implemented for this annotation] @a.\n\n  annotationOk(_, _, _, a@SearchableAnnoBoost(_, _)) :- try { false } | warning $[Static analysis not implemented for this annotation] @a.\n  annotationOk(_, _, _, a@SearchableAnno2Annotation(_)) :- try { false } | warning $[Static analysis not implemented for this annotation] @a.\n  annotationOk(_, _, _, a@SearchNamespaceAnno2Annotation(_)) :- try { false } | warning $[Static analysis not implemented for this annotation] @a.\n\n  annotationOk(s, p, _, TransientAnno()) :-\n    declareAnnotation(s, p, TRANSIENT()).\n\n  annotationOk(s, p, t, a@IdAnno()) :-\n    declareAnnotation(s, p, ID()),\n    noDuplicateIdAnnotations(s) | error $[Only one id annotatation allowed in an entity] @a,\n    equalType(t, string(s))     | error $[Id property must be of type String] @a,\n    isTopLevelEntity(s)         | error $[Id annotation not allowed in sub-entities] @a,\n    isNoSessionEntity(s)        | error $[Id annotation not allowed in session entities] @a.\n\n  annotationOk(s, p, _, NameAnno()) :-\n    declareAnnotation(s, p, NAME()),\n    noMultipleNameAnnotations(s).\n\n  annotationOk(s, p, _, a@CacheAnno()) :-\n    hasAnnotation(resolveAnnotation(s, p), DERIVED()) | error $[cached annotation can only be set on derived properties] @a.\n\n  // inverse property on List&lt;t&gt;\n  annotationOk(s, p, LIST(t), InverseAnno(sort, prop)) :- { sortType s_eval thisType propType }\n    declareAnnotation(s, p, INVERSE()),\n    new s_eval, s_eval -P-&gt; s,\n    sortType == typeOfInverseSort(s_eval, sort, t),\n    noDoubleInverse(sortType, prop),\n    thisType == typeOfThis(s),\n    propType == typeOfProperty(s_eval, sortType, prop),\n    inverseListAnnoTypeOk(propType, thisType, prop).\n\n  inverseListAnnoTypeOk : TYPE * TYPE * string\n  inverseListAnnoTypeOk(T, T, _).\n  inverseListAnnoTypeOk(LIST(_), _, prop) :- false | error $[Inverse between lists not allowed] @prop. // correct error message for tests\n  inverseListAnnoTypeOk(_, _, prop) :- false | error $[Inverse property must be the same type as this entity] @prop.\n\n  // inverse property on Set&lt;t&gt;\n  annotationOk(s, p, SET(t), InverseAnno(sort, prop)) :- { sortType s_eval thisType propType }\n    declareAnnotation(s, p, INVERSE()),\n    new s_eval, s_eval -P-&gt; s,\n    sortType == typeOfInverseSort(s_eval, sort, t),\n    noDoubleInverse(sortType, prop),\n    thisType == typeOfThis(s),\n    propType == typeOfProperty(s_eval, sortType, prop),\n    or(\n      equalTypeB(propType, thisType),\n      equalTypeB(propType, SET(thisType))\n    ) | error $[Inverse property must be the same type as this entity] @prop.\n\n  // inverse property non-collection\n  annotationOk(s, p, t, InverseAnno(sort, prop)) :- { sortType s_eval propType thisType }\n    declareAnnotation(s, p, INVERSE()),\n    new s_eval, s_eval -P-&gt; s,\n    sortType == typeOfInverseSort(s_eval, sort, t),\n    noDoubleInverse(sortType, prop),\n    thisType == typeOfThis(s),\n    propType == typeOfProperty(s_eval, sortType, prop),\n    or(orB(\n      equalTypeB(propType, thisType),\n      equalTypeB(propType, LIST(thisType))),\n      equalTypeB(propType, SET(thisType))\n    ) | error $[Inverse property must have (a collection of) the same type as this entity] @prop.\n\n  annotationOk(s, p, _, a@InverseReferenceOnlyAnno()) :-\n    hasAnnotation(resolveAnnotation(s, p), INVERSE())\n      | error $[inverse-reference-only annotation is only allowed on properties that have an inverse specified] @a.\n\n  annotationOk(_, _, _, NotNullAnno()).\n  annotationOk(_, _, _, NotEmptyAnno()).\n  annotationOk(s, _, propType, a@AllowedAnno(exp)) :- { t t' }\n    t == stripOptionalSetOrListType(propType),\n    t' == typeOfExp(s, exp),\n    or(\n      typeCompatibleB(t', LIST(t)),\n      typeCompatibleB(t', SET(t))\n    ) | error $[Allowed expression must be a list of set of type [t], [t'] given] @a.\n\n  annotationOk(s, _, t, a@DefaultAnno(exp)) :- {t'}\n    t' == typeOfExp(s, exp),\n    typeCompatible(t', t) | error $[Default value must be of type [t], [t'] given] @a.\n\n  annotationOk(_, _, _, LengthAnno(_)).\n  annotationOk(s, _, _, FormatAnno(str)) :- stringOk(s, str).\n\n  typeOfInverseSort : scope * string * TYPE -&gt; TYPE\n  typeOfInverseSort(s, sort, t) = sortType :-\n    t == ENTITY(_, _) | error $[Inverse annotation only allowed on (collections of) entity types],\n    resolveType(s, sort) == [(_, (_, sortType))] | error $[Cannot resolve sort [sort] to an entity],\n    sortType == ENTITY(_, _) | error $[Cannot resolve sort [sort] to an entity],\n    sortType == t | error $[Inverse entity must be the same as property type [t]].\n\nrules // resolving entity.name\n\n  typeOfProperty(_, ENTITY(_, s_ent), n@\"name\") = t :- { path s_name nameProp n' }\n    resolveClosestAnnotationByAnno(s_ent, NAME()) == [(path, (nameProp, _))],\n    s_name == scopeFromPath(path),\n    resolveLocalProperty(s_name, nameProp) == [(_, (n', t))],\n    @n.ref := n'.\n\nrules // validation\n\n  annotationOk(s, _, _, ValidateCreateAnno(validateExp, messageExp)) :- validateOk(s, validateExp, messageExp).\n  annotationOk(s, _, _, ValidateUpdateAnno(validateExp, messageExp)) :- validateOk(s, validateExp, messageExp).\n  annotationOk(s, _, _, ValidateDeleteAnno(validateExp, messageExp)) :- validateOk(s, validateExp, messageExp).\n  annotationOk(s, _, _, ValidateAnno(validateExp, messageExp)) :- validateOk(s, validateExp, messageExp).\n  annotationOk(s, _, _, NamedValidateAnno(_, validateExp, messageExp)) :- validateOk(s, validateExp, messageExp).\n\n  validateOk : scope * Exp * Exp\n  validateOk(s, validateExp, messageExp) :- { validateType messageType }\n    validateType == typeOfExp(s, validateExp),\n    messageType == typeOfExp(s, messageExp),\n    typeCompatible(validateType, bool(s)) | error $[The expression to be validated should be compatible with type Bool, [validateType] given],\n    typeCompatible(messageType, string(s)) | error $[The error message should be compatible with type String, [messageType] given].\n\nrules // predicates\n\n  isTopLevelEntity : scope\n  isTopLevelEntity(s) :- doesNotHaveAnnotation(resolveEntityAnnotation(s), SUBENTITY()).\n\n  isNoSessionEntity : scope\n  isNoSessionEntity(s) :- doesNotHaveAnnotation(resolveEntityAnnotation(s), SESSIONENTITY()).\n\n  noDuplicateIdAnnotations : scope\n  noDuplicateIdAnnotations(s) :- resolveAnnotationByAnno(s, ID()) == [_].\n\n  noMultipleNameAnnotations : scope\n  noMultipleNameAnnotations(s) :- resolveAnnotationByAnno(s, NAME()) == [_] | error $[Found multiple properties called \"name\" or with a name annotation].\n\n  noDoubleInverse : TYPE * string\n  noDoubleInverse(ENTITY(_, s_ent), x) :-\n    doesNotHaveAnnotation(resolveAnnotation(s_ent, x), INVERSE())\n      | error $[Inverse annotations cannot be declared on both sides].\n\n  hasIdAnnotationB : scope -&gt; BOOL\n  hasIdAnnotationB(s) = notB(emptyAnnotationResultB(resolveAnnotationByAnno(s, ID()))).\n\n  isMutableB : scope * string -&gt; BOOL\n  isMutableB(s, x) = notB(hasAnnotationB(resolveAnnotation(s, x), DERIVED())).\n\n  isMutable : scope * string\n  isMutable(s, x) :- hasAnnotationB(resolveAnnotation(s, x), DERIVED()) == FALSE().\n  isMutable(s, x@\"name\") :- { t } propertyTypeNoRef(s, x) == t.      // only allow assignment if the property is overridden\n  isMutable(s, x@\"naturalId\") :- { t } propertyTypeNoRef(s, x) == t. // only allow assignment if the property is overridden\n\n  isMutableProperty : TYPE * string\n  isMutableProperty(_, _) :- false | error $[Can only check mutability of native class and entity properties].\n  isMutableProperty(NATIVECLASS(_, _), _). // all native class properties are mutable\n  isMutableProperty(ENTITY(_, s_entity), x) :- {annotations}\n    annotations == resolveAnnotation(s_entity, x),\n    doesNotHaveAnnotation(annotations, DERIVED()) | error $[Property [x] is a derived property and hence cannot be edited]. // correct error message for tests\n\nrules // utils\n\n  hasAnnotationB : list((path * (string * ANNOTATION))) * ANNOTATION -&gt; BOOL\n  hasAnnotationB([], _) = FALSE().\n  hasAnnotationB([(_, (_, a)) | tl], a) = TRUE().\n  hasAnnotationB([(_, (_, _)) | tl], a) = hasAnnotationB(tl, a).\n\n  hasAnnotation : list((path * (string * ANNOTATION))) * ANNOTATION\n  hasAnnotation(ps, a) :- hasAnnotationB(ps, a) == TRUE().\n\n  doesNotHaveAnnotation : list((path * (string * ANNOTATION))) * ANNOTATION\n  doesNotHaveAnnotation(ps, a) :- hasAnnotationB(ps, a) == FALSE().\n\n  withAnnotation : list((path * (string * TYPE))) * ANNOTATION -&gt; list((path * (string * TYPE)))\n  withAnnotation(xs, a) = filterResultsWithBool(zipResultsWithHasAnnoBool(xs, a)).\n\n  withoutAnnotation : list((path * (string * TYPE))) * ANNOTATION -&gt; list((path * (string * TYPE)))\n  withoutAnnotation(xs, a) = filterResultsWithBool(zipResultsWithNotHasAnnoBool(xs, a)).\n\n  zipResultsWithHasAnnoBool maps zipResultWithHasAnnoBool(list(*), *) = list(*)\n  zipResultWithHasAnnoBool : (path * (string * TYPE)) * ANNOTATION -&gt; ((path * (string * TYPE)) * BOOL)\n  zipResultWithHasAnnoBool(r@(p, (x, _)), a) = (r, hasAnnotationB(resolveAnnotation(scopeFromPath(p), x), a)).\n\n  zipResultsWithNotHasAnnoBool maps zipResultWithNotHasAnnoBool(list(*), *) = list(*)\n  zipResultWithNotHasAnnoBool : (path * (string * TYPE)) * ANNOTATION -&gt; ((path * (string * TYPE)) * BOOL)\n  zipResultWithNotHasAnnoBool(r@(p, (x, _)), a) = (r, notB(hasAnnotationB(resolveAnnotation(scopeFromPath(p), x), a))).\n\n  filterResultsWithBool : list(((path * (string * TYPE)) * BOOL)) -&gt; list((path * (string * TYPE)))\n  filterResultsWithBool([]) = [].\n  filterResultsWithBool([(x, TRUE()) | xs]) = [x | filterResultsWithBool(xs)].\n  filterResultsWithBool([(_, FALSE()) | xs]) = filterResultsWithBool(xs).\n\n  emptyAnnotationResultB : list((path * (string * ANNOTATION))) -&gt; BOOL\n  emptyAnnotationResultB([]) = TRUE().\n  emptyAnnotationResultB(_) = FALSE().\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/entities/annotations.stx/#modal-h2","title":"annotations.stx","text":""},{"location":"webdslstatix/trans/static-semantics/entities/built-ins.stx/","title":"<code>built-ins.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/entities/built-ins.stx</p> <pre><code>module static-semantics/entities/built-ins\n\nimports\n  static-semantics/types/built-ins\n\n  static-semantics/entities/annotations\n\n  static-semantics/webdsl-entities\n  static-semantics/webdsl-built-ins\n  static-semantics/webdsl\n\nrules\n\n  declareEntityBuiltIns : scope\n  declareEntityBuiltIns(s) :- {s_object s_ent s_sessionmessage s_sessionmanager}\n    new s_object, s_object -DEF-&gt; s,\n    new s_ent, s_ent -INHERIT-&gt; s_object,\n    declareType(s, \"Object\", BUILTINTYPE(\"Object\", s_object)),\n    declareType(s, \"Entity\", ENTITY(\"Entity\", s_ent)),\n    declareVar(s_ent, \"id\"       , uuid(s)),\n    declareVar(s_ent, \"naturalId\", string(s)),\n    declareVar(s_ent, \"version\"  , int(s)),\n    declareVar(s_ent, \"name\"     , string(s)), declareAnnotations(s_ent, \"name\", [OVERRIDABLE(), NAME(), DERIVED()]),\n    declareVar(s_ent, \"created\"  , datetime(s)),\n    declareVar(s_ent, \"modified\" , datetime(s)),\n    declareBuiltInFunction(s_ent, \"save\"  , [], VOID()),\n    declareBuiltInFunction(s_ent, \"delete\", [], VOID()), // TO-DO: not allowed on session entities and global vars\n    declareBuiltInFunction(s_object, \"toString\", [], string(s)),\n\n    new s_sessionmessage, s_sessionmessage -INHERIT-&gt; s_ent,\n    declareType(s, \"SessionMessage\", ENTITY(\"SessionMessage\", s_sessionmessage)),\n    declareVar(s_sessionmessage, \"text\", text(s)),\n\n    new s_sessionmanager, s_sessionmanager -INHERIT-&gt; s_ent,\n    declareType(s, \"SessionManager\", ENTITY(\"SessionManager\", s_sessionmanager)),\n    declareVar(s_sessionmanager, \"messages\"         , ENTITY(\"SessionMessage\", s_sessionmessage)),\n    declareVar(s_sessionmanager, \"lastUse\"          , datetime(s)),\n    declareVar(s_sessionmanager, \"logsqlMessage\"    , text(s)),\n    declareVar(s_sessionmanager, \"stayLoggedIn\"     , bool(s)),\n    declareVar(s_sessionmanager, \"sessionHasChanges\", bool(s)),\n    declareVar(s_sessionmanager, \"domain\"           , string(s)),\n    declareVar(s_sessionmanager, \"cookieValue\"      , uuid(s)).\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/entities/built-ins.stx/#modal-h2","title":"built-ins.stx","text":""},{"location":"webdslstatix/trans/static-semantics/entities/generated-functions.stx/","title":"<code>generated-functions.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/entities/generated-functions.stx</p> <pre><code>module static-semantics/entities/generated-functions\n\nimports\n  static-semantics/entities/annotations\n\n  static-semantics/types/built-ins\n\n  static-semantics/webdsl\n  static-semantics/webdsl-actions\n  static-semantics/webdsl-types\n\nrules\n\n/*\n                       declare findEntity(&lt;idType&gt;) or loadEntity(&lt;uuid&gt;) based\n                       on presence of `(id)` annotation and type\n                     */\n\n  defOk(s, GeneratedDefinition(Generated([\"loadOrFindEntity\", entityName, loadName, findName, getUniqueName, isUniqueName, isUniqueIdName]))) :- { s_ent t }\n    resolveType(s, entityName) == [(_, (_, t@ENTITY(_, s_ent)))],\n    declareLoadOrFindEntity(s, loadName, findName, getUniqueName, isUniqueName, isUniqueIdName, t, hasIdAnnotationB(s_ent)).\n\n  declareLoadOrFindEntity : scope * string * string * string * string * string * TYPE * BOOL\n  declareLoadOrFindEntity(s, loadName, _, _, _, _, t, FALSE()) :-\n    declareFunction(s, loadName, GENERATED_ORIGIN(1), [uuid(s)], t).\n\n  declareLoadOrFindEntity(s, _, findName, getUniqueName, isUniqueName, isUniqueIdName, t, TRUE()) :- { s_ent idName idType bool }\n    bool == bool(s),\n    t == ENTITY(_, s_ent),\n    resolveAnnotationByAnno(s_ent, ID()) == [(_, (idName, _))],\n    idType == propertyType(s_ent, idName),\n    declareFunction(s, findName,       GENERATED_ORIGIN(1), [idType], t),\n    declareFunction(s, getUniqueName,  GENERATED_ORIGIN(1), [idType], t),\n    declareFunction(s, isUniqueName,   GENERATED_ORIGIN(1), [t], bool),\n    declareFunction(s, isUniqueIdName, GENERATED_ORIGIN(1), [idType], bool),\n    declareFunction(s, isUniqueIdName, GENERATED_ORIGIN(2), [idType, t], bool).\n\nrules\n\n/*\n                       declare findEntityByProperty and findEntityByPropertyLike if\n                       the property is string-type compatible\n                     */\n\n  defOk(s, GeneratedDefinition(Generated([\"findEntityByProperty\", entityName, propertyName, findByPropName, findByPropLikeName]))) :- { entType s_ent propType }\n    resolveType(s, entityName) == [(_, (_, entType@ENTITY(_, s_ent)))],\n    propType == propertyType(s_ent, propertyName),\n    declareFindEntityByProperty(s, findByPropName, findByPropLikeName, entType, propType, typeCompatibleB(propType, string(s))).\n\n  declareFindEntityByProperty : scope * string * string * TYPE * TYPE * BOOL\n  declareFindEntityByProperty(_, _, _, _, _, FALSE()).\n  declareFindEntityByProperty(s, findByPropName, findByPropLikeName, entType, propType, TRUE()) :-\n    declareFunction(s, findByPropName, PROP_ORIGIN(), [propType], LIST(entType)),\n    declareFunction(s, findByPropLikeName, PROP_ORIGIN(), [propType], LIST(entType)).\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/entities/generated-functions.stx/#modal-h2","title":"generated-functions.stx","text":""},{"location":"webdslstatix/trans/static-semantics/types/built-ins.stx/","title":"<code>built-ins.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/types/built-ins.stx</p> <pre><code>module static-semantics/types/built-ins\n\nimports\n  static-semantics/actions/functions\n\n  static-semantics/webdsl-actions\n  static-semantics/webdsl-built-ins\n  static-semantics/webdsl-entities\n  static-semantics/webdsl-native\n  static-semantics/webdsl-types\n  static-semantics/webdsl\n\nrules\n\n  declareBuiltInType : scope * string\n  declareBuiltInType(s, name) :- {s_type s_object}\n    object(s) == BUILTINTYPE(_, s_object),\n    new s_type, s_type -INHERIT-&gt; s_object, s_type -DEF-&gt; s,\n    declareExtendScope(s, name, s_type), // declare s_type to be linked to type name\n    extendScopes(resolveExtendScope(s, name), s_type),\n    declareType(s, name, BUILTINTYPE(name, s_type)),\n    declareVar(s, name, STATICBUILTINTYPE(name, s_type)). // declare class name as global variable that refers to the static scope\n\n  declareBuiltInSubType : scope * string * string\n  declareBuiltInSubType(s, sub, super) :- {s_sub s_super}\n    builtInType(s, super) == BUILTINTYPE(super, s_super),\n    new s_sub, s_sub -INHERIT-&gt; s_super, s_sub -DEF-&gt; s,\n    noCircularInheritance(s_sub) | error $[Circular inheritance detected in built-in type [sub]],\n    declareExtendScope(s, sub, s_sub), // declare s_type to be linked to type name\n    extendScopes(resolveExtendScope(s, sub), s_sub),\n    declareType(s, sub, BUILTINTYPE(sub, s_sub)),\n    declareVar(s, sub, STATICBUILTINTYPE(sub, s_sub)).\n\n  builtInType : scope * string -&gt; TYPE\n  builtInType(s, name) = t :- {ts}\n    resolveType(s, name) == ts | error $[Built-in type [name] does not exist [ts]],\n    ts == [(_, (_, t@BUILTINTYPE(name, _)))] | error $[Built-in type [name] does not exist [ts]].\n\nrules\n\n  int   : scope -&gt; TYPE\n  int(s)   = builtInType(s, \"Int\").\n  float : scope -&gt; TYPE\n  float(s) = builtInType(s, \"Float\").\n  long  : scope -&gt; TYPE\n  long(s)  = builtInType(s, \"Long\").\n\n  string      : scope -&gt; TYPE\n  string(s)       = builtInType(s, \"String\").\n  secret      : scope -&gt; TYPE\n  secret(s)       = builtInType(s, \"Secret\").\n  email       : scope -&gt; TYPE\n  email(s)        = builtInType(s, \"Email\").\n  url         : scope -&gt; TYPE\n  url(s)          = builtInType(s, \"URL\").\n  wikitext    : scope -&gt; TYPE\n  wikitext(s)     = builtInType(s, \"WikiText\").\n  text        : scope -&gt; TYPE\n  text(s)         = builtInType(s, \"Text\").\n  patch       : scope -&gt; TYPE\n  patch(s)        = builtInType(s, \"Patch\").\n  placeholder : scope -&gt; TYPE\n  placeholder(s)  = builtInType(s, \"Placeholder\").\n\n  date     : scope -&gt; TYPE\n  date(s)     = builtInType(s, \"Date\").\n  datetime : scope -&gt; TYPE\n  datetime(s) = builtInType(s, \"DateTime\").\n  time     : scope -&gt; TYPE\n  time(s)     = builtInType(s, \"Time\").\n\n  bool  : scope -&gt; TYPE\n  bool(s)  = builtInType(s, \"Bool\").\n  uuid  : scope -&gt; TYPE\n  uuid(s)  = builtInType(s, \"UUID\").\n  file  : scope -&gt; TYPE\n  file(s)  = builtInType(s, \"File\").\n  image : scope -&gt; TYPE\n  image(s) = builtInType(s, \"Image\").\n\n  entity : scope -&gt; TYPE\n  entity(s) = definedTypeNoRef(s, \"Entity\").\n\n  object : scope -&gt; TYPE\n  object(s) = definedTypeNoRef(s, \"Object\").\n\n  declareTypeBuiltIns : scope\n  declareTypeBuiltIns(s) :-\n    // numeric types\n    declareBuiltInType(s, \"Int\"),\n    declareBuiltInType(s, \"Float\"),\n    declareBuiltInType(s, \"Long\"),\n\n    // string types\n    declareBuiltInType(s, \"String\"),\n    declareBuiltInSubType(s, \"Secret\", \"String\"),\n    declareBuiltInSubType(s, \"Email\", \"String\"),\n    declareBuiltInSubType(s, \"URL\", \"String\"),\n    declareBuiltInSubType(s, \"WikiText\", \"String\"),\n    declareBuiltInSubType(s, \"Text\", \"String\"),\n    declareBuiltInSubType(s, \"Patch\", \"String\"),\n    declareBuiltInSubType(s, \"Placeholder\", \"String\"),\n\n    // date types\n    declareBuiltInType(s, \"DateTime\"),\n    declareBuiltInSubType(s, \"Date\", \"DateTime\"),\n    declareBuiltInSubType(s, \"Time\", \"DateTime\"),\n\n    // misc\n    declareBuiltInType(s, \"Bool\"),\n    declareBuiltInType(s, \"UUID\"),\n    declareBuiltInType(s, \"File\"),\n    declareBuiltInType(s, \"Image\").\n\n  declareTypeBuiltInFunctions : scope\n  declareTypeBuiltInFunctions(s) :- {int string float s_int s_file s_image s_float}\n    int == int(s),\n    string == string(s),\n    float == float(s),\n\n    new s_int, declareExtendScope(s, \"Int\", s_int),\n    declBuiltInFunctionEntity(s_int, \"floatValue\", [], float, FALSE()),\n\n    new s_file, declareExtendScope(s, \"File\", s_file),\n    declBuiltInFunctionEntity(s_file, \"download\"           , []      , VOID(), FALSE()),\n    declBuiltInFunctionEntity(s_file, \"download\"           , [string], VOID(), FALSE()),\n    declBuiltInFunctionEntity(s_file, \"fileName\"           , []      , string, FALSE()),\n    declBuiltInFunctionEntity(s_file, \"fileNameForDownload\", []      , string, FALSE()),\n\n    declareExtendScope(s, \"Image\", s_file), // also expose file functions to image\n    new s_image, declareExtendScope(s, \"Image\", s_image),\n    declBuiltInFunctionEntity(s_image, \"resize\"   , [int, int]          , VOID()  , FALSE()),\n    declBuiltInFunctionEntity(s_image, \"crop\"     , [int, int, int, int], VOID()  , FALSE()),\n    declBuiltInFunctionEntity(s_image, \"getWidth\" , []                  , int     , FALSE()),\n    declBuiltInFunctionEntity(s_image, \"getHeight\", []                  , int     , FALSE()),\n    declBuiltInFunctionEntity(s_image, \"clone\"    , []                  , image(s), FALSE()),\n\n    new s_float, declareExtendScope(s, \"Float\", s_float),\n    declBuiltInFunctionEntity(s_float, \"round\" , [], int, FALSE()),\n    declBuiltInFunctionEntity(s_float, \"floor\" , [], int, FALSE()),\n    declBuiltInFunctionEntity(s_float, \"ceil\"  , [], int, FALSE()),\n    declBuiltInFunctionEntity(s_float, \"log\"   , [], float, FALSE()),\n    declBuiltInFunctionEntity(s_float, \"log2\"  , [], float, FALSE()).\n\nrules // built-in functions and properties for built-in generic type List\n\n  typeOfProperty(s, LIST(t), \"length\") = int(s).\n  typeOfProperty(s, LIST(t), \"first\") = t.\n  typeOfProperty(s, LIST(t), \"last\") = t.\n\n  typeOfCall(s, LIST(t), \"add\", [arg]) = VOID() :-\n    typeCompatible(typeOfExp(s, arg), t) | error $[No function 'add' with compatible argument types found].\n\n  typeOfCall(s, LIST(t), \"remove\", [arg]) = VOID() :-\n    typeCompatible(typeOfExp(s, arg), t) | error $[No function 'remove' with compatible argument types found].\n\n  typeOfCall(s, LIST(_), \"clear\", []) = VOID().\n\n  typeOfCall(s, rt@LIST(t), \"addAll\", [arg]) = rt :- {argType}\n    argType == typeOfExp(s, arg),\n    or(\n      typeCompatibleB(argType, LIST(t)),\n      typeCompatibleB(argType, SET(t))\n    ).\n\n  typeOfCall(s, LIST(t), \"set\", []) = SET(t).\n\n  typeOfCall(s, LIST(t), \"indexOf\", [arg]) = int(s) :-\n    typeCompatible(typeOfExp(s, arg), t).\n\n  typeOfCall(s, LIST(t), \"get\", [arg]) = t :-\n    typeCompatible(typeOfExp(s, arg), int(s)).\n\n  typeOfCall(s, LIST(t), \"set\", [arg1, arg2]) = VOID() :-\n    typeCompatible(typeOfExp(s, arg1), int(s)),\n    typeCompatible(typeOfExp(s, arg2), t).\n\n  typeOfCall(s, LIST(t), \"insert\", [arg1, arg2]) = VOID() :-\n    typeCompatible(typeOfExp(s, arg1), int(s)),\n    typeCompatible(typeOfExp(s, arg2), t).\n\n  typeOfCall(s, LIST(t), \"removeAt\", [arg]) = VOID() :-\n    typeCompatible(typeOfExp(s, arg), int(s)).\n\n  typeOfCall(s, lt@LIST(_), \"subList\", [arg1, arg2]) = lt :-\n    typeCompatible(typeOfExp(s, arg1), int(s)),\n    typeCompatible(typeOfExp(s, arg2), int(s)).\n\n  typeOfCall(s, LIST(t), \"random\", []) = t.\n\nrules // built-in functions specifically for lists of strings\n\n  typeOfCall(s, LIST(BUILTINTYPE(\"String\", _)), \"concat\", []) = string(s).\n\n  typeOfCall(s, LIST(BUILTINTYPE(\"String\", _)), \"concat\", [arg]) = string :- { t }\n    string == string(s),\n    t == typeOfExp(s, arg),\n    typeCompatible(t, string) | error $[Concatenation separator type must be compatible with String, [t] given] @arg.\n\nrules // built-in functions and properties for built-in generic type Set\n\n  typeOfProperty(s, SET(t), \"length\") = int(s).\n  typeOfProperty(s, SET(t), \"first\") = t.\n  typeOfProperty(s, SET(t), \"last\") = t.\n\n  typeOfCall(s, SET(t), \"get\", [arg]) = t :-\n    typeCompatible(typeOfExp(s, arg), int(s)).\n\n  typeOfCall(s, SET(t), \"add\", [arg]) = VOID() :-\n    typeCompatible(typeOfExp(s, arg), t).\n\n  typeOfCall(s, SET(t), \"remove\", [arg]) = VOID() :-\n    typeCompatible(typeOfExp(s, arg), t).\n\n  typeOfCall(s, SET(_), \"clear\", []) = VOID().\n\n  typeOfCall(s, rt@SET(t), \"addAll\", [arg]) = rt :- {argType}\n    argType == typeOfExp(s, arg),\n    or(\n      typeCompatibleB(argType, LIST(t)),\n      typeCompatibleB(argType, SET(t))\n    ).\n\n  typeOfCall(s, SET(t), \"list\", []) = LIST(t).\n\n  typeOfCall(s, SET(t), \"random\", []) = t.\n\nrules // built-in properties for built-in generic type Ref\n\n  typeOfCall(s, REF(t), \"getEntity\", []) = entity(s).\n\n  typeOfCall(s, REF(t), \"getValidationErrors\", []) = LIST(string(s)).\n\n  typeOfCall(s, REF(LIST(t)), \"getAllowed\", []) = LIST(t).\n  typeOfCall(s, REF(SET(t)) , \"getAllowed\", []) = LIST(t).\n  typeOfCall(s, REF(t)      , \"getAllowed\", []) = LIST(t).\n\n  typeOfCall(s, REF(t), \"getReflectionProperty\", []) = definedTypeIfExists(s, \"ReflectionProperty\").\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/types/built-ins.stx/#modal-h2","title":"built-ins.stx","text":""},{"location":"webdslstatix/trans/static-semantics/types/type-extensions.stx/","title":"<code>type-extensions.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/types/type-extensions.stx</p> <pre><code>module static-semantics/types/type-extensions\n\nimports\n  static-semantics/actions/functions\n\n  static-semantics/types/built-ins\n\n  static-semantics/webdsl-entities\n  static-semantics/webdsl-native\n  static-semantics/webdsl-types\n  static-semantics/webdsl\n\nrules\n\n  defOk(s, TypeDef(name, defs)) :- {s_type}\n    builtInType(s, name) == BUILTINTYPE(name, _) | error $[Type [name] is not a built-in type],\n    new s_type, s_type -DEF-&gt; s,\n    declareExtendScope(s, name, s_type), // declare s_type to be linked to other scopes from type name\n    extendScopes(resolveExtendScope(s, name), s_type),\n    typeElementsOk(s, s_type, defs).\n\n  typeElementsOk maps typeElementOk(*, *, list(*))\n  typeElementOk : scope * scope * TypeElement\n  typeElementOk(s, s_type, TypeFunction(function)) :-\n    nativeClassFunctionOk(s, s_type, function).\n\n  typeElementOk(s, s_type, TypeFunctionFromStatic(NCFunctionFromStatic(_, function))) :-\n    nativeClassFunctionOk(s, s_type, function).\n\nrules // typing of expressions\n\n  typeOfCall(s, BUILTINTYPE(_, s_type), f, args) = typeOfFunctionCallInternal(s, f, args, funSigs) :-\n    funSigs == resolveEntityFunction(s_type, f).\n\n  typeOfCall(s, STATICBUILTINTYPE(_, s_type), f, args) = typeOfFunctionCallInternal(s, f, args, funSigs) :-\n    funSigs == resolveStaticEntityFunction(s_type, f).\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/types/type-extensions.stx/#modal-h2","title":"type-extensions.stx","text":""},{"location":"webdslstatix/trans/static-semantics/ui/actions.stx/","title":"<code>actions.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/ui/actions.stx</p> <pre><code>module static-semantics/ui/actions\n\nimports\n  static-semantics/actions/functions\n\n  static-semantics/entities/annotations\n\n  static-semantics/types/built-ins\n\n  static-semantics/ui/template-calls\n\n  static-semantics/webdsl-actions\n  static-semantics/webdsl-types\n  static-semantics/webdsl-ui\n  static-semantics/webdsl\n\nrules // var decls in templates and pages\n\n  templateElementOk(s, s_decl, _, TEVarDecl(varDecl))            :- templateVarDeclOk(s, s_decl, varDecl).\n  templateElementOk(s, s_decl, _, RequestScopeTemplate(varDecl)) :- templateVarDeclOk(s, s_decl, varDecl).\n  templateElementOk(s, s_decl, _, LocalScopeTemplate(varDecl))   :- templateVarDeclOk(s, s_decl, varDecl).\n\n  templateVarDeclOk: scope * scope * VarDecl\n  templateVarDeclOk(s, s_decl, TemplateVarDecl(x, sort)) :- { t }\n    t == typeOfSort(s, sort),\n    inequalType(t, UNTYPED()) | error $[Unknown type [sort]] @sort,\n    declareVar(s_decl, x, t),\n    @x.type := t.\n\n  templateVarDeclOk(s, s_decl, TemplateVarDeclInit(x, sort, exp)) :- { t expType }\n    t == typeOfSort(s, sort),\n    expType == typeOfExp(s, exp),\n    typeCompatible(expType, t) | error $[Expression [exp] is not of type [sort], got type [expType]] @exp,\n    declareVar(s_decl, x, t),\n    @x.type := t.\n\n  templateVarDeclOk(s, s_decl, TemplateVarDeclInitInferred(x, exp)) :- { t }\n    t == typeOfExp(s, exp),\n    inequalType(t, UNTYPED()) | error $[Unable to infer type of [exp]] @exp,\n    declareVar(s_decl, x, t),\n    @x.type := t.\n\nrules // action definitions\n\n  templateActionOk : scope * scope * string * list(FormalArg) * list(Statement) * BOOL\n  templateActionOk(s, s_pha, a, args, stmts, declare) :- {s_fun s_fun_body argTypes}\n    new s_fun, s_fun -P-&gt; s, // TO-DO: possibly create different label for edges out of actions, abusing P label here\n    argTypes == typesOfArgs(s, args),\n    declareParameters(s_fun, zipArgTypes(args, argTypes)),\n    new s_fun_body, s_fun_body -P-&gt; s_fun,\n    optionallyDeclareAction(s_pha, a, args, argTypes, declare),\n    stmtsOk(s_fun_body, stmts, PAGE(_, _)).\n\n  optionallyDeclareAction : scope * string * list(FormalArg) * list(TYPE) * BOOL\n  optionallyDeclareAction(_, _, _, _, FALSE()).\n  optionallyDeclareAction(s, a, args, ts, TRUE()) :- declareAction(s, a, FUNCTION_ORIGIN(args), ts).\n\n  defOk(_, Action2Definition(Action(_, a, _, _))) :- false | error $[Actions are only allowed in pages and templates] @a.\n\nrules // action calls\n\n  templateElementOk(s, _, s_pha, Action2TemplateElement(Action(_, a, FormalArgs(args), Block(stmts)))) :-\n    templateActionOk(s, s_pha, a, args, stmts, TRUE()).\n\n  actionCallOrInlineOrExpOk : scope * ActionCallOrInlineOrExp\n  actionCallOrInlineOrExpOk(s, ActionCallOrInline(a)) :- actionCallOrInlineOk(s, a).\n  actionCallOrInlineOrExpOk(s, ActionCallOrInlineExp(PropertySubmitExp(e))) :-\n    typeCompatible(typeOfExp(s, e), string(s)) | error $[Expression must be compatible with type String].\n\n  actionCallOrInlineOk : scope * ActionCallOrInline\n  actionCallOrInlineOk(s, ActionCall(ThisCall(a, args))) :- {argTypes a' ts}\n    argTypes == typesOfExps(s, args),\n    resolveAction(s, a) == [(_, (a', ACTION(_, ts))) | _] | error $[Action [a] not defined] @a,\n    typesCompatible(argTypes, ts) == TRUE() | error $[Given argument types not compatible with action definition. Got [argTypes] but expected [ts]] @args,\n    @a.ref := a'.\n\n  actionCallOrInlineOk(s, InlineAction(Block(stmts))) :-\n    templateActionOk(s, s, \"\", [], stmts, FALSE()).\n\nrules // action blocks in templates\n\n  templateElementOk(s, _, _, Init(Block(stmts))) :-\n    stmtsOk(s, stmts, PAGE(_, _)).\n\n  templateElementOk(s, _, _, DataBindAction(Block(stmts))) :-\n    stmtsOk(s, stmts, UNTYPED()).\n\n  templateElementOk(s, _, _, RenderAction(Block(stmts))) :-\n    stmtsOk(s, stmts, UNTYPED()).\n\n  templateElementOk(s, _, _, AllPhasesAction(Block(stmts))) :-\n    stmtsOk(s, stmts, UNTYPED()).\n\n  templateElementOk(s, _, _, ValidateAction(Block(stmts))) :-\n    stmtsOk(s, stmts, UNTYPED()).\n\nrules // statements\n\n  stmtOk(s, _, r@Return(_), PAGE(_, _)) :- false | error $[Expected page call in return statement].\n  stmtOk(s, _, r@Return(ThisCall2Exp(ThisCall(p, exps))), PAGE(_, _)) :-\n    pageCallOk_internal(s, p, exps).\n\n  stmtOk(_, _, GoTo(pc), _) :- try { false } | warning $[This statement is not yet implemented].\n\nrules // expressions\n\n  // pass new scope as placeholder and action scope because passing `s`\n  // would introduce a CloseLabel exception in the concurrent solver.\n  // this causes any actions/placeholders references and declarations to fail\n  // but this is not a big deal since there's no use case for working with\n  // actions/placeholders in rendertemplate(...) and validatetemplate(...) calls\n\n  typeOfExp(s, RenderTemplateFunctionCall(tc)) = string(s) :-\n    templateCallOk(s, new, tc).\n\n  typeOfExp(s, ValidateTemplateFunctionCall(tc)) = string(s) :-\n    templateCallOk(s, new, tc).\n\nrules // template var arg exp\n\n  typeOfExp(s, e@TemplateVarArgExp(expVarArgs)) = LIST(t) :-\n    t == typeOfExpVarArgList(s, expVarArgs),\n    @e.type := t.\n\n  typeOfExpVarArgList : scope * list(ExpVarArg) -&gt; TYPE\n  typeOfExpVarArgList(s, []) = UNTYPED() :- false | error $[Cannot infer the type of an empty list of ExpVarArgs].\n  typeOfExpVarArgList(s, [hd | tl]) = t :-\n    t == typeOfExpVarArg(s, hd),\n    expVarArgsCompatible(s, tl, t).\n\n  expVarArgsCompatible : scope * list(ExpVarArg) * TYPE\n  expVarArgsCompatible(_, [], _).\n  expVarArgsCompatible(s, [hd | tl], T1) :- { T2 }\n    T2 == typeOfExpVarArg(s, hd),\n    typeCompatible(T2, T1) | error $[Type of [hd] must be compatible [T1], [T2] given]@hd,\n    expVarArgsCompatible(s, tl, T1).\n\n  typeOfExpVarArg : scope * ExpVarArg -&gt; TYPE\n  typeOfExpVarArg(s, ExpVarArg(expsOrTemplateArgs)) = TEMPLATEVARARG(ts, new) :-\n    ts == typesOfExpOrTemplateArgs(s, expsOrTemplateArgs).\n\n  typeOfExpVarArg(s, ExpVarArgFor(x, srt, exp, OptFilterSome(f), expVarArgs)) = t :- { s_for typeOfSort typeOfExp }\n    typeOfSort == typeOfSort(s, srt),\n    typeOfExp == typeOfExp(s, exp),\n    or(\n      equalTypeB(LIST(typeOfSort), typeOfExp),\n      equalTypeB(SET(typeOfSort), typeOfExp)\n    ) | error $[Must be a list or set of type [typeOfSort], [typeOfExp] given] @exp,\n    new s_for, s_for -P-&gt; s,\n    forLoopFilterOk(s_for, f),\n    declareVar(s_for, x, typeOfSort),\n    declareAnnotation(s_for, x, DERIVED()), // abuse derived annotation to declare immutability of x\n    t == typeOfExpVarArgList(s_for, expVarArgs),\n    @x.type := typeOfSort.\n\n  typeOfExpVarArg(s, ExpVarArgForInferred(x, exp, OptFilterSome(f), expVarArgs)) = t :- { s_for typeOfExp typeOfSort }\n    typeOfExp == typeOfExp(s, exp),\n    typeOfSort == stripGenericType(typeOfExp),\n    new s_for, s_for -P-&gt; s,\n    forLoopFilterOk(s_for, f),\n    declareVar(s_for, x, typeOfSort),\n    declareAnnotation(s_for, x, DERIVED()), // abuse derived annotation to declare immutability of x\n    t == typeOfExpVarArgList(s_for, expVarArgs),\n    @x.type := typeOfSort.\n\n  typeOfExpVarArg(s, ExpVarArgForAll(x, srt, OptFilterSome(f), expVarArgs)) = t :- { s_for typeOfSort }\n    typeOfSort == typeOfSort(s, srt),\n    new s_for, s_for -P-&gt; s,\n    forLoopFilterOk(s_for, f),\n    declareVar(s_for, x, typeOfSort),\n    declareAnnotation(s_for, x, DERIVED()), // abuse derived annotation to declare immutability of x\n    t == typeOfExpVarArgList(s_for, expVarArgs),\n    @x.type := typeOfSort.\n\n  typeOfExpVarArg(s, ExpVarArgForCount(x, e1, e2, expVarArgs)) = t :- { s_for int t1 t2 }\n    int == int(s),\n    typeCompatible(typeOfExp(s, e1), int) | error $[Expression must be compatible with type Int] @e1,\n    typeCompatible(typeOfExp(s, e2), int) | error $[Expression must be compatible with type Int] @e2,\n    new s_for, s_for -P-&gt; s,\n    declareVar(s_for, x, int),\n    declareAnnotation(s_for, x, DERIVED()), // abuse derived annotation to declare immutability of x\n    t == typeOfExpVarArgList(s_for, expVarArgs),\n    @x.type := int.\n\nrules // exp or template arg\n\n  typesOfExpOrTemplateArgs maps typeOfExpOrTemplateArg(*, list(*)) = list(*)\n  typeOfExpOrTemplateArg : scope * ExpOrTemplateArg -&gt; TYPE\n  typeOfExpOrTemplateArg(s, ExpVarArgExp(exp)) = t :-\n    t == typeOfExp(s, exp).\n\n  typeOfExpOrTemplateArg(s, ExpVarArgElements(elems)) = TEMPLATEELEMENTS() :- { s_eval }\n    new s_eval, s_eval -P-&gt; s,\n    templateElementsOk(s_eval, new, elems).\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/ui/actions.stx/#modal-h2","title":"actions.stx","text":""},{"location":"webdslstatix/trans/static-semantics/ui/ajax.stx/","title":"<code>ajax.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/ui/ajax.stx</p> <pre><code>module static-semantics/ui/ajax\n\nimports\n  static-semantics/types/built-ins\n\n  static-semantics/ui/template-calls\n\n  static-semantics/webdsl-ui\n  static-semantics/webdsl\n\nrules // placeholders and ajax\n\n  templateElementOk(s, _, s_pha, TEPlaceholder(PlaceholderHtml(_, ph, elems))) :-\n    declarePlaceholder(s_pha, ph),\n    templateElementsOk(s, s_pha, elems).\n\n  templateElementOk(s, _, s_pha, TEPlaceholder(PlaceholderHtmlExp(_, e, elems))) :-\n    typeCompatible(typeOfExp(s, e), string(s)) | error $[Expression should be compatible with String],\n    templateElementsOk(s, s_pha, elems).\n\n  templateElementOk(s, _, s_pha, TEPlaceholder(Placeholder(ph, elems))) :-\n    declarePlaceholder(s_pha, ph),\n    templateElementsOk(s, s_pha, elems).\n\n  templateElementOk(s, _, s_pha, TEPlaceholder(PlaceholderExp(e, elems))) :-\n    typeCompatible(typeOfExp(s, e), string(s)) | error $[Expression should be compatible with String],\n    templateElementsOk(s, s_pha, elems).\n\n  templateElementOk(s, _, s_pha, TEPlaceholderWithAjaxCall(PlaceholderAjaxHtml(_, ph, tc))) :-\n    declarePlaceholder(s_pha, ph),\n    templateCallOk(s, s_pha, tc).\n\n  templateElementOk(s, _, s_pha, TEPlaceholderWithAjaxCall(PlaceholderAjaxHtmlExp(_, e, tc))) :-\n    typeCompatible(typeOfPlaceholderExp(s, e), string(s)) | error $[Expression should be compatible with String],\n    templateCallOk(s, s_pha, tc).\n\n  templateElementOk(s, _, s_pha, TEPlaceholderWithAjaxCall(PlaceholderAjax(ph, tc))) :-\n    declarePlaceholder(s_pha, ph),\n    templateCallOk(s, s_pha, tc).\n\n  templateElementOk(s, _, s_pha, TEPlaceholderWithAjaxCall(PlaceholderAjaxExp(e, tc))) :-\n    typeCompatible(typeOfPlaceholderExp(s, e), string(s)) | error $[Expression should be compatible with String],\n    templateCallOk(s, s_pha, tc).\n\nrules // ajax statements\n\n  stmtOk(s, _, AjaxStatement(stmt), _) :- ajaxStmtOk(s, stmt).\n\n  ajaxStmtOk : scope * AjaxStatement\n\n  ajaxStmtOk(s, AjaxReplace(ph, AjaxReplaceTemplateCall(tc))) :-\n    ajaxPlaceholderExpressionOk(s, ph),\n    ajaxTemplateCallOk(s, s, tc)\n      | error $[An ajax-enabled template must be called here] @tc. // correct error message for tests\n\n  ajaxStmtOk(s, AjaxAppend(ph, tc)) :-\n    ajaxPlaceholderExpressionOk(s, ph),\n    ajaxTemplateCallOk(s, s, tc)\n      | error $[An ajax-enabled template must be called here] @tc. // correct error message for tests\n\n  ajaxStmtOk(s, AjaxVisibility(ph, _)) :-\n    ajaxPlaceholderExpressionOk(s, ph).\n\n  ajaxStmtOk(s, AjaxRelocate(pc)) :-\n    pageCallOk(s, pc).\n\n  ajaxStmtOk(s, AjaxRestyle(ph, e)) :-\n    ajaxPlaceholderExpressionOk(s, ph),\n    typeCompatible(typeOfExp(s, e), string(s)) | error $[CSS classname must be compatible with type String] @e.\n\n  ajaxStmtOk(s, AjaxClear(ph)) :-\n    ajaxPlaceholderExpressionOk(s, ph).\n\n  ajaxStmtOk(s, AjaxRefresh()).\n\n  ajaxStmtOk(s, AjaxRunScript(e)) :-\n    typeCompatible(typeOfExp(s, e), string(s)) | error $[Javascript code must be compatible with type String] @e.\n\n  ajaxPlaceholderExpressionOk : scope * Exp\n  ajaxPlaceholderExpressionOk(s, e) :-\n    typeCompatible(typeOfExp(s, e), string(s))\n      | error $[Expression should be compatible with type string or a placeholder variable] @e.\n\n  ajaxPlaceholderExpressionOk(s, e@Var(ph)) :- { s_next r }\n    resolvePlaceholder(s, ph) == r,\n    new s_next, s_next -P-&gt; s,\n    ajaxPlaceholderExpressionResultOk(s_next, r, e).\n\n  ajaxPlaceholderExpressionResultOk : scope * list((path * (string * TYPE))) * Exp\n  ajaxPlaceholderExpressionResultOk(s, r, e) :- false | error $[Unexpected input? r: [r], e: [e]].\n  ajaxPlaceholderExpressionResultOk(s, [_ | _], _).\n\n  ajaxPlaceholderExpressionResultOk(s, [], e) :-\n    typeCompatible(typeOfExp(s, e), string(s)) | error $[Type of expression [e] is not compatible with String or Placeholder] @e.\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/ui/ajax.stx/#modal-h2","title":"ajax.stx","text":""},{"location":"webdslstatix/trans/static-semantics/ui/attributes.stx/","title":"<code>attributes.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/ui/attributes.stx</p> <pre><code>module static-semantics/ui/attributes\n\nimports\n  static-semantics/types/built-ins\n\n  static-semantics/webdsl-types\n  static-semantics/webdsl\n\nsignature\n  relations\n    attributeCollection : string\n\nrules // attribute collection declaration and resolving\n\n  declareAttributeCollection : scope * string\n  declareAttributeCollection(s, c) :-\n    !attributeCollection[c] in s,\n    resolveAttributeCollection(s, c) == [_] | error $[Attribute collection with name [c] is defined multiple times. Use \"override\" modifier to replace existing attribute collections]. // correct error message for tests\n\n  resolveAttributeCollection : scope * string -&gt; list((path * string))\n  resolveAttributeCollection(s, c) = ps :-\n    query attributeCollection\n      filter P* F* ((EXTEND? INHERIT*) | (DEF? (IMPORT | IMPORTLIB)?))\n      and { c' :- c' == c }\n      in s |-&gt; ps.\n\nrules // attributes\n\n  attributesOk maps attributeOk(*, list(*))\n  attributeOk : scope * Attribute\n  attributeOk(s, a@AttributeSelection2Attribute(_)) :- try { false } | warning $[This UI attribute is not implemented yet] @a.\n  attributeOk(s, AttributeExpandLocal(_, _, _)) :- try { false } | warning $[This UI attribute is not implemented yet].\n\n  attributeOk(s, Attribute(_, exp)) :- typed(s, exp).\n  attributeOk(s, XMLAttributesIf(c, attributes)) :-\n    equalType(typeOfExp(s, c), bool(s)) | error $[Condition should be of type bool] @c,\n    attributesOk(s, attributes).\n\n  attributeOk(s, XMLAttributesIfElse(c, attributes_if, attributes_else)) :-\n    equalType(typeOfExp(s, c), bool(s)) | error $[Condition should be of type bool] @c,\n    attributesOk(s, attributes_if),\n    attributesOk(s, attributes_else).\n\n  attributeOk(s, CommonAttribute2Attribute(ca)) :- commonAttributeOk(s, ca).\n\n  commonAttributeOk : scope * CommonAttribute\n  commonAttributeOk(_, _) :- try { false } | warning $[This common attribute is not yet implemented].\n  commonAttributeOk(s, AllAttributes()).\n  commonAttributeOk(s, AllAttributesExceptExp(exp)) :- {t}\n    t == typeOfExp(s, exp),\n    or(\n      typeCompatibleB(string(s), t),\n      orB(\n        typeCompatibleB(LIST(string(s)), t),\n        typeCompatibleB(SET(string(s)), t)\n      )\n    ) | error $[Attribute names should be of type String, List of String of Set of String, but type [t] given] @exp.\n\n  commonAttributeOk(s, AttributesExp(exp)) :- {t}\n    t == typeOfExp(s, exp),\n    or(\n      typeCompatibleB(string(s), t),\n      orB(\n        typeCompatibleB(LIST(string(s)), t),\n        typeCompatibleB(SET(string(s)), t)\n      )\n    ) | error $[Attribute names should be of type String, List of String of Set of String, but type [t] given] @exp.\n\nrules // attribute collections\n\n  defOk(s, AttributeCollection(AttributeCollectionOverrideNone(), c, attrs)) :-\n    declareAttributeCollection(s, c).\n\n  defOk(s, AttributeCollection(AttributeCollectionOverride(), c, attrs)) :- {c'}\n    resolveAttributeCollection(s, c) == [(_, c')] | error $[Attribute collection with name [c] not defined] @c, // correct error message for tests\n    @c.ref := c'.\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/ui/attributes.stx/#modal-h2","title":"attributes.stx","text":""},{"location":"webdslstatix/trans/static-semantics/ui/built-ins.stx/","title":"<code>built-ins.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/ui/built-ins.stx</p> <pre><code>module static-semantics/ui/built-ins\n\nimports\n  static-semantics/types/built-ins\n\n  static-semantics/ui/template-calls\n\n  static-semantics/webdsl\n  static-semantics/webdsl-ui\n\nrules\n\n  declareUIBuiltIns : scope\n  declareUIBuiltIns(s) :-\n    declareTemplate(s, \"title\", []),\n    declareTemplate(s, \"text\", [object(s)]),\n    declareTemplate(s, \"image\", [url(s)]),\n    declareTemplate(s, \"header\", []),\n    declareTemplate(s, \"section\", []),\n//    declTemplate(s, \"url\", [url(s)], []), // TO-DO: investigate if url is template or pageplaceholde\n    declareTemplate(s, \"form\", []),\n    declareTemplate(s, \"dynamicform\", []),\n    declareTemplate(s, \"captcha\", []),\n    declareTemplate(s, \"input\", [object(s)]),\n    declareTemplate(s, \"output\", [object(s)]),\n\n//    declareTemplate(s, \"navigate\", []),\n//    declareTemplate(s, \"navigate\", [url(s)]),\n//    declareTemplate(s, \"navigate\", [PAGE(_)]), // disable PAGE(_) declarations for now since they are producing nabl2.Var in libraries\n//    declareTemplate(s, \"navigate\", [string(s), url(s)]),\n//    declareTemplate(s, \"navigate\", [string(s), PAGE(_)]), // disable PAGE(_) declarations for now since they are producing nabl2.Var in libraries\n//    declareTemplate(s, \"navigatebutton\", [PAGE(_), string(s)]), // disable PAGE(_) declarations for now since they are producing nabl2.Var in libraries\n    declareTemplate(s, \"navigatebutton\", [url(s), string(s)]),\n\n    declareTemplate(s, \"includeCSS\", [string(s)]),\n    declareTemplate(s, \"includeCSS\", [string(s), string(s)]),\n    declareTemplate(s, \"includeJS\", [string(s)]),\n    declareTemplate(s, \"includeJSLast\", [string(s)]),\n    declareTemplate(s, \"includeHead\", [string(s)]),\n\n    declareTemplate(s, \"templateContext\", [string(s)]),\n\n    declarePage(s, \"url\", [string(s)]).\n\nrules // navigate function call\n\n  typeOfExp(s, ThisCall2Exp(ThisCall(\"navigate\", [ThisCall2Exp(ThisCall(p, args))]))) = string(s) :-\n    pageCallOk_internal(s, p, args).\n\n  typeOfExp(s, ThisCall2Exp(ThisCall(\"navigate\", [_]))) = UNTYPED() :-\n    false | error $[Navigate function should have a page call or url(...) argument].\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/ui/built-ins.stx/#modal-h2","title":"built-ins.stx","text":""},{"location":"webdslstatix/trans/static-semantics/ui/template-calls.stx/","title":"<code>template-calls.stx</code>","text":"<p> pdmosses/webdsl-statix/webdslstatix/trans/static-semantics/ui/template-calls.stx</p> <pre><code>module static-semantics/ui/template-calls\n\nimports\n  static-semantics/actions/functions\n\n  static-semantics/entities/annotations\n\n  static-semantics/types/built-ins\n\n  static-semantics/ui/actions\n  static-semantics/ui/attributes\n\n  static-semantics/webdsl-actions\n  static-semantics/webdsl-types\n  static-semantics/webdsl-ui\n  static-semantics/webdsl\n\nrules // template calls\n\n  templateElementOk(s, _, s_pha, TemplateCall2TemplateElement(tc)) :-\n    templateCallOk(s, s_pha, tc).\n\n  ajaxTemplateCallOk : scope * scope * TemplateCall\n  ajaxTemplateCallOk(s, s_pha, tc) :- templateCallOk_internal(s, s_pha, tc, TRUE()).\n\n  templateCallOk : scope * scope * TemplateCall\n  templateCallOk(s, s_pha, tc) :- templateCallOk_internal(s, s_pha, tc, FALSE()).\n\n  // BOOL denotes if template must be ajax enabled\n  templateCallOk_internal : scope * scope * TemplateCall * BOOL\n  templateCallOk_internal(s, s_pha, TemplateCall(TemplateCallId(t), TCallArgs(targs), TCallPropAssigns(propAssigns), TemplateBody(body)), ajax) :-\n    templatePropAssignmentsOk(s, propAssigns),\n    templateElementsOk(s, s_pha, body),\n    templateCallMatchesSig(s, t, targs, ajax).\n\n  // BOOL denotes if template must be ajax enabled\n  templateCallMatchesSig : scope * string * list(TemplateArgExp) * BOOL\n  templateCallMatchesSig(s, t, targs, ajax) :- {argTypes nameCompatibleSigs mostSpecificSigs t'}\n    argTypes == typesOfTemplateArgExps(s, targs),\n    inputTemplateCallOk(s, t, targs, argTypes),\n    nameCompatibleSigs == resolveTemplate_internal(s, t, ajax),\n    mostSpecificSigs == mostSpecificSigs(argTypes, typeCompatibleSigs(nameCompatibleSigs, argTypes)),\n    mostSpecificSigs == [(t', TEMPLATE(_, _, _)) | _] | error $[Cannot resolve template [t] with compatible argument types] @t,\n    singleSignature(mostSpecificSigs, \"template\", t) | error $[Cannot resolve template [t] with compatible argument types] @t,\n    @t.ref := t'.\n\n  typesOfTemplateArgExps maps typeOfTemplateArgExp(*, list(*)) = list(*)\n  typeOfTemplateArgExp : scope * TemplateArgExp -&gt; TYPE\n  typeOfTemplateArgExp(s, Exp(exp))                      = typeOfExp(s, exp).\n  typeOfTemplateArgExp(s, TemplateElementsArgument(exp)) = TEMPLATEELEMENTS().\n  typeOfTemplateArgExp(s, ExpEntityDerive(_, _))         = UNTYPED() :- // TO-DO\n    try { false } | warning $[Derive expressions not implemented yet].\n\nrules // pre-defined template calls\n\n  // elements\n  templateCallOk(_, _, TemplateCall(TemplateCallId(\"elements\"), TCallArgs(targs), TCallPropAssigns(propAssigns), TemplateBody(body))) :-\n    targs == [] | error $[Cannot pass arguments to passed template elements],\n    body == []  | error $[Cannot pass template elements to passed template elements].\n\n  // validation\n  templateCallOk(s, _, ValidationErrors(_)).\n  templateCallOk(s, _, ValidationErrorsEmpty()).\n\n  // navigatebutton\n  templateCallOk(s, s_pha, tc@TemplateCall(TemplateCallId(\"navigatebutton\"), TCallArgs([Exp(ThisCall2Exp(ThisCall(\"url\", _))) | _]), _, _)) :-\n    templateCallOk_internal(s, s_pha, tc, FALSE()).\n\n  templateCallOk(s, s_pha, tc@TemplateCall(TemplateCallId(t@\"navigatebutton\"), TCallArgs([Exp(ThisCall2Exp(ThisCall(p, args))) | [Exp(e)]]), _, _)) :-\n    typeCompatible(typeOfExp(s, e), string(s)) | error $[Cannot resolve template [t] with compatible argument types] @tc,\n    pageCallOk_internal(s, p, args).\n\nrules // navigate calls\n\n  templateElementOk(s, _, s_pha, NavigateCall(pc, props, elems)) :-\n    pageCallOk(s, pc),\n    templatePropAssignmentsOk(s, props),\n    templateElementsOk(s, s_pha, elems).\n\n  pageCallOk : scope * PageCall\n  pageCallOk(s, PageCall(p, args)) :-\n    pageCallOk_internal(s, p, args).\n\n  pageCallOk_internal : scope * string * list(Exp)\n  pageCallOk_internal(s, p, args) :- {argTypes ts}\n    pageType(s, p) == PAGE(_, ts) | error $[There is no page with signature [p]] @p, // correct error message for tests\n    argTypes == typesOfExps(s, args),\n    typesCompatible(argTypes, ts) == TRUE() | error $[Given argument types not compatible with page definition. Got [argTypes] but expected [ts]] @args.\n\n  pageCallOk_internal(_, \"root\", []). // root page is always accessible from all locations\n\nrules // property assignments\n\n  templatePropAssignmentsOk : scope * list(PropertyAssignment)\n  templatePropAssignmentsOk(s, pas) :- templatePropAssignmentsOkNoDuplicates(s, pas, []).\n\n  templatePropAssignmentsOkNoDuplicates : scope * list(PropertyAssignment) * list(string)\n  templatePropAssignmentsOkNoDuplicates(_, [], _).\n  templatePropAssignmentsOkNoDuplicates(s, [pa | pas], xs) :- {x}\n    x == templatePropAssignmentOk(s, pa),\n    noDuplicatesString(x, xs) | error $[Properties are defined multiple times: [x]] @x, // correct error message for tests\n    templatePropAssignmentsOkNoDuplicates(s, pas, [x | xs]).\n\n  templatePropAssignmentOk : scope * PropertyAssignment -&gt; string // return name of property for duplicate check\n  templatePropAssignmentOk(s, _) = \"_IGNORE\" :- // TO-DO\n    try { false } | warning $[This template property assignment is not implemented yet].\n\n  templatePropAssignmentOk(s, PropertyAssignment(x, e)) = x :-\n    typeCompatible(typeOfExp(s, e), string(s)) | error $[Property [x] requires a String value] @e.\n\n  templatePropAssignmentOk(s, PropertySubmit(x, a)) = x :-\n    actionCallOrInlineOrExpOk(s, a).\n\n  templatePropAssignmentOk(s, AttributeSelection2PropertyAssignment(AttributeIgnoreDefault(c@\"class\"))) = \"_IGNORE\".\n  templatePropAssignmentOk(s, AttributeSelection2PropertyAssignment(AttributeIgnoreDefault(c@\"style\"))) = \"_IGNORE\".\n  templatePropAssignmentOk(s, AttributeSelection2PropertyAssignment(AttributeIgnoreDefault(_))) = \"_IGNORE\" :-\n    false | error $[Only \"class\" and \"style\" are implicitly combined with defaults].\n\n  templatePropAssignmentOk(s, CommonAttribute2PropertyAssignment(ca)) = \"_IGNORE\" :-\n    commonAttributeOk(s, ca).\n\n  templatePropAssignmentOk(s, AttributeSelection2PropertyAssignment(AttributeSelection(a))) = \"_IGNORE\" :- { a' }\n    resolveAttributeCollection(s, a) == [(_, a') | _] | error $[Attribute collection [a] is not defined],\n    @a.ref := a'.\n\nrules // mutability check for input templates\n\n  inputTemplateCallOk : scope * string * list(TemplateArgExp) * list(TYPE)\n  inputTemplateCallOk(s, _, _, _). // all other template calls are ok\n  inputTemplateCallOk(s, \"input\", [Exp(e) | _], [t | _]) :- isMutableExp(s, e, t).\n\n  isMutableExp : scope * Exp * TYPE\n  isMutableExp(_, e, t) :- false | error $[Cannot verify mutability of expression [e]] @e.\n  isMutableExp(s, Var(x), t) :- isMutableOrRef(s, x, t).\n  isMutableExp(s, Cast(_, sort), t) :- typeOfSort(s, sort) == REF(_).\n  isMutableExp(s, FieldAccess(FAVar(var), x), t) :- {varType}\n    varType == variableType(s, var),\n    isMutableProperty(varType, x).\n\n</code></pre> \u00d7"},{"location":"webdslstatix/trans/static-semantics/ui/template-calls.stx/#modal-h2","title":"template-calls.stx","text":""}]}